{"id": "1", "text": "Given a list of numbers, return whether any two sums to k.\nFor example, given [10, 15, 3, 7] and k of 17, return true since 10 + 7 is 17.\n\nBonus: Can you do this in one pass?", "solution": "def check_sums(array, k):\n    potential_solutions = set()\n    for num in array:\n        if num in potential_solutions:\n            return True\n        potential_solutions.add(k - num)\n    return False", "title": "IE/1", "entry_cls_name": "Solution", "testing_code": "assert not check_sums([], 17)\nassert check_sums([10, 15, 3, 7], 17)\nassert not check_sums([10, 15, 3, 4], 17)\nassert check_sums([2, 7, 11, 15], 9) == True\nassert check_sums([], 19) == False\nassert check_sums([2, 11, 99, 15], 26) == True\nassert check_sums([2, 11, 99, 16], 26) == False", "entry_fn_name": "check_sums"}
{"id": "2", "text": "Given an array of integers, return a new array such that each element at index i of the new array is the product of all the numbers in the original array except the one at i.\n\nFor example, if our input was [1, 2, 3, 4, 5], the expected output would be [120, 60, 40, 30, 24]. If our input was [3, 2, 1], the expected output would be [2, 3, 6].\n\nFollow-up: what if you can't use division?", "solution": "def get_factors(array):\n    if not array or len(array)==1: return array\n    cumulative_product = 1\n    right_prod_array = list()\n    for num in array:\n        cumulative_product *= num\n        right_prod_array.append(cumulative_product)\n    cumulative_product = 1\n    left_prod_array = list()\n    for num in array[::-1]:\n        cumulative_product *= num\n        left_prod_array.append(cumulative_product)\n    left_prod_array = left_prod_array[::-1]\n    output_array = list()\n    for i in range(len(array)):\n        num = None\n        if i == 0:\n            num = left_prod_array[i + 1]\n        elif i == len(array) - 1:\n            num = right_prod_array[i - 1]\n        else:\n            num = right_prod_array[i - 1] * left_prod_array[i + 1]\n        output_array.append(num)\n    return output_array", "title": "IE/2", "entry_cls_name": "Solution", "testing_code": "assert get_factors([1, 2, 3, 4, 5]) == [120, 60, 40, 30, 24]\nassert get_factors([3, 2, 1]) == [2, 3, 6]", "entry_fn_name": "get_factors"}
{"id": "4", "text": "Given an array of integers, find the first missing positive integer in linear time and constant space. In other words, find the lowest positive integer that does not exist in the array. The array can contain duplicates and negative numbers as well.\n\nFor example, the input [3, 4, -1, 1] should give 2. The input [1, 2, 0] should give 3.\n\nYou can modify the input array in-place.", "solution": "def get_positive_subset(array):\n    i = 0\n    j = len(array) - 1\n    while i < j:\n        if array[i] > 0 and array[j] <= 0:\n            (array[i], array[j]) = (array[j], array[i])\n            i += 1\n            j -= 1\n        elif array[i] > 0:\n            j -= 1\n        else:\n            i += 1\n    pivot = i if array[i] > 0 else i + 1\n    return array[pivot:]\ndef get_missing_number(array):\n    if not array:\n        return 1\n    array = get_positive_subset(array)\n    array_len = len(array)\n    if not array:\n        return 1\n    if max(array) == len(array):\n        return max(array) + 1\n    for num in array:\n        current_num = abs(num)\n        if current_num - 1 < array_len:\n            array[current_num - 1] *= -1\n    for (i, num) in enumerate(array):\n        if num > 0:\n            return i + 1", "title": "IE/4", "entry_cls_name": "Solution", "testing_code": "assert get_missing_number([3, 4, -1, 1]) == 2\nassert get_missing_number([1, 2, 0]) == 3\nassert get_missing_number([1, 2, 5]) == 3\nassert get_missing_number([1]) == 2\nassert get_missing_number([-1, -2]) == 1\nassert get_missing_number([]) == 1\nassert get_missing_number([0, 6, -1, 5, 4]) == 1\nassert get_missing_number([1, 2, 3, 4]) == 5\nassert get_missing_number([1, 2, 4, 5]) == 3\nassert get_missing_number([-1, -2, -4, -5]) == 1\nassert get_missing_number([7, 8, 9, 11, 12]) == 1", "entry_fn_name": "get_missing_number"}
{"id": "7", "text": "Given the mapping a = 1, b = 2, ... z = 26, and an encoded message, count the number of ways it can be decoded.\n\nFor example, the message '111' would give 3, since it could be decoded as 'aaa', 'ka', and 'ak'.\n\nYou can assume that the messages are decodable. For example, '001' is not allowed.", "solution": "def get_message_count(code_str):\n    c = [0]*len(code_str) + [1]\n\n    for i in range(len(code_str)-1,-1,-1):\n        if code_str[i].startswith('0'):\n            c[i] = 0\n        elif i == len(code_str) - 1:\n            c[i] = 1\n        else:\n            if int(code_str[i:i + 2]) <= 26:\n                c[i] = c[i + 2]\n            c[i] += c[i + 1]\n    return c[0]", "title": "IE/7", "entry_cls_name": "Solution", "testing_code": "\nassert get_message_count(\"81\") == 1\nassert get_message_count(\"11\") == 2\nassert get_message_count(\"111\") == 3\nassert get_message_count(\"1111\") == 5\nassert get_message_count(\"1311\") == 4\nassert get_message_count(\"1118111111131111111111111111111111111111111111333333333333333333333262626262626\") == 162442229760", "entry_fn_name": "get_message_count"}
{"id": "8", "text": "A unival tree (which stands for \"universal value\") is a tree where all nodes under it have the same value.\n\nGiven the root to a binary tree, count the number of unival subtrees.\n\nFor example, the following tree has 5 unival subtrees:\n\n```\n   0\n  / \\\n 1   0\n    / \\\n   1   0\n  / \\\n 1   1\n```", "solution": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\n    def __repr__(self):\n        return str(self.data)\ndef count_unival_trees(root):\n    if not root:\n        return 0\n    elif not root.left and (not root.right):\n        return 1\n    elif not root.left and root.data == root.right.data:\n        return 1 + count_unival_trees(root.right)\n    elif not root.right and root.data == root.left.data:\n        return 1 + count_unival_trees(root.left)\n    child_counts = count_unival_trees(root.left) + count_unival_trees(root.right)\n    current_node_count = 0\n    if root.data == root.left.data and root.data == root.left.data:\n        current_node_count = 1\n    return current_node_count + child_counts", "title": "IE/8", "entry_cls_name": "Solution", "testing_code": "node_a = Node('0')\nnode_b = Node('1')\nnode_c = Node('0')\nnode_d = Node('1')\nnode_e = Node('0')\nnode_f = Node('1')\nnode_g = Node('1')\nnode_a.left = node_b\nnode_a.right = node_c\nnode_c.left = node_d\nnode_c.right = node_e\nnode_d.left = node_f\nnode_d.right = node_g\nassert count_unival_trees(None) == 0\nassert count_unival_trees(node_a) == 5\nassert count_unival_trees(node_c) == 4\nassert count_unival_trees(node_g) == 1\nassert count_unival_trees(node_d) == 3", "entry_fn_name": "count_unival_trees"}
{"id": "11", "text": "Implement an autocomplete system. That is, given a query string s and a set of all possible query strings, return all strings in the set that have s as a prefix.\n\nFor example, given the query string de and the set of strings [dog, deer, deal], return [deer, deal].\n\nHint: Try preprocessing the dictionary into a more efficient data structure to speed up queries.", "solution": "def add_to_trie(s, trie):\n    if not s:\n        return trie\n    character = s[0]\n    if character not in trie:\n        trie[character] = dict()\n    trie[character] = add_to_trie(s[1:], trie[character])\n    return trie\ndef get_dictionary_trie(dictionary):\n    trie = dict()\n    for word in dictionary:\n        trie = add_to_trie(word, trie)\n    return trie\ndef get_possible_completions(trie):\n    possible_completions = list()\n    for character in trie:\n        if trie[character]:\n            child_completions = get_possible_completions(trie[character])\n            for child_completion in child_completions:\n                possible_completions.append(character + child_completion)\n        else:\n            possible_completions.append(character)\n    return possible_completions\ndef get_autocomplete_suggestions(s, dictionary):\n    trie = get_dictionary_trie(dictionary)\n    current_trie = trie\n    for character in s:\n        if character not in current_trie:\n            return []\n        current_trie = current_trie[character]\n    completions = get_possible_completions(current_trie)\n    completions = [s + x for x in completions]\n    return completions", "title": "IE/11", "entry_cls_name": "Solution", "testing_code": "assert get_autocomplete_suggestions('de', ['dog', 'deer', 'deal']) == ['deer', 'deal']\nassert get_autocomplete_suggestions('ca', ['cat', 'car', 'cer']) == ['cat', 'car']\nassert get_autocomplete_suggestions('ae', ['cat', 'car', 'cer']) == []\nassert get_autocomplete_suggestions('ae', []) == []\nassert get_autocomplete_suggestions('f', ['dog', 'deer', 'deal', 'cat']) == []", "entry_fn_name": "get_autocomplete_suggestions"}
{"id": "12", "text": "There exists a staircase with N steps, and you can climb up either 1 or 2 steps at a time. Given N, write a function that returns the number of unique ways you can climb the staircase. The order of the steps matters.\n\nFor example, if N is 4, then there are 5 unique ways:\n\n```\n1, 1, 1, 1\n2, 1, 1\n1, 2, 1\n1, 1, 2\n2, 2\n```\n\nWhat if, instead of being able to climb 1 or 2 steps at a time, you could climb any number from a set of positive integers X? For example, if X = {1, 3, 5}, you could climb 1, 3, or 5 steps at a time.", "solution": "def get_step_combos(num_steps, step_sizes):\n    combos = list()\n    if num_steps < min(step_sizes):\n        return combos\n    for step_size in step_sizes:\n        if num_steps == step_size:\n            combos.append([step_size])\n        elif num_steps > step_size:\n            child_combos = get_step_combos(num_steps - step_size, step_sizes)\n            for child_combo in child_combos:\n                combos.append([step_size] + child_combo)\n    return combos", "title": "IE/12", "entry_cls_name": "Solution", "testing_code": "assert get_step_combos(4, [1, 2]) == [[1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2]]\nassert get_step_combos(4, [1, 2, 3]) == [[1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [1, 3], [2, 1, 1], [2, 2], [3, 1]]", "entry_fn_name": "get_step_combos"}
{"id": "13", "text": "Given an integer k and a string s, find the length of the longest substring that contains at most k distinct characters.\n\nFor example, given s = \"abcba\" and k = 2, the longest substring with k distinct characters is \"bcb\".", "solution": "def get_longest_sub_with_k_dist(s, k):\n    if not s:\n        return ''\n    elif len(s) <= k:\n        return s\n    elif k == 1:\n        return s[0]\n    distinct_char_count = 0\n    seen_chars = set()\n    candidate = None\n    remaining_string = None\n    first_char = s[0]\n    second_char_index = 0\n    while s[second_char_index] == first_char:\n        second_char_index += 1\n    candidate = s\n    for (index, char) in enumerate(s):\n        if char not in seen_chars:\n            seen_chars.add(char)\n            distinct_char_count += 1\n        if distinct_char_count > k:\n            candidate = s[:index]\n            remaining_string = s[second_char_index:]\n            break\n    longest_remaining = get_longest_sub_with_k_dist(remaining_string, k)\n    longest_substring = None\n    if len(candidate) < len(longest_remaining):\n        longest_substring = longest_remaining\n    else:\n        longest_substring = candidate\n    return longest_substring", "title": "IE/13", "entry_cls_name": "Solution", "testing_code": "assert get_longest_sub_with_k_dist('abcba', 2) == 'bcb'\nassert get_longest_sub_with_k_dist('abccbba', 2) == 'bccbb'\nassert get_longest_sub_with_k_dist('abcbbbabbcbbadd', 2) == 'bbbabb'\nassert get_longest_sub_with_k_dist('abcbbbaaaaaaaaaabbcbbadd', 1) == 'a'\nassert get_longest_sub_with_k_dist('abccbba', 3) == 'abccbba'\nassert get_longest_sub_with_k_dist('abaacca', 2) == 'aacca'\nassert get_longest_sub_with_k_dist('eceba', 2) == 'ece'\nassert get_longest_sub_with_k_dist('aabbcc', 3) == 'aabbcc'\nassert get_longest_sub_with_k_dist('aaaccc', 2) == 'aaaccc'\nassert get_longest_sub_with_k_dist('abcbbbbcccbdddadacb', 2) == 'bcbbbbcccb'\nassert get_longest_sub_with_k_dist('abcadcacacaca', 3) == 'cadcacacaca'", "entry_fn_name": "get_longest_sub_with_k_dist"}
{"id": "14", "text": "The area of a circle is defined as r^2. Estimate \\pi to 3 decimal places using a Monte Carlo method.\n\nHint: The basic equation of a circle is x^2 + y^2 = r^2.", "solution": "from random import random\nradius = 2\ndef estimate_pi(num_random_tests):\n    pi_counter = 0\n    rsquared = radius ** 2\n    for _ in range(num_random_tests):\n        x_rand = random() * radius\n        y_rand = random() * radius\n        if x_rand ** 2 + y_rand ** 2 < rsquared:\n            pi_counter += 1\n    return 4 * pi_counter / num_random_tests", "title": "IE/14", "entry_cls_name": "Solution", "testing_code": "assert round(estimate_pi(100000000), 3) == 3.141", "entry_fn_name": "estimate_pi"}
{"id": "17", "text": "Suppose we represent our file system by a string in the following manner:\n\nThe string \"dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext\" represents:\n\n```\ndir\n    subdir1\n    subdir2\n        file.ext\n```\n\nThe directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext.\n\nThe string \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\" represents:\n\n```\ndir\n    subdir1\n        file1.ext\n        subsubdir1\n    subdir2\n        subsubdir2\n            file2.ext\n```\n\nThe directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext.\n\nWe are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is \"dir/subdir2/subsubdir2/file2.ext\", and its length is 32 (not including the double quotes).\n\nGiven a string representing the file system in the above format, return the length of the longest absolute path to a file in the abstracted file system. If there is no file in the system, return 0.", "solution": "def get_longest_path(fs: str) -> int:\n    paths = fs.split('\\n')\n    max_len = 0\n    path_lengths = {0: 0}\n    depth = 0\n    for path in paths:\n        name = path.strip()\n        depth = len(path)-len(name)\n        if '.' in name:\n            max_len = max(max_len, path_lengths[depth] + len(name))\n        else:\n            path_lengths[depth+1] = path_lengths[depth] + len(name) + 1\n    return max_len", "title": "IE/17", "entry_cls_name": "Solution", "testing_code": "assert get_longest_path('dir\\n\\tsubdir1\\n\\tsubdir2') == 0\nassert get_longest_path('dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext') == 20\nassert get_longest_path(\"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\") == 32", "entry_fn_name": "get_longest_path"}
{"id": "18", "text": "Given an array of integers and a number k, where 1 <= k <= length of the array, compute the maximum values of each subarray of length k.\n\nFor example, given array = [10, 5, 2, 7, 8, 7] and k = 3, we should get: [10, 7, 8, 8], since:\n\n```\n10 = max(10, 5, 2)\n7 = max(5, 2, 7)\n8 = max(2, 7, 8)\n8 = max(7, 8, 7)\n```\n\nDo this in O(n) time and O(k) space. You can modify the input array in-place and you do not need to store the results. You can simply print them out as you compute them.", "solution": "from collections import deque\ndef get_sliding_max(a, k):\n    window_max_elements = list()\n    if not a:\n        return None\n    if len(a) <= k:\n        return [max(a)]\n    dq = deque()\n    for i in range(k):\n        while dq and a[dq[-1]] < a[i]:\n            dq.pop()\n        dq.append(i)\n    window_max_elements.append(a[dq[0]])\n    for i in range(k, len(a)):\n        while dq and dq[0] <= i - k:\n            dq.popleft()\n        while dq and a[dq[-1]] < a[i]:\n            dq.pop()\n        dq.append(i)\n        window_max_elements.append(a[dq[0]])\n    return window_max_elements", "title": "IE/18", "entry_cls_name": "Solution", "testing_code": "assert get_sliding_max([10, 5, 2, 7, 8, 7], 3) == [10, 7, 8, 8]\nassert get_sliding_max([5, 2, 1], 2) == [5, 2]", "entry_fn_name": "get_sliding_max"}
{"id": "19", "text": "A builder is looking to build a row of N houses that can be of K different colors. He has a goal of minimizing cost while ensuring that no two neighboring houses are of the same color.\n\nGiven an N by K matrix where the nth row and kth column represents the cost to build the nth house with kth color, return the minimum cost which achieves this goal.", "solution": "import sys\ndef get_minimum_painting_cost(cost_matrix):\n    num_houses = len(cost_matrix)\n    num_colors = len(cost_matrix[0])\n    if not cost_matrix:\n        return 0\n    prev_house_min = 0\n    prev_house_min_index = -1\n    prev_house_second_min = 0\n    for i in range(num_houses):\n        curr_house_min = sys.maxsize\n        curr_house_second_min = sys.maxsize\n        curr_house_min_index = 0\n        for j in range(num_colors):\n            if prev_house_min_index == j:\n                cost_matrix[i][j] += prev_house_second_min\n            else:\n                cost_matrix[i][j] += prev_house_min\n            if curr_house_min > cost_matrix[i][j]:\n                curr_house_second_min = curr_house_min\n                curr_house_min = cost_matrix[i][j]\n                curr_house_min_index = j\n            elif curr_house_second_min > cost_matrix[i][j]:\n                curr_house_second_min = cost_matrix[i][j]\n        prev_house_min = curr_house_min\n        prev_house_second_min = curr_house_second_min\n        prev_house_min_index = curr_house_min_index\n    return min(cost_matrix[num_houses - 1])\nassert get_minimum_painting_cost( [[7, 3, 8, 6, 1, 2], [5, 6, 7, 2, 4, 3], [10, 1, 4, 9, 7, 6]]) == 4\nassert get_minimum_painting_cost([[7, 3, 8, 6, 1, 2], [5, 6, 7, 2, 4, 3], [10, 1, 4, 9, 7, 6], [10, 1, 4, 9, 7, 6]]) == 8", "title": "IE/19", "entry_cls_name": "Solution", "testing_code": "assert get_minimum_painting_cost( [[7, 3, 8, 6, 1, 2], [5, 6, 7, 2, 4, 3], [10, 1, 4, 9, 7, 6]]) == 4\nassert get_minimum_painting_cost([[7, 3, 8, 6, 1, 2], [5, 6, 7, 2, 4, 3], [10, 1, 4, 9, 7, 6], [10, 1, 4, 9, 7, 6]]) == 8", "entry_fn_name": "get_minimum_painting_cost"}
{"id": "21", "text": "Given an array of time intervals (start, end) for classroom lectures (possibly overlapping), find the minimum number of rooms required.\n\nFor example, given [(30, 75), (0, 50), (60, 150)], you should return 2.", "solution": "def get_num_classrooms(timing_tuples):\n    if not timing_tuples:\n        return 0\n    start_times = dict()\n    end_times = dict()\n    for (start, end) in timing_tuples:\n        if start not in start_times:\n            start_times[start] = 0\n        start_times[start] += 1\n        if end not in end_times:\n            end_times[end] = 0\n        end_times[end] += 1\n    (global_start, global_end) = (min(start_times), max(end_times))\n    max_class_count = 0\n    current_class_count = 0\n    for i in range(global_start, global_end):\n        if i in start_times:\n            current_class_count += start_times[i]\n            if current_class_count > max_class_count:\n                max_class_count = current_class_count\n        if i in end_times:\n            current_class_count -= end_times[i]\n    return max_class_count", "title": "IE/21", "entry_cls_name": "Solution", "testing_code": "assert get_num_classrooms([]) == 0\nassert get_num_classrooms([(30, 75), (0, 50), (60, 150)]) == 2\nassert get_num_classrooms([(30, 75), (0, 50), (10, 60), (60, 150)]) == 3\nassert get_num_classrooms([(60, 150)]) == 1\nassert get_num_classrooms([(60, 150), (150, 170)]) == 2\nassert get_num_classrooms([(60, 150), (60, 150), (150, 170)]) == 3\nassert get_num_classrooms([[30, 75], [0, 50], [60, 150]]) == 2\nassert get_num_classrooms([[0, 30], [5, 10], [15, 20]]) == 2\nassert get_num_classrooms([[0, 30], [30, 40], [15, 20]]) == 2\nassert get_num_classrooms([[0, 50], [0, 10], [0, 20]]) == 3\nassert get_num_classrooms([[0, 30], [30, 40], [40, 50]]) == 2", "entry_fn_name": "get_num_classrooms"}
{"id": "22", "text": "Given a dictionary of words and a string made up of those words (no spaces), return the original sentence in a list. If there is more than one possible reconstruction, return any of them. If there is no possible reconstruction, then return null.\n\nFor example, given the set of words 'quick', 'brown', 'the', 'fox', and the string \"thequickbrownfox\", you should return ['the', 'quick', 'brown', 'fox'].\n\nGiven the set of words 'bed', 'bath', 'bedbath', 'and', 'beyond', and the string \"bedbathandbeyond\", return either ['bed', 'bath', 'and', 'beyond] or ['bedbath', 'and', 'beyond'].", "solution": "def get_sentence_split(s, words):\n    if not s or not words:\n        return []\n    word_set = set(words)\n    sentence_words = list()\n    for i in range(len(s)):\n        if s[0:i + 1] in word_set:\n            sentence_words.append(s[0:i + 1])\n            word_set.remove(s[0:i + 1])\n            sentence_words += get_sentence_split(s[i + 1:], word_set)\n            break\n    return sentence_words", "title": "IE/22", "entry_cls_name": "Solution", "testing_code": "assert get_sentence_split('thequickbrownfox', ['quick', 'brown', 'the', 'fox']) == ['the', 'quick', 'brown', 'fox']\nassert get_sentence_split('bedbathandbeyond', ['bed', 'bath', 'bedbath', 'and', 'beyond']) == ['bed', 'bath', 'and', 'beyond']\nassert get_sentence_split('thequickbrownfox', ['the', 'quick', 'brown', 'fox']) == ['the', 'quick', 'brown', 'fox']", "entry_fn_name": "get_sentence_split"}
{"id": "23", "text": "You are given an M by N matrix consisting of booleans that represents a board. Each True boolean represents a wall. Each False boolean represents a tile you can walk on.\n\nGiven this matrix, a start coordinate, and an end coordinate, return the minimum number of steps required to reach the end coordinate from the start. If there is no possible path, then return null. You can move up, left, down, and right. You cannot move through walls. You cannot wrap around the edges of the board.\n\nFor example, given the following board:\n\n```\n[[f, f, f, f],\n [t, t, f, t],\n [f, f, f, f],\n [f, f, f, f]]\n```\n\nand start = (3, 0) (bottom left) and end = (0, 0) (top left), the minimum number of steps required to reach the end is 7, since we would need to go through (1, 2) because there is a wall everywhere else on the second row.", "solution": "from copy import deepcopy\ndef add_to_cache(coordinate, cache):\n    new_cache = deepcopy(cache)\n    new_cache.add('{}-{}'.format(coordinate[0], coordinate[1]))\n    return new_cache\ndef is_visited(coordinate, cache):\n    return '{}-{}'.format(coordinate[0], coordinate[1]) in cache\ndef find_path(matrix, rows, cols, start, end, cache):\n    if start == end:\n        return 0\n    cache = add_to_cache(start, cache)\n\n    def explore_neighbour(coordinate):\n        if not is_visited(coordinate, cache) and matrix[coordinate[0]][coordinate[1]] != 't':\n            path_length = find_path(matrix, rows, cols, coordinate, end, cache)\n            if path_length != None:\n                path_lengths.append(path_length)\n    path_lengths = list()\n    if start[0] != 0:\n        coordinate = (start[0] - 1, start[1])\n        explore_neighbour(coordinate)\n    if start[0] != rows - 1:\n        coordinate = (start[0] + 1, start[1])\n        explore_neighbour(coordinate)\n    if start[1] != 0:\n        coordinate = (start[0], start[1] - 1)\n        explore_neighbour(coordinate)\n    if start[1] != cols - 1:\n        coordinate = (start[0], start[1] + 1)\n        explore_neighbour(coordinate)\n    return min(path_lengths) + 1 if path_lengths else None", "title": "IE/23", "entry_cls_name": "Solution", "testing_code": "matrix = [['f', 'f', 'f', 'f'], ['t', 't', 'f', 't'], ['f', 'f', 'f', 'f'], ['f', 'f', 'f', 'f']]\nassert find_path(matrix, len(matrix), len(matrix[0]), (0, 0), (0, 0), set()) == 0\nassert find_path(matrix, len(matrix), len(matrix[0]), (1, 0), (0, 0), set()) == 1\nassert find_path(matrix, len(matrix), len(matrix[0]), (3, 0), (0, 0), set()) == 7\nassert find_path(matrix, len(matrix), len(matrix[0]), (3, 0), (0, 3), set()) == 6\nmatrix = [['f', 'f', 'f', 'f'], ['t', 't', 't', 'f'], ['f', 'f', 'f', 'f'], ['f', 'f', 'f', 'f']]\nassert find_path(matrix, len(matrix), len(matrix[0]), (0, 0), (0, 0), set()) == 0\nassert find_path(matrix, len(matrix), len(matrix[0]), (1, 0), (0, 0), set()) == 1\nassert find_path(matrix, len(matrix), len(matrix[0]), (3, 0), (0, 0), set()) == 9\nassert find_path(matrix, len(matrix), len(matrix[0]), (3, 0), (0, 3), set()) == 6\nassert find_path(matrix, len(matrix), len(matrix[0]), (2, 0), (3, 3), set()) == 4", "entry_fn_name": "find_path"}
{"id": "25", "text": "Implement regular expression matching with the following special characters:\n\n* . (period) which matches any single character\n* \\* (asterisk) which matches zero or more of the preceding element\nThat is, implement a function that takes in a string and a valid regular expression and returns whether or not the string matches the regular expression.\n\nFor example, given the regular expression \"ra.\" and the string \"ray\", your function should return true. The same regular expression on the string \"raymond\" should return false.\n\nGiven the regular expression `\".*at\"` and the string \"chat\", your function should return true. The same regular expression on the string \"chats\" should return false.", "solution": "def is_match(regex, string):\n    if not regex:\n        return not string\n    first_match = bool(string) and regex[0] in {string[0], '.'}\n    if len(regex) >= 2 and regex[1] == '*':\n        return is_match(regex[2:], string) or (first_match and is_match(regex, string[1:]))\n    else:\n        return first_match and is_match(regex[1:], string[1:])", "title": "IE/25", "entry_cls_name": "Solution", "testing_code": "assert is_match('ra.', 'ray')\nassert not is_match('ra.', 'raymond')\nassert is_match('.*at', 'chat')\nassert not is_match('.*at', 'chats')\nassert is_match('ra.', 'ray') == True\nassert is_match('.*at', 'chat') == True\nassert is_match('.*at', 'chats') == False\nassert is_match('a', 'aa') == False\nassert is_match('a*', 'a') == True\nassert is_match('.*', 'ab') == True\nassert is_match('c*a*b', 'aab') == True\nassert is_match('mis*is*p*', 'mississippi') == False\nassert is_match('ab*a*c*a', 'aaa') == True", "entry_fn_name": "is_match"}
{"id": "27", "text": "Given a string of round, curly, and square open and closing brackets, return whether the brackets are balanced (well-formed).\n\nFor example, given the string \"([])[]({})\", you should return true.\n\nGiven the string \"([)]\" or \"((()\", you should return false.", "solution": "brace_map = {')': '(', '}': '{', ']': '['}\ndef is_balanced(s):\n    stack = list()\n    for char in s:\n        if stack and char in brace_map and (stack[-1] == brace_map[char]):\n            stack.pop()\n        else:\n            stack.append(char)\n    return not stack", "title": "IE/27", "entry_cls_name": "Solution", "testing_code": "assert is_balanced('')\nassert is_balanced('{}')\nassert is_balanced('([])')\nassert is_balanced('([])[]({})')\nassert not is_balanced('(')\nassert not is_balanced(']')\nassert not is_balanced('((()')\nassert not is_balanced('([)]')", "entry_fn_name": "is_balanced"}
{"id": "28", "text": "Write an algorithm to justify text. Given a sequence of words and an integer line length k, return a list of strings which represents each line, fully justified.\n\nMore specifically, you should have as many words as possible in each line. There should be at least one space between each word. Pad extra spaces when necessary so that each line has exactly length k. Spaces should be distributed as equally as possible, with the extra spaces, if any, distributed starting from the left.\n\nIf you can only fit one word on a line, then you should pad the right-hand side with spaces.\n\nEach word is guaranteed not to be longer than k.\n\nFor example, given the list of words [\"the\", \"quick\", \"brown\", \"fox\", \"jumps\", \"over\", \"the\", \"lazy\", \"dog\"] and k = 16, you should return the following:\n\n[\"the  quick brown\", # 1 extra space on the left\n\"fox  jumps  over\", # 2 extra spaces distributed evenly\n\"the   lazy   dog\"] # 4 extra spaces distributed evenly", "solution": "def justify_text(words, max_line_length):\n    lines = list()\n    cumulative_length = -1\n    current_words = list()\n    line_lengths = list()\n    for word in words:\n        if cumulative_length + (len(word) + 1) > max_line_length:\n            lines.append(current_words)\n            line_lengths.append(cumulative_length)\n            cumulative_length = -1\n            current_words = list()\n        cumulative_length += len(word) + 1\n        current_words.append(word)\n    if current_words:\n        lines.append(current_words)\n        line_lengths.append(cumulative_length)\n    justified_lines = list()\n    for (words, length) in zip(lines, line_lengths):\n        spaces_to_add = max_line_length - length\n        guaranteed_spaces = 1 + spaces_to_add // (len(words) - 1)\n        bonus_space_recipients = spaces_to_add % (len(words) - 1)\n        line = ''\n        for (index, word) in enumerate(words[:-1]):\n            line += word\n            line += guaranteed_spaces * ' '\n            if index < bonus_space_recipients:\n                line += ' '\n        line += words[-1]\n        justified_lines.append(line)\n    return justified_lines", "title": "IE/28", "entry_cls_name": "Solution", "testing_code": "assert justify_text(['the', 'quick', 'brown', 'fox', 'jumps', 'over', 'the', 'lazy', 'dog'], 16) == ['the  quick brown', 'fox  jumps  over', 'the   lazy   dog']\nassert justify_text(['the', 'quick', 'brown', 'fox', 'jumps', 'over'], 16) == ['the  quick brown', 'fox  jumps  over']\nassert justify_text(['the', 'quick'], 16) == ['the        quick']", "entry_fn_name": "justify_text"}
{"id": "30", "text": "You are given an array of non-negative integers that represents a two-dimensional elevation map where each element is unit-width wall and the integer is the height. Suppose it will rain and all spots between two walls get filled up.\n\nCompute how many units of water remain trapped on the map in O(N) time and O(1) space.\n\nFor example, given the input [2, 1, 2], we can hold 1 unit of water in the middle.\n\nGiven the input [3, 0, 1, 3, 0, 5], we can hold 3 units in the first index, 2 in the second, and 3 in the fourth index (we cannot hold 5 since it would run off to the left), so we can trap 8 units of water.", "solution": "def calculate_trapped_water(walls):\n    if len(walls) < 3:\n        return 0\n    total_water_volume = 0\n    left = 0\n    right = len(walls) - 1\n    left_max = 0\n    right_max = 0\n    while left <= right:\n        if walls[left] < walls[right]:\n            if walls[left] > left_max:\n                left_max = walls[left]\n            else:\n                total_water_volume += left_max - walls[left]\n            left += 1\n        else:\n            if walls[right] > right_max:\n                right_max = walls[right]\n            else:\n                total_water_volume += right_max - walls[right]\n            right -= 1\n    return total_water_volume", "title": "IE/30", "entry_cls_name": "Solution", "testing_code": "assert calculate_trapped_water([1]) == 0\nassert calculate_trapped_water([2, 1]) == 0\nassert calculate_trapped_water([2, 1, 2]) == 1\nassert calculate_trapped_water([4, 1, 2]) == 1\nassert calculate_trapped_water([4, 1, 2, 3]) == 3\nassert calculate_trapped_water([3, 0, 1, 3, 0, 5]) == 8\nassert calculate_trapped_water([10, 9, 1, 1, 6]) == 10\nassert calculate_trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6", "entry_fn_name": "calculate_trapped_water"}
{"id": "31", "text": "The edit distance between two strings refers to the minimum number of character insertions, deletions, and substitutions required to change one string to the other. For example, the edit distance between \"kitten\" and \"sitting\" is three: substitute the \"k\" for \"s\", substitute the \"e\" for \"i\", and append a \"g\".\n\nGiven two strings, compute the edit distance between them.", "solution": "def get_edit_distance(s1, s2):\n    if s1 == s2:\n        return 0\n    elif not s1:\n        return len(s2)\n    elif not s2:\n        return len(s1)\n    if s1[0] == s2[0]:\n        return get_edit_distance(s1[1:], s2[1:])\n    return 1 + min(get_edit_distance(s1[1:], s2), get_edit_distance(s1, s2[1:]), get_edit_distance(s1[1:], s2[1:]))", "title": "IE/31", "entry_cls_name": "Solution", "testing_code": "assert get_edit_distance('', '') == 0\nassert get_edit_distance('a', 'b') == 1\nassert get_edit_distance('abc', '') == 3\nassert get_edit_distance('abc', 'abc') == 0\nassert get_edit_distance('kitten', 'sitting') == 3\nassert get_edit_distance('', 'abcd') == 4\nassert get_edit_distance('abcd', 'abcd') == 0\nassert get_edit_distance('horse', 'ros') == 3\nassert get_edit_distance('intention', 'execution') == 5", "entry_fn_name": "get_edit_distance"}
{"id": "32", "text": "Suppose you are given a table of currency exchange rates, represented as a 2D array. Determine whether there is a possible arbitrage: that is, whether there is some sequence of trades you can make, starting with some amount A of any currency, so that you can end up with some amount greater than A of that currency.\n\nThere are no transaction costs and you can trade fractional quantities.", "solution": "from math import log\ndef arbitrage(table):\n    transformed_graph = [[-log(edge) for edge in row] for row in table]\n    source = 0\n    n = len(transformed_graph)\n    min_dist = [float('inf')] * n\n    min_dist[source] = 0\n    for _ in range(n - 1):\n        for v in range(n):\n            for w in range(n):\n                if min_dist[w] > min_dist[v] + transformed_graph[v][w]:\n                    min_dist[w] = min_dist[v] + transformed_graph[v][w]\n    for v in range(n):\n        for w in range(n):\n            if min_dist[w] > min_dist[v] + transformed_graph[v][w]:\n                return True\n    return False", "title": "IE/32", "entry_cls_name": "Solution", "testing_code": "assert arbitrage([[1, 2], [2, 1]])\nassert not arbitrage([[1, 1], [1, 1]])\nassert arbitrage([[3, 4], [4, 3]]) == True\nassert arbitrage([[3, 3], [3, 3]]) == True", "entry_fn_name": "arbitrage"}
{"id": "33", "text": "Compute the running median of a sequence of numbers. That is, given a stream of numbers, print out the median of the list so far on each new element.\n\nRecall that the median of an even-numbered list is the average of the two middle numbers.\n\nFor example, given the sequence [2, 1, 5, 7, 2, 0, 5], your algorithm should print out:\n\n```\n2\n1.5\n2\n3.5\n2\n2\n2\n```", "solution": "import heapq as hq\ndef get_running_medians(arr):\n    if not arr:\n        return []\n    min_heap = list()\n    max_heap = list()\n    medians = list()\n    for x in arr:\n        hq.heappush(min_heap, x)\n        if len(min_heap) > len(max_heap) + 1:\n            smallest_large_element = hq.heappop(min_heap)\n            hq.heappush(max_heap, -smallest_large_element)\n        if len(min_heap) == len(max_heap):\n            median = (min_heap[0] - max_heap[0]) / 2\n        else:\n            median = min_heap[0]\n        medians.append(median)\n    return medians\n", "title": "IE/33", "entry_cls_name": "Solution", "testing_code": "assert get_running_medians([]) == []\nassert get_running_medians([2, 5]) == [2, 3.5]\nassert get_running_medians([3, 3, 3, 3]) == [3, 3, 3, 3]\nassert get_running_medians([2, 1, 5, 7, 2, 0, 5]) == [2, 1.5, 2, 3.5, 2, 2, 2]", "entry_fn_name": "get_running_medians"}
{"id": "34", "text": "Given a string, find the palindrome that can be made by inserting the fewest number of characters as possible anywhere in the word. If there is more than one palindrome of minimum length that can be made, return the lexicographically earliest one (the first one alphabetically).\n\nFor example, given the string \"race\", you should return \"ecarace\", since we can add three letters to it (which is the smallest amount to make a palindrome). There are seven other palindromes that can be made from \"race\" by adding three letters, but \"ecarace\" comes first alphabetically.\n\nAs another example, given the string \"google\", you should return \"elgoogle\".", "solution": "def is_palindrome(s):\n    return s[::-1] == s\ndef get_nearest_palindrome(s):\n    if is_palindrome(s):\n        return s\n    if s[0] == s[-1]:\n        return s[0] + get_nearest_palindrome(s[1:-1]) + s[-1]\n    else:\n        pal_1 = s[0] + get_nearest_palindrome(s[1:]) + s[0]\n        pal_2 = s[-1] + get_nearest_palindrome(s[:-1]) + s[-1]\n        if len(pal_1) > len(pal_2):\n            return pal_2\n        elif len(pal_1) < len(pal_2):\n            return pal_1\n        return pal_1 if pal_1 < pal_2 else pal_2", "title": "IE/34", "entry_cls_name": "Solution", "testing_code": "assert get_nearest_palindrome('racecar') == 'racecar'\nassert get_nearest_palindrome('google') == 'elgoogle'\nassert get_nearest_palindrome('egoogle') == 'elgoogle'\nassert get_nearest_palindrome('elgoog') == 'elgoogle'\nassert get_nearest_palindrome('race') == 'ecarace'\nassert get_nearest_palindrome('aacecaaa') == 'aaacecaaa'\nassert get_nearest_palindrome('aaaecaaa') == 'aaacecaaa'\nassert get_nearest_palindrome('abcd') == 'abcdcba'", "entry_fn_name": "get_nearest_palindrome"}
{"id": "35", "text": "Given an array of strictly the characters 'R', 'G', and 'B', segregate the values of the array so that all the Rs come first, the Gs come second, and the Bs come last. You can only swap elements of the array.\n\nDo this in linear time and in-place.\n\nFor example, given the array ['G', 'B', 'R', 'R', 'B', 'R', 'G'], it should become ['R', 'R', 'R', 'G', 'G', 'B', 'B'].", "solution": "def swap_indices(arr, i, j):\n    tmp = arr[i]\n    arr[i] = arr[j]\n    arr[j] = tmp\ndef pull_elements_to_front(arr, start_index, end_index, letter):\n    i = start_index\n    j = end_index\n    last_letter_index = -1\n    while i < j:\n        if arr[i] == letter:\n            last_letter_index = i\n            i += 1\n        elif arr[j] != letter:\n            j -= 1\n        else:\n            last_letter_index = i\n            swap_indices(arr, i, j)\n    return last_letter_index\ndef reorder_array(arr):\n    last_index = pull_elements_to_front(arr, 0, len(arr) - 1, 'R')\n    pull_elements_to_front(arr, last_index + 1, len(arr) - 1, 'G')\n    return arr", "title": "IE/35", "entry_cls_name": "Solution", "testing_code": "assert reorder_array(['G', 'R']) == ['R', 'G']\nassert reorder_array(['G', 'B', 'R']) == ['R', 'G', 'B']\nassert reorder_array(['B', 'G', 'R']) == ['R', 'G', 'B']\nassert reorder_array(['G', 'B', 'R', 'R', 'B', 'R', 'G']) == ['R', 'R', 'R', 'G', 'G', 'B', 'B']", "entry_fn_name": "reorder_array"}
{"id": "37", "text": "The power set of a set is the set of all its subsets. Write a function that, given a set, generates its power set.\n\nFor example, given the set {1, 2, 3}, it should return {{}, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}}.\n\nYou may also use a list or array to represent a set.", "solution": "def get_power_set(numbers):\n    if len(numbers) == 0:\n        return [set([])]\n    power_set = list()\n    current_number = numbers[0]\n    child_power_set = get_power_set(numbers[1:])\n    power_set.extend(child_power_set)\n    for child_set in child_power_set:\n        new_set = child_set.copy()\n        new_set.add(current_number)\n        power_set.append(new_set)\n    return power_set", "title": "IE/37", "entry_cls_name": "Solution", "testing_code": "assert get_power_set([]) == [set()]\nassert get_power_set([1]) == [set(), {1}]\nassert get_power_set([1, 2]) == [set(), {2}, {1}, {1, 2}]\nassert get_power_set([1, 2, 3]) == [set(), {3}, {2}, {2, 3}, {1}, {1, 3}, {1, 2}, {1, 2, 3}]\nassert get_power_set([1, 2, 3, 4]) == [set(), {4}, {3}, {3, 4}, {2}, {2, 4}, {2, 3}, {2, 3, 4}, {1}, {1, 4}, {1, 3}, {1, 3, 4}, {1, 2}, {1, 2, 4}, {1, 2, 3}, {1, 2, 3, 4}]", "entry_fn_name": "get_power_set"}
{"id": "40", "text": "Given an array of integers where every integer occurs three times except for one integer, which only occurs once, find and return the non-duplicated integer.\n\nFor example, given `[6, 1, 3, 3, 3, 6, 6]`, return `1`. Given `[13, 19, 13, 13]`, return `19`.\n\nDo this in $O(N)$ time and $O(1)$ space.", "solution": "WORD_SIZE = 32\ndef get_non_duplicated_number(arr):\n    non_duplicate = 0\n    for i in range(0, WORD_SIZE):\n        sum_i_position_bits = 0\n        x = 1 << i\n        for j in range(len(arr)):\n            if arr[j] & x:\n                sum_i_position_bits += 1\n        if sum_i_position_bits % 3:\n            non_duplicate |= x\n    return non_duplicate", "title": "IE/40", "entry_cls_name": "Solution", "testing_code": "assert get_non_duplicated_number([6, 1, 3, 3, 3, 6, 6]) == 1\nassert get_non_duplicated_number([13, 19, 13, 13]) == 19\n", "entry_fn_name": "get_non_duplicated_number"}
{"id": "41", "text": "Given an unordered list of flights taken by someone, each represented as (origin, destination) pairs, and a starting airport, compute the person's itinerary. If no such itinerary exists, return null. If there are multiple possible itineraries, return the lexicographically smallest one. All flights must be used in the itinerary.\n\nFor example, given the list of flights [('SFO', 'HKO'), ('YYZ', 'SFO'), ('YUL', 'YYZ'), ('HKO', 'ORD')] and starting airport 'YUL', you should return the list ['YUL', 'YYZ', 'SFO', 'HKO', 'ORD'].\n\nGiven the list of flights [('SFO', 'COM'), ('COM', 'YYZ')] and starting airport 'COM', you should return null.\n\nGiven the list of flights [('A', 'B'), ('A', 'C'), ('B', 'C'), ('C', 'A')] and starting airport 'A', you should return the list ['A', 'B', 'C', 'A', 'C'] even though ['A', 'C', 'A', 'B', 'C'] is also a valid itinerary. However, the first one is lexicographically smaller.", "solution": "def get_itinerary(flights, starting_point):\n    def _get_itinerary(flights, starting_point, current_itinerary):\n      if not flights:\n          return current_itinerary + [starting_point]\n      updated_itinerary = None\n      for (index, (city_1, city_2)) in enumerate(flights):\n          if starting_point == city_1:\n              child_itinerary = _get_itinerary(flights[:index] + flights[index + 1:], city_2, current_itinerary + [city_1])\n              if child_itinerary:\n                  if not updated_itinerary or ''.join(child_itinerary) < ''.join(updated_itinerary):\n                      updated_itinerary = child_itinerary\n      return updated_itinerary or []\n    return _get_itinerary(flights, starting_point, [])\n", "title": "IE/41", "entry_cls_name": "Solution", "testing_code": "assert get_itinerary([('SFO', 'HKO'), ('YYZ', 'SFO'), ('YUL', 'YYZ'), ('HKO', 'ORD')], 'YUL') == ['YUL', 'YYZ', 'SFO', 'HKO', 'ORD']\nassert get_itinerary([('SFO', 'COM'), ('COM', 'YYZ')], 'YUL') == []\nassert get_itinerary([('A', 'B'), ('A', 'C'), ('B', 'C'), ('C', 'A')], 'A') == ['A', 'B', 'C', 'A', 'C']\nassert get_itinerary([('A','B'),('B','A')],'A') == ['A', 'B', 'A']\nassert get_itinerary([('A','B'),('C','D')],'D') == []", "entry_fn_name": "get_itinerary"}
{"id": "42", "text": "Given a list of integers S and a target number k, write a function that returns a subset of S that adds up to k. If such a subset cannot be made, then return an empty list.\n\nIntegers can appear more than once in the list. You may assume all numbers in the list are positive.\n\nFor example, given `S = [12, 1, 61, 5, 9, 2]` and `k = 24`, return [12, 9, 2, 1] since it sums up to 24.", "solution": "def get_subset_for_sum(arr, k):\n    if len(arr) == 0:\n        return []\n    if arr[0] == k:\n        return [arr[0]]\n    with_first = get_subset_for_sum(arr[1:], k - arr[0])\n    if with_first:\n        return [arr[0]] + with_first\n    else:\n        return get_subset_for_sum(arr[1:], k)", "title": "IE/42", "entry_cls_name": "Solution", "testing_code": "assert get_subset_for_sum([], 1) == []\nassert get_subset_for_sum([12, 1, 61, 5, 9, 2], 24) == [12, 1, 9, 2]\nassert get_subset_for_sum([12, 1, 61, 5, 9, 2], 61) == [61]\nassert get_subset_for_sum([12, 1, 61, 5, -108, 2], -106) == [-108, 2]\nassert get_subset_for_sum([1,2],3) == [1,2]\nassert get_subset_for_sum([-1,-1,-1,-1,-1,-1,8],2) == [-1, -1, -1, -1, -1, -1, 8]", "entry_fn_name": "get_subset_for_sum"}
{"id": "44", "text": "We can determine how \"out of order\" an array A is by counting the number of inversions it has. Two elements A[i] and A[j] form an inversion if A[i] > A[j] but i < j. That is, a smaller element appears after a larger element.\n\nGiven an array, count the number of inversions it has. Do this faster than O(N^2) time.\n\nYou may assume each element in the array is distinct.\n\nFor example, a sorted list has zero inversions. The array [2, 4, 1, 3, 5] has three inversions: (2, 1), (4, 1), and (4, 3). The array [5, 4, 3, 2, 1] has ten inversions: every distinct pair forms an inversion.", "solution": "def merge(a_with_inv, b_with_inv):\n    (i, k) = (0, 0)\n    merged = list()\n    (a, a_inv) = a_with_inv\n    (b, b_inv) = b_with_inv\n    inversions = a_inv + b_inv\n    while i < len(a) and k < len(b):\n        if a[i] < b[k]:\n            merged.append(a[i])\n            i += 1\n        else:\n            merged.append(b[k])\n            inversions += len(a[i:])\n            k += 1\n    while i < len(a):\n        merged.append(a[i])\n        i += 1\n    while k < len(b):\n        merged.append(b[k])\n        k += 1\n    return (merged, inversions)\ndef merge_sort(arr):\n    if not arr or len(arr) == 1:\n        return (arr, 0)\n    mid = len(arr) // 2\n    (merged_array, inversions) = merge(merge_sort(arr[:mid]), merge_sort(arr[mid:]))\n    return (merged_array, inversions)\ndef count_inversions(arr):\n    (_, inversions) = merge_sort(arr)\n    return inversions", "title": "IE/44", "entry_cls_name": "Solution", "testing_code": "assert count_inversions([1, 2, 3, 4, 5]) == 0\nassert count_inversions([2, 1, 3, 4, 5]) == 1\nassert count_inversions([2, 4, 1, 3, 5]) == 3\nassert count_inversions([2, 6, 1, 3, 7]) == 3\nassert count_inversions([5, 4, 3, 2, 1]) == 10\n", "entry_fn_name": "count_inversions"}
{"id": "46", "text": "Given a string, find the longest palindromic contiguous substring. If there are more than one with the maximum length, return any one.\n\nFor example, the longest palindromic substring of \"aabcdcb\" is \"bcdcb\". The longest palindromic substring of \"bananas\" is \"anana\".", "solution": "def is_palindrome(s1):\n    return s1 == s1[::-1]\ndef get_longest_palindrome_substring(s):\n    if not s or is_palindrome(s):\n        return s\n    s1 = get_longest_palindrome_substring(s[1:])\n    s2 = get_longest_palindrome_substring(s[:-1])\n    return s1 if len(s1) >= len(s2) else s2", "title": "IE/46", "entry_cls_name": "Solution", "testing_code": "assert get_longest_palindrome_substring('aabcdcb') == 'bcdcb'\nassert get_longest_palindrome_substring('bananas') == 'anana'\nassert get_longest_palindrome_substring('banana') == 'anana'\nassert get_longest_palindrome_substring('bbbbccc') == 'bbbb'\nassert get_longest_palindrome_substring('cbbd') == 'bb'", "entry_fn_name": "get_longest_palindrome_substring"}
{"id": "47", "text": "Given a array of numbers representing the stock prices of a company in chronological order, write a function that calculates the maximum profit you could have made from buying and selling that stock once. You must buy before you can sell it.\n\nFor example, given [9, 11, 8, 5, 7, 10], you should return 5, since you could buy the stock at 5 dollars and sell it at 10 dollars.", "solution": "import sys\ndef get_stock_profit(prices):\n    if not prices or len(prices) == 1:\n      return 0\n    min_price = prices[0]\n    max_diff = -sys.maxsize\n    for price in prices[1:]:\n        if price - min_price > max_diff:\n            max_diff = price - min_price\n        if price < min_price:\n            min_price = price\n    return max_diff", "title": "IE/47", "entry_cls_name": "Solution", "testing_code": "assert get_stock_profit([9]) == 0\nassert get_stock_profit([9, 11, 8, 5, 7, 10]) == 5\nassert get_stock_profit([1, 2, 3, 4, 5]) == 4\nassert get_stock_profit([1, 1, 1, 1, 1]) == 0\nassert get_stock_profit([1, 1, 1, 2, 1]) == 1\nassert get_stock_profit([5, 4]) == -1", "entry_fn_name": "get_stock_profit"}
{"id": "49", "text": "Given an array of numbers, find the maximum sum of any contiguous subarray of the array.\n\nFor example, given the array [34, -50, 42, 14, -5, 86], the maximum sum would be 137, since we would take elements 42, 14, -5, and 86.\n\nGiven the array [-5, -1, -8, -9], the maximum sum would be 0, since we would not take any elements.\n\nDo this in O(N) time.", "solution": "def get_max_subarray(arr):\n    if not arr or max(arr) < 0:\n        return 0\n    current_max_sum = arr[0]\n    overall_max_sum = arr[0]\n    for num in arr[1:]:\n        current_max_sum = max(num, current_max_sum + num)\n        overall_max_sum = max(overall_max_sum, current_max_sum)\n    return overall_max_sum", "title": "IE/49", "entry_cls_name": "Solution", "testing_code": "assert get_max_subarray([34, -50, 42, 14, -5, 86]) == 137\nassert get_max_subarray([-5, -1, -8, -9]) == 0\nassert get_max_subarray([44, -5, 42, 14, -150, 86]) == 95\nassert get_max_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6", "entry_fn_name": "get_max_subarray"}
{"id": "50", "text": "Suppose an arithmetic expression is given as a binary tree. Each leaf is an integer and each internal node is one of '+', '\u2212', '\u2217', or '/'.\n\nGiven the root to such a tree, write a function to evaluate it.\n\nFor example, given the following tree:\n\n```\n    *\n   / \\\n  +    +\n / \\  / \\\n3  2  4  5\n```\n\nYou should return 45, as it is (3 + 2) * (4 + 5).", "solution": "class Node:\n\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\ndef solve_graph(root):\n    if root.val.isnumeric():\n        return float(root.val)\n    return eval('{} {} {}'.format(solve_graph(root.left), root.val, solve_graph(root.right)))", "title": "IE/50", "entry_cls_name": "Solution", "testing_code": "d = Node('3')\ne = Node('2')\nf = Node('4')\ng = Node('5')\nb = Node('+')\nb.left = d\nb.right = e\nc = Node('+')\nc.left = f\nc.right = g\na = Node('*')\na.left = b\na.right = c\nassert solve_graph(a) == 45\nassert solve_graph(c) == 9\nassert solve_graph(b) == 5\nassert solve_graph(d) == 3", "entry_fn_name": "solve_graph"}
{"id": "56", "text": "Given an undirected graph represented as an adjacency matrix and an integer k, write a function to determine whether each vertex in the graph can be colored such that no two adjacent vertices share the same color using at most k colors.", "solution": "def can_color_graph(adjacency_matrix, k):\n    max_adjacencies = 0\n    for row in adjacency_matrix:\n        max_adjacencies = max(max_adjacencies, sum(row))\n    return k > max_adjacencies", "title": "IE/56", "entry_cls_name": "Solution", "testing_code": "adjacency_matrix_1 = [[0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0]]\nassert can_color_graph(adjacency_matrix_1, 4)\nassert not can_color_graph(adjacency_matrix_1, 3)\nadjacency_matrix_2 = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\nassert can_color_graph(adjacency_matrix_2, 4)\nassert can_color_graph(adjacency_matrix_2, 1)\nadjacency_matrix_3 = [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]]\nassert can_color_graph(adjacency_matrix_3, 4)\nassert can_color_graph(adjacency_matrix_3, 3)\nassert not can_color_graph(adjacency_matrix_3, 2)", "entry_fn_name": "can_color_graph"}
{"id": "57", "text": "\nGiven a string s and an integer k, break up the string into multiple texts such that each text has a length of k or less. You must break it up so that words don't break across lines. If there's no way to break the text up, then return an empty list.\n\nYou can assume that there are no spaces at the ends of the string and that there is exactly one space between each word.\n\nFor example, given the string \"the quick brown fox jumps over the lazy dog\" and k = 10, you should return: [\"the quick\", \"brown fox\", \"jumps over\", \"the lazy\", \"dog\"]. No string in the list has a length of more than 10.\n", "solution": "def break_test(sentence, k):\n    words = sentence.split()\n    broken_text = list()\n    char_counter = -1\n    current_words = list()\n    index = 0\n    while index < len(words):\n        word = words[index]\n        if len(word) > k:\n            return []\n        if char_counter + len(word) + 1 <= k:\n            char_counter += len(word) + 1\n            current_words.append(word)\n            index += 1\n        else:\n            broken_text.append(' '.join(current_words))\n            char_counter = -1\n            current_words = list()\n    broken_text.extend(current_words)\n    return broken_text\n", "title": "IE/57", "entry_cls_name": "Solution", "testing_code": "assert break_test('encyclopedia', 8) == []\nassert break_test('the quick brown fox jumps over the lazy dog', 10) == ['the quick', 'brown fox', 'jumps over', 'the lazy', 'dog']\nassert break_test('a b c d e f gg h h ii',2) == ['a', 'b', 'c', 'd', 'e', 'f', 'gg', 'h', 'h', 'ii']\nassert break_test('ab',1) == []\nassert break_test('a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a',1) == ['a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a']", "entry_fn_name": "break_test"}
{"id": "58", "text": "An sorted array of integers was rotated an unknown number of times.\n\nGiven such an array, find the index of the element in the array in faster than linear time. If the element doesn't exist in the array, return -1.\n\nFor example, given the array [13, 18, 25, 2, 8, 10] and the element 8, return 4 (the index of 8 in the array).\n\nYou can assume all the integers in the array are unique.", "solution": "def find_element_helper(arr, element, start, end):\n    if start == end:\n        return -1\n    mid = start + (end - start) // 2\n    if arr[mid] == element:\n        return mid\n    elif arr[mid] > element:\n        if arr[start] >= element:\n            return find_element_helper(arr, element, start, mid)\n        else:\n            return find_element_helper(arr, element, mid, end)\n    elif arr[mid] < element:\n        if arr[start] <= element:\n            return find_element_helper(arr, element, start, mid)\n        else:\n            return find_element_helper(arr, element, mid, end)\ndef find_element(arr, element):\n    element_pos = find_element_helper(arr, element, 0, len(arr))\n    return element_pos", "title": "IE/58", "entry_cls_name": "Solution", "testing_code": "assert find_element([13, 18, 25, 2, 8, 10], 2) == 3\nassert find_element([13, 18, 25, 2, 8, 10], 8) == 4\nassert find_element([25, 2, 8, 10, 13, 18], 8) == 2\nassert find_element([8, 10, 13, 18, 25, 2], 8) == 0", "entry_fn_name": "find_element"}
{"id": "60", "text": "Given a multiset of integers, return whether it can be partitioned into two subsets whose sums are the same.\n\nFor example, given the multiset {15, 5, 20, 10, 35, 15, 10}, it would return true, since we can split it up into {15, 5, 10, 15, 10} and {20, 35}, which both add up to 55.\n\nGiven the multiset {15, 5, 20, 10, 35}, it would return false, since we can't split it up into two subsets that add up to the same sum.", "solution": "def partition_helper(mset, start, end, outer_sum, inner_sum):\n    if start >= end:\n        return False\n    if outer_sum == inner_sum:\n        return True\n    return partition_helper(mset, start + 1, end, outer_sum + mset[start], inner_sum - mset[start]) or partition_helper(mset, start, end - 1, outer_sum + mset[end], inner_sum - mset[end])\ndef can_partition(mset):\n    if not mset:\n        return True\n    if sum(mset) % 2 == 1:\n        return False\n    mset.sort()\n    return partition_helper(mset, 0, len(mset) - 1, 0, sum(mset))", "title": "IE/60", "entry_cls_name": "Solution", "testing_code": "assert can_partition([15, 5, 20, 10, 35, 15, 10])\nassert not can_partition([15, 5, 20, 10, 35])\nassert can_partition([1, 2, 3, 4, 9, 1])\nassert can_partition([1, 1, 1, 1, 1, 1, 6])\nassert can_partition([15, 5, 20, 10, 35, 15, 10]) == True\nassert can_partition([5, 5, 20, 10, 35]) == False\nassert can_partition([1, 5, 11, 5]) == True\nassert can_partition([1, 2, 3, 5]) == False", "entry_fn_name": "can_partition"}
{"id": "62", "text": "There is an N by M matrix of zeroes. Given N and M, write a function to count the number of ways of starting at the top-left corner and getting to the bottom-right corner. You can only move right or down. Return -1 if it is not possible.\n\nFor example, given a 2 by 2 matrix, you should return 2, since there are two ways to get to the bottom-right:\n* Right, then down\n* Down, then right\n\nGiven a 5 by 5 matrix, there are 70 ways to get to the bottom-right.\n", "solution": "def matrix_traversal_helper(row_count, col_count, curr_row, curr_col):\n    if curr_row == row_count - 1 and curr_col == col_count - 1:\n        return 1\n    count = 0\n    if curr_row < row_count - 1:\n        count += matrix_traversal_helper(row_count, col_count, curr_row + 1, curr_col)\n    if curr_col < col_count - 1:\n        count += matrix_traversal_helper(row_count, col_count, curr_row, curr_col + 1)\n    return count\ndef get_matrix_traversals(row_count, col_count):\n    if not row_count or not col_count:\n        return -1\n    count = matrix_traversal_helper(row_count, col_count, 0, 0)\n    return count\n", "title": "IE/62", "entry_cls_name": "Solution", "testing_code": "assert get_matrix_traversals(1, 1) == 1\nassert get_matrix_traversals(2, 2) == 2\nassert get_matrix_traversals(5, 5) == 70\nassert get_matrix_traversals(10,10) == 48620\nassert get_matrix_traversals(15,15) == 40116600\nassert get_matrix_traversals(0, 0) == -1\nassert get_matrix_traversals(1,0)==-1\nassert get_matrix_traversals(0,1)==-1", "entry_fn_name": "get_matrix_traversals"}
{"id": "63", "text": "Given a 2D matrix of characters and a target word, write a function that returns whether the word can be found in the matrix by going left-to-right, or up-to-down.\n\nFor example, given the following matrix:\n\n```\n[['F', 'A', 'C', 'I'],\n ['O', 'B', 'Q', 'P'],\n ['A', 'N', 'O', 'B'],\n ['M', 'A', 'S', 'S']]\n```\n\nand the target word 'FOAM', you should return true, since it's the leftmost column. Similarly, given the target word 'MASS', you should return true, since it's the last row.", "solution": "def get_row_word(matrix, word_len, rows, x, y):\n    row_chars = list()\n    for i in range(word_len):\n        row_chars.append(matrix[x + i][y])\n    return ''.join(row_chars)\ndef get_col_word(matrix, word_len, cols, x, y):\n    return ''.join(matrix[x][y:y + word_len])\ndef word_checker(matrix, word, word_len, rows, cols, x, y):\n    if x >= rows or y >= cols:\n        return False\n    (row_word, col_word) = (None, None)\n    if x + word_len <= rows and y < cols:\n        row_word = get_row_word(matrix, word_len, rows, x, y)\n    if y + word_len <= cols and x < rows:\n        col_word = get_col_word(matrix, word_len, cols, x, y)\n    if row_word == word or col_word == word:\n        return True\n    check_1 = word_checker(matrix, word, word_len, rows, cols, x + 1, y) if col_word else None\n    check_2 = word_checker(matrix, word, word_len, rows, cols, x, y + 1) if row_word else None\n    return check_1 or check_2\ndef word_exists(matrix, word):\n    rows = len(matrix)\n    cols = len(matrix[0])\n    word_len = len(word)\n    return word_checker(matrix, word, word_len, rows, cols, 0, 0)", "title": "IE/63", "entry_cls_name": "Solution", "testing_code": "matrix = [['F', 'A', 'C', 'I'], ['O', 'B', 'Q', 'P'], ['A', 'N', 'O', 'B'], ['M', 'A', 'S', 'S']]\nassert not word_exists(matrix, 'FOAMS')\nassert word_exists(matrix, 'FOAM')\nassert word_exists(matrix, 'MASS')\nassert not word_exists(matrix, 'FORM')", "entry_fn_name": "word_exists"}
{"id": "64", "text": "A knight's tour is a sequence of moves by a knight on a chessboard such that all squares are visited once.\n\nGiven N, write a function to return the number of knight's tours on an N by N chessboard.", "solution": "import random\nclass Position:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __hash__(self):\n        return hash((self.x, self.y))\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def __repr__(self):\n        return 'Position=[x={},y={}]'.format(self.x, self.y)\ndef get_potential_knight_moves(start, size, visited):\n    moves = list()\n    moves.append(Position(start.x + 1, start.y + 2))\n    moves.append(Position(start.x + 1, start.y - 2))\n    moves.append(Position(start.x - 1, start.y + 2))\n    moves.append(Position(start.x - 1, start.y - 2))\n    moves.append(Position(start.x + 2, start.y + 1))\n    moves.append(Position(start.x + 2, start.y - 1))\n    moves.append(Position(start.x - 2, start.y + 1))\n    moves.append(Position(start.x - 2, start.y - 1))\n    valid_moves = [pos for pos in moves if pos.x >= 0 and pos.x < size and (pos.y >= 0) and (pos.y < size) and (pos not in visited)]\n    return valid_moves\ndef run_knights_tour(start, size, visited):\n    if len(visited) == size * size:\n        return 1\n    moves = get_potential_knight_moves(start, size, visited)\n    count = 0\n    for move in moves:\n        tmp_visted = visited.copy()\n        tmp_visted.add(move)\n        count += run_knights_tour(move, size, tmp_visted)\n    return count\ndef count_knights_tours(size):\n    count = 0\n    for i in range(size):\n        for j in range(size):\n            start = Position(i, j)\n            count += run_knights_tour(start, size, set([start]))\n    return count", "title": "IE/64", "entry_cls_name": "Solution", "testing_code": "assert count_knights_tours(1) == 1\nassert count_knights_tours(2) == 0\nassert count_knights_tours(3) == 0\nassert count_knights_tours(4) == 0\nassert count_knights_tours(5) == 1728", "entry_fn_name": "count_knights_tours"}
{"id": "65", "text": "Given a N by M matrix of numbers, print out the matrix in a clockwise spiral.\n\nFor example, given the following matrix:\n\n```\n[[1,  2,  3,  4,  5],\n [6,  7,  8,  9,  10],\n [11, 12, 13, 14, 15],\n [16, 17, 18, 19, 20]]\n```\nYou should print out the following:\n\n```\n1, 2, 3, 4, 5, 10, 15, 20, 19, 18, 17, 16, 11, 6, 7, 8, 9, 14, 13, 12\n```", "solution": "def get_spiral(matrix, srow, scol, erow, ecol):\n    numbers = list()\n    for i in range(scol, ecol + 1):\n        numbers.append(matrix[srow][i])\n    for i in range(srow + 1, erow + 1):\n        numbers.append(matrix[i][ecol])\n    if srow < erow:\n        for i in range(ecol - 1, srow - 1, -1):\n            numbers.append(matrix[erow][i])\n    if scol < ecol:\n        for i in range(erow - 1, srow, -1):\n            numbers.append(matrix[i][scol])\n    return numbers\ndef spiral_helper(matrix):\n    (srow, scol, erow, ecol) = (0, 0, len(matrix) - 1, len(matrix[0]) - 1)\n    clockwise_numbers = list()\n    while srow < erow or scol < ecol:\n        clockwise_numbers.extend(get_spiral(matrix, srow, scol, erow, ecol))\n        if srow < erow:\n            srow += 1\n            erow -= 1\n        if scol < ecol:\n            scol += 1\n            ecol -= 1\n    return clockwise_numbers", "title": "IE/65", "entry_cls_name": "Solution", "testing_code": "matrix_0 = [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20]]\nassert spiral_helper(matrix_0) == [1, 2, 3, 4, 5, 10, 15, 20, 19, 18, 17, 16, 11, 6, 7, 8, 9, 14, 13, 12]\nmatrix_1 = [[1, 2, 3], [6, 7, 8], [11, 12, 13], [16, 17, 18]]\nassert spiral_helper(matrix_1) == [1, 2, 3, 8, 13, 18, 17, 16, 11, 6, 7, 12]\nmatrix_2 = [[1, 4], [2, 5], [3, 6]]\nassert spiral_helper(matrix_2) == [1, 4, 5, 6, 3, 2]\nmatrix_3 = [[1, 2, 3]]\nassert spiral_helper(matrix_3) == [1, 2, 3]\nmatrix_4 = [[1], [2], [3]]\nassert spiral_helper(matrix_4) == [1, 2, 3]", "entry_fn_name": "spiral_helper"}
{"id": "68", "text": "On our special chessboard, two bishops attack each other if they share the same diagonal. This includes bishops that have another bishop located between them, i.e. bishops can attack through pieces.\n\nYou are given N bishops, represented as (row, column) tuples on a M by M chessboard. Write a function to count the number of pairs of bishops that attack each other. The ordering of the pair doesn't matter: [1, 2] is considered the same as [2, 1].\n\nFor example, given M = 5 and the list of bishops:\n```\n(0, 0)\n(1, 2)\n(2, 2)\n(4, 0)\n```\n\nThe board would look like this:\n\n```\n[b 0 0 0 0]\n[0 0 b 0 0]\n[0 0 b 0 0]\n[0 0 0 0 0]\n[b 0 0 0 0]\n```\n\nYou should return 2, since bishops 1 and 3 attack each other, as well as bishops 3 and 4.", "solution": "def add_new_bishop(location, attack_positions, board_size):\n    count = 0\n    if location in attack_positions:\n        count += 1\n    \n    new_attack_positions = list()\n    [i, j] = location\n    while i > 0 and j > 0:\n        i -= 1\n        j -= 1\n        new_attack_positions.append([i, j])\n    [i, j] = location\n    while i > 0 and j < board_size - 1:\n        i -= 1\n        j += 1\n        new_attack_positions.append([i, j])\n    [i, j] = location\n    while i < board_size - 1 and j > 0:\n        i += 1\n        j -= 1\n        new_attack_positions.append([i, j])\n    [i, j] = location\n    while i < board_size - 1 and j < board_size - 1:\n        i += 1\n        j += 1\n        new_attack_positions.append([i, j])\n    attack_positions.extend(new_attack_positions)\n    return (count, attack_positions)\ndef get_attack_vectors(bishop_locations, board_size):\n    attack_positions = list()\n    total_count = 0\n    for location in bishop_locations:\n        (count, attack_positions) = add_new_bishop(location, attack_positions, board_size)\n        total_count += count\n    return total_count", "title": "IE/68", "entry_cls_name": "Solution", "testing_code": "assert get_attack_vectors([[0, 0], [1, 2], [2, 2], [4, 0]], 5) == 2\nassert get_attack_vectors([[0, 0], [1, 2], [2, 2]], 5) == 1\nassert get_attack_vectors([[0, 0], [1, 2], [2, 2]], 1) == 0", "entry_fn_name": "get_attack_vectors"}
{"id": "69", "text": "Given a list of integers, return the largest product that can be made by multiplying any three integers.\n\nFor example, if the list is [-10, -10, 5, 2], we should return 500, since that's -10 * -10 * 5.\n\nYou can assume the list has at least three integers.", "solution": "import sys\ndef get_pairwise_products(arr):\n    pairwise_products = list()\n    for i in range(len(arr)):\n        for j in range(len(arr)):\n            if i != j:\n                pairwise_products.append([set([i, j]), arr[i] * arr[j]])\n    return pairwise_products\ndef get_largest_product(arr):\n    pairwise_products = get_pairwise_products(arr)\n    max_triple = -1 * sys.maxsize\n    for i in range(len(arr)):\n        for (prev_indices, product) in pairwise_products:\n            if i not in prev_indices:\n                triple_prod = arr[i] * product\n                if triple_prod > max_triple:\n                    max_triple = triple_prod\n    return max_triple", "title": "IE/69", "entry_cls_name": "Solution", "testing_code": "assert get_largest_product([-10, -10, 5, 2]) == 500\nassert get_largest_product([-10, 10, 5, 2]) == 100\nassert get_largest_product([1, 2, 3]) == 6\nassert get_largest_product([1, 2, 3, 4]) == 24", "entry_fn_name": "get_largest_product"}
{"id": "70", "text": "A number is considered perfect if its digits sum up to exactly 10.\n\nGiven a positive integer n, return the n-th perfect number.\n\nFor example, given 1, you should return 19. Given 2, you should return 28.", "solution": "def get_perfect_number(n):\n    tmp_sum = 0\n    for char in str(n):\n        tmp_sum += int(char)\n    return n * 10 + (10 - tmp_sum)", "title": "IE/70", "entry_cls_name": "Solution", "testing_code": "assert get_perfect_number(1) == 19\nassert get_perfect_number(2) == 28\nassert get_perfect_number(3) == 37\nassert get_perfect_number(10) == 109\nassert get_perfect_number(11) == 118\nassert get_perfect_number(19) == 190\nassert get_perfect_number(15) == 154", "entry_fn_name": "get_perfect_number"}
{"id": "72", "text": "In a directed graph, each node is assigned an uppercase letter. We define a path's value as the number of most frequently-occurring letter along that path. For example, if a path in the graph goes through \"ABACA\", the value of the path is 3, since there are 3 occurrences of 'A' on the path.\n\nGiven a graph with n nodes and m directed edges, return the largest value path of the graph. If the largest value is infinite, then return an empty list.\n\nThe graph is represented with a string and an edge list. The i-th character represents the uppercase letter of the i-th node. Each list in the edge list [i, j] means there is a directed edge from the i-th node to the j-th node. Self-edges are possible, as well as multi-edges.\n\nFor example, the following input graph:\n\n```\nABACA\n[[0, 1],\n [0, 2],\n [2, 3],\n [3, 4]]\n```\nWould have maximum value 3 using the path of vertices `[0, 2, 3, 4], [A, A, C, A]`.\n\nThe following input graph:\n\n```\nA\n[(0, 0)]\n```\n\nShould return -1, since we have an infinite loop.", "solution": "class GraphPath:\n\n    def __init__(self, nodes=set(), letter_counts=dict()):\n        self.nodes = nodes\n        self.letter_counts = letter_counts\n\n    def __repr__(self):\n        return 'nodes={}, letters={}'.format(self.nodes, self.letter_counts)\ndef get_max_value_string_helper(graph_path, node, adjacency_map):\n    if node in graph_path.nodes:\n        return [graph_path]\n    new_nodes = graph_path.nodes.copy()\n    new_nodes.add(node)\n    new_letter_counts = graph_path.letter_counts.copy()\n    if node[0] not in new_letter_counts:\n        new_letter_counts[node[0]] = 0\n    new_letter_counts[node[0]] += 1\n    new_graph_path = GraphPath(new_nodes, new_letter_counts)\n    if node not in adjacency_map:\n        return [new_graph_path]\n    paths = list()\n    for child_node in adjacency_map[node]:\n        new_paths = get_max_value_string_helper(new_graph_path, child_node, adjacency_map)\n        paths.extend(new_paths)\n    return paths\ndef get_max_value_string(graph_string, edge_list):\n    letter_counts = dict()\n    nodes = list()\n    for char in graph_string:\n        if char not in letter_counts:\n            letter_counts[char] = 0\n        else:\n            letter_counts[char] += 1\n        nodes.append('{}{}'.format(char, letter_counts[char]))\n    adjacency_map = dict()\n    for (start, end) in edge_list:\n        if nodes[start] not in adjacency_map:\n            adjacency_map[nodes[start]] = set()\n        if nodes[start] != nodes[end]:\n            adjacency_map[nodes[start]].add(nodes[end])\n    paths = list()\n    graph_path = GraphPath()\n    for node in adjacency_map:\n        new_paths = get_max_value_string_helper(graph_path, node, adjacency_map)\n        paths.extend(new_paths)\n    max_value = 0\n    for path in paths:\n        max_path_value = max(path.letter_counts.values())\n        if max_path_value > max_value:\n            max_value = max_path_value\n    return max_value if max_value > 0 else -1", "title": "IE/72", "entry_cls_name": "Solution", "testing_code": "assert get_max_value_string('ABACA', [[0, 1], [0, 2], [2, 3], [3, 4]]) == 3\nassert get_max_value_string('A', [[0, 0]]) == -1\nassert get_max_value_string('ABCDE', [[0, 1],[2,3],[3,1]]) == 1", "entry_fn_name": "get_max_value_string"}
{"id": "74", "text": "Suppose you have a multiplication table that is N by N. That is, a 2D array where the value at the i-th row and j-th column is (i + 1) * (j + 1) (if 0-indexed) or i * j (if 1-indexed).\n\nGiven integers N and X, write a function that returns the number of times X appears as a value in an N by N multiplication table.\n\nFor example, given N = 6 and X = 12, you should return 4, since the multiplication table looks like this:\n\n|     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- |\n| 1   | 2   | 3   | 4   | 5   | 6   |\n| 2   | 4   | 6   | 8   | 10  | 12  |\n| 3   | 6   | 9   | 12  | 15  | 18  |\n| 4   | 8   | 12  | 16  | 20  | 24  |\n| 5   | 10  | 15  | 20  | 25  | 30  |\n| 6   | 12  | 18  | 24  | 30  | 36  |\n\nAnd there are 4 12's in the table.", "solution": "def get_mult_count(n, x):\n    if n == 1:\n        return n\n    running_counter = 0\n    for i in range(1, n+1):\n        if x % i == 0 and x / i <= n:\n           running_counter+=1 \n    return running_counter", "title": "IE/74", "entry_cls_name": "Solution", "testing_code": "assert get_mult_count(1, 1) == 1\nassert get_mult_count(6, 12) == 4\nassert get_mult_count(2, 4) == 1\nassert get_mult_count(3, 6) == 2", "entry_fn_name": "get_mult_count"}
{"id": "75", "text": "Given an array of numbers, find the length of the longest increasing subsequence in the array. The subsequence does not necessarily have to be contiguous.\n\nFor example, given the array `[0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]`, the longest increasing subsequence has length 6: it is `0, 2, 6, 9, 11, 15`.", "solution": "def get_longest_inc_subseq(arr):\n    if len(arr) == 0:\n        return 0\n    DP = [1]*len(arr)\n    LONGEST = [1]*len(arr)\n    for i in range(0, len(arr)):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                DP[i] = max(DP[i],DP[j]+1)\n        LONGEST[i] = max(DP[i],LONGEST[i-1])\n    return LONGEST[-1]", "title": "IE/75", "entry_cls_name": "Solution", "testing_code": "assert get_longest_inc_subseq([]) == 0\nassert get_longest_inc_subseq([0, 1]) == 2\nassert get_longest_inc_subseq([0, 2, 1]) == 2\nassert get_longest_inc_subseq([0, 1, 2]) == 3\nassert get_longest_inc_subseq([2, 1, 0]) == 1\nassert get_longest_inc_subseq([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]) == 6", "entry_fn_name": "get_longest_inc_subseq"}
{"id": "76", "text": "You are given an N by M 2D matrix of lowercase letters. Determine the minimum number of columns that can be removed to ensure that each row is ordered from top to bottom lexicographically. That is, the letter at each column is lexicographically later as you go down each row. It does not matter whether each row itself is ordered lexicographically.\n\nFor example, given the following table:\n\n```\ncba\ndaf\nghi\n```\n\nThis is not ordered because of the a in the center. We can remove the second column to make it ordered:\n\n```\nca\ndf\ngi\n```\n\nSo your function should return 1, since we only needed to remove 1 column.\n\nAs another example, given the following table:\n\n```\nabcdef\n```\n\nYour function should return 0, since the rows are already ordered (there's only one row).\n\nAs another example, given the following table:\n\n```\nzyx\nwvu\ntsr\n```\n\nYour function should return 3, since we would need to remove all the columns to order it.", "solution": "def get_col_rem_count(matrix):\n    if not matrix:\n        return 0\n    rows = len(matrix)\n    if rows == 1:\n        return 0\n    cols = len(matrix[0])\n    col_drop_count = 0\n    for i in range(cols):\n        for k in range(1, rows):\n            if matrix[k][i] < matrix[k - 1][i]:\n                col_drop_count += 1\n                break\n    return col_drop_count", "title": "IE/76", "entry_cls_name": "Solution", "testing_code": "assert get_col_rem_count(['cba', 'daf', 'ghi']) == 1\nassert get_col_rem_count(['abcdef']) == 0\nassert get_col_rem_count(['zyx', 'wvu', 'tsr']) == 3\nassert get_col_rem_count([['c', 'b', 'a'], ['d', 'a', 'f'], ['g', 'h', 'i']]) == 1\nassert get_col_rem_count([['c', 'a'], ['d', 'f'], ['g', 'i']]) == 0\nassert get_col_rem_count([['a', 'b', 'c', 'd', 'e', 'f']]) == 0", "entry_fn_name": "get_col_rem_count"}
{"id": "77", "text": "Given a list of possibly overlapping intervals, return a new list of intervals where all overlapping intervals have been merged.\n\nThe input list is not necessarily ordered in any way.\n\nFor example, given `[(1, 3), (5, 8), (4, 10), (20, 25)]`, you should return `[(1, 3), (4, 10), (20, 25)]`.", "solution": "def merge_overlaps(intervals):\n    (interval_starts, interval_ends) = (set(), set())\n    for (start, end) in intervals:\n        interval_starts.add(start)\n        interval_ends.add(end)\n    min_start = min(interval_starts)\n    max_end = max(interval_ends)\n    current_active = 0\n    instant_statuses = list([current_active])\n    merged = list()\n    for i in range(min_start, max_end + 1):\n        if i in interval_ends:\n            current_active -= 1\n        if i in interval_starts:\n            current_active += 1\n        instant_statuses.append(current_active)\n    (start, end) = (None, None)\n    for i in range(len(instant_statuses)):\n        if instant_statuses[i] and (not instant_statuses[i - 1]):\n            start = i\n        if not instant_statuses[i] and instant_statuses[i - 1]:\n            end = i\n            merged.append([start, end])\n            (start, end) = (None, None)\n    return merged", "title": "IE/77", "entry_cls_name": "Solution", "testing_code": "assert merge_overlaps([[1, 3], [5, 8], [4, 10], [20, 25]]) == [[1, 3], [4, 10], [20, 25]]\nassert merge_overlaps([[1, 3], [5, 8], [4, 10], [20, 25], [6, 12]]) == [[1, 3], [4, 12], [20, 25]]", "entry_fn_name": "merge_overlaps"}
{"id": "79", "text": "Given an array of integers, write a function to determine whether the array could become non-decreasing by modifying at most 1 element.\n\nFor example, given the array `[10, 5, 7]`, you should return true, since we can modify the 10 into a 1 to make the array non-decreasing.\n\nGiven the array `[10, 5, 1]`, you should return false, since we can't modify any one element to get a non-decreasing array.", "solution": "def can_edit(arr):\n    decr_pairs = 0\n    if not arr:\n        return False\n    prev = None\n    for i in range(0, len(arr)-1):\n        if arr[i] > arr[i + 1]:\n            if decr_pairs:\n                return False\n            if prev is not None:\n                if i+2 < len(arr) and arr[i] > arr[i+2] and prev > arr[i+1]:\n                    return False\n            decr_pairs += 1\n        prev = arr[i]\n    return True", "title": "IE/79", "entry_cls_name": "Solution", "testing_code": "assert can_edit([10, 5, 7])\nassert not can_edit([10, 5, 1])\nassert can_edit([1, 10, 5, 7])", "entry_fn_name": "can_edit"}
{"id": "80", "text": "Given the root of a binary tree, return a deepest node. For example, in the following tree, return d.\n\n```\n    a\n   / \\\n  b   c\n /\nd\n```", "solution": "class Node:\n\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n    def __repr__(self):\n        return str(self.val)\ndef find_deepest_node(root, depth):\n    if not root.left and (not root.right):\n        return (root, depth)\n    left_depth = depth\n    right_depth = depth\n    if root.left:\n        (left_deepest, left_depth) = find_deepest_node(root.left, depth + 1)\n    if root.right:\n        (right_deepest, right_depth) = find_deepest_node(root.right, depth + 1)\n    return (left_deepest, left_depth) if left_depth > right_depth else (right_deepest, right_depth)\ndef find_deepest_node_helper(root):\n    return find_deepest_node(root, 0)[0]", "title": "IE/80", "entry_cls_name": "Solution", "testing_code": "a = Node('a')\nb = Node('b')\nc = Node('c')\nd = Node('d')\ne = Node('e')\nf = Node('f')\na.left = b\na.right = c\nb.left = d\nassert find_deepest_node_helper(a) == d\nc.left = e\ne.left = f\nassert find_deepest_node_helper(a) == f", "entry_fn_name": "find_deepest_node_helper"}
{"id": "81", "text": "Given a mapping of digits to letters (as in a phone number), and a digit string, return all possible letters the number could represent. You can assume each valid number in the mapping is a single digit.\n\nFor example if `{'2': ['a', 'b', 'c'], '3': ['d', 'e', 'f'], }` then `\"23\"` should return `['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']`.", "solution": "digit_mapping = {'2': ['a', 'b', 'c'], '3': ['d', 'e', 'f']}\ndef get_letter_strings(number_string):\n    if not number_string:\n        return\n    if len(number_string) == 1:\n        return digit_mapping[number_string[0]]\n    possible_strings = list()\n    current_letters = digit_mapping[number_string[0]]\n    strings_of_rem_nums = get_letter_strings(number_string[1:])\n    for letter in current_letters:\n        for string in strings_of_rem_nums:\n            possible_strings.append(letter + string)\n    return possible_strings", "title": "IE/81", "entry_cls_name": "Solution", "testing_code": "assert get_letter_strings('2') == ['a', 'b', 'c']\nassert get_letter_strings('23') == ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']\nassert get_letter_strings('32') == ['da', 'db', 'dc', 'ea', 'eb', 'ec', 'fa', 'fb', 'fc']", "entry_fn_name": "get_letter_strings"}
{"id": "84", "text": "Given a matrix of 1s and 0s, return the number of \"islands\" in the matrix. A 1 represents land and 0 represents water, so an island is a group of 1s that are neighboring and their perimeter is surrounded by water.\n\nFor example, this matrix has 4 islands.\n\n```\n1 0 0 0 0\n0 0 1 1 0\n0 1 1 0 0\n0 0 0 0 0\n1 1 0 0 1\n1 1 0 0 1\n```", "solution": "def add_island(x, y, world_map, visited):\n    coord = '{}-{}'.format(x, y)\n    if coord in visited:\n        return 0\n    visited.add(coord)\n    if x > 0 and world_map[x - 1][y]:\n        add_island(x - 1, y, world_map, visited)\n    if x < len(world_map) - 1 and world_map[x + 1][y]:\n        add_island(x + 1, y, world_map, visited)\n    if y > 0 and world_map[x][y - 1]:\n        add_island(x, y - 1, world_map, visited)\n    if y < len(world_map[0]) - 1 and world_map[x][y + 1]:\n        add_island(x, y + 1, world_map, visited)\n    return 1\ndef count_islands(world_map):\n    count = 0\n    visited = set()\n    for i in range(len(world_map)):\n        for k in range(len(world_map[0])):\n            if world_map[i][k]:\n                count += add_island(i, k, world_map, visited)\n    return count", "title": "IE/84", "entry_cls_name": "Solution", "testing_code": "world_map = [[1, 0, 0, 0, 0], [0, 0, 1, 1, 0], [0, 1, 1, 0, 0], [0, 0, 0, 0, 0], [1, 1, 0, 0, 1], [1, 1, 0, 0, 1]]\nassert count_islands(world_map) == 4", "entry_fn_name": "count_islands"}
{"id": "85", "text": "Given three 32-bit integers x, y, and b, return x if b is 1 and y if b is 0, using only mathematical or bit operations. You can assume b can only be 1 or 0.", "solution": "def get_num(x, y, b):\n    return x * b + y * abs(b - 1)", "title": "IE/85", "entry_cls_name": "Solution", "testing_code": "assert get_num(3, 4, 1) == 3\nassert get_num(3, 4, 0) == 4\nassert get_num(4, 4, 1) == 4\nassert get_num(4, 4, 1) == 4\nassert get_num(0, 1, 0) == 1\nassert get_num(0, 1, 1) == 0", "entry_fn_name": "get_num"}
{"id": "86", "text": "Given a string of parentheses, write a function to compute the minimum number of parentheses to be removed to make the string valid (i.e. each open parenthesis is eventually closed).\n\nFor example, given the string \"()())()\", you should return 1. Given the string \")(\", you should return 2, since we must remove all of them.", "solution": "def get_chars_removed_helper(string, stack, removed):\n    if not string and (not stack):\n        return removed\n    elif not string:\n        return len(stack) + removed\n    if string[0] == ')' and stack and (stack[-1] == '('):\n        stack.pop()\n        return get_chars_removed_helper(string[1:], stack, removed)\n    removed_chars_add = get_chars_removed_helper(string[1:], stack + [string[0]], removed)\n    removed_chars_ignore = get_chars_removed_helper(string[1:], stack, removed + 1)\n    return min(removed_chars_add, removed_chars_ignore)\ndef get_chars_removed(string):\n    chars_removed = get_chars_removed_helper(string, list(), 0)\n    return chars_removed", "title": "IE/86", "entry_cls_name": "Solution", "testing_code": "assert get_chars_removed('()())()') == 1\nassert get_chars_removed(')(') == 2\nassert get_chars_removed('()(((') == 3\nassert get_chars_removed(')()(((') == 4\nassert get_chars_removed(')()') == 1\nassert get_chars_removed(')((') == 3\nassert get_chars_removed('())') == 1\nassert get_chars_removed('()(') == 1\nassert get_chars_removed('(((') == 3", "entry_fn_name": "get_chars_removed"}
{"id": "88", "text": "Implement division of two positive integers without using the division, multiplication, or modulus operators. Return the quotient as an integer, ignoring the remainder.", "solution": "def divide(dividend, divisor):\n    if not divisor:\n        return\n    current_sum = 0\n    quotient = 0\n    while current_sum <= dividend:\n        quotient += 1\n        current_sum += divisor\n    return quotient - 1", "title": "IE/88", "entry_cls_name": "Solution", "testing_code": "assert not divide(1, 0)\nassert divide(1, 1) == 1\nassert divide(0, 1) == 0\nassert divide(12, 3) == 4\nassert divide(13, 3) == 4\nassert divide(25, 5) == 5\nassert divide(25, 7) == 3", "entry_fn_name": "divide"}
{"id": "89", "text": "Determine whether a tree is a valid binary search tree.\n\nA binary search tree is a tree with two children, left and right, and satisfies the constraint that the key in the left child must be less than or equal to the root and the key in the right child must be greater than or equal to the root.", "solution": "class Node:\n\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\ndef is_valid_bst_node_helper(node, lb, ub):\n    if node and node.val <= ub and (node.val >= lb):\n        return is_valid_bst_node_helper(node.left, lb, node.val) and is_valid_bst_node_helper(node.right, node.val, ub)\n    return not node\ndef is_valid_bst(root):\n    return is_valid_bst_node_helper(root, -sys.maxsize, sys.maxsize)", "title": "IE/89", "entry_cls_name": "Solution", "testing_code": "import sys\nassert is_valid_bst(None)\na = Node(3)\nb = Node(2)\nc = Node(6)\nd = Node(1)\ne = Node(3)\nf = Node(4)\na.left = b\na.right = c\nb.left = d\nb.right = e\nc.left = f\nassert is_valid_bst(a)\na = Node(1)\nb = Node(2)\nc = Node(6)\nd = Node(1)\ne = Node(3)\nf = Node(4)\na.left = b\na.right = c\nb.left = d\nb.right = e\nc.left = f\nassert not is_valid_bst(a)\na = Node(3)\nb = Node(2)\nc = Node(6)\nd = Node(1)\ne = Node(4)\nf = Node(4)\na.left = b\na.right = c\nb.left = d\nb.right = e\nc.left = f\nassert not is_valid_bst(a)", "entry_fn_name": "is_valid_bst"}
{"id": "92", "text": "We're given a hashmap with a key courseId and value a list of courseIds, which represents that the prerequsite of courseId is courseIds. Return a sorted ordering of courses such that we can finish all courses.\n\nReturn null if there is no such ordering.\n\nFor example, given `{'CSC300': ['CSC100', 'CSC200'], 'CSC200': ['CSC100'], 'CSC100': []}`, should return `['CSC100', 'CSC200', 'CSCS300']`.", "solution": "def get_course_order_helper(prereqs, indep, order):\n    if not indep:\n        return (None, None, None)\n    elif not prereqs:\n        return (prereqs, indep, order)\n    new_indep = set()\n    for dc in prereqs:\n        required = prereqs[dc] - indep\n        if not len(required):\n            new_indep.add(dc)\n            order.append(dc)\n    for course in new_indep:\n        del prereqs[course]\n    return get_course_order_helper(prereqs, indep.union(new_indep), order)\ndef get_course_order(prereqs):\n    indep = set()\n    order = list()\n    for course in prereqs:\n        if not prereqs[course]:\n            indep.add(course)\n            order.append(course)\n        else:\n            prereqs[course] = set(prereqs[course])\n    for course in indep:\n        del prereqs[course]\n    (_, _, order) = get_course_order_helper(prereqs, indep, order)\n    return order", "title": "IE/92", "entry_cls_name": "Solution", "testing_code": "prereqs = {'CSC100': [], 'CSC200': [], 'CSC300': []}\nassert get_course_order(prereqs) == ['CSC100', 'CSC200', 'CSC300']\nprereqs = {'CSC300': ['CSC100', 'CSC200'], 'CSC200': ['CSC100'], 'CSC100': []}\nassert get_course_order(prereqs) == ['CSC100', 'CSC200', 'CSC300']\nprereqs = {'CSC400': ['CSC200'], 'CSC300': ['CSC100', 'CSC200'], 'CSC200': ['CSC100'], 'CSC100': []}\nassert get_course_order(prereqs) == ['CSC100', 'CSC200', 'CSC400', 'CSC300']\nprereqs = {'CSC400': ['CSC300'], 'CSC300': ['CSC100', 'CSC200'], 'CSC200': ['CSC100'], 'CSC100': ['CSC400']}\nassert not get_course_order(prereqs)", "entry_fn_name": "get_course_order"}
{"id": "93", "text": "Given a tree, find the largest tree/subtree that is a BST.\n\nGiven a tree, return the size of the largest tree/subtree that is a BST.", "solution": "class Node:\n\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n    def __repr__(self):\n        string = 'val={}:(left={}, right={})'.format(self.val, self.left, self.right)\n        return string\ndef get_largest_bst_helper(node):\n    if not node:\n        return (True, node, 0, sys.maxsize, -sys.maxsize)\n    if not node.left and (not node.right):\n        return (True, node, 1, node.val, node.val)\n    (left_is_bst, left_bst, left_nodes, left_minval, left_maxval) = get_largest_bst_helper(node.left)\n    (right_is_bst, right_bst, right_nodes, right_minval, right_maxval) = get_largest_bst_helper(node.right)\n    if left_is_bst and right_is_bst:\n        if node.left and node.right:\n            if node.val >= left_maxval and node.val <= right_minval:\n                return (True, node, left_nodes + right_nodes + 1, left_minval, right_maxval)\n        elif node.left and node.val >= left_maxval:\n            return (True, node, left_nodes + 1, left_minval, node.val)\n        elif node.right and node.val >= right_minval:\n            return (True, node, left_nodes + 1, node.val, right_maxval)\n    if left_nodes > right_nodes:\n        return (False, left_bst, left_nodes, left_minval, node.val)\n    else:\n        return (False, right_bst, right_nodes, node.val, right_maxval)\ndef get_largest_bst(root):\n    (_, largest_bst, nodes, _, _) = get_largest_bst_helper(root)\n    return (largest_bst, nodes)", "title": "IE/93", "entry_cls_name": "Solution", "testing_code": "import sys\na = Node(3)\nb = Node(2)\nc = Node(6)\nd = Node(1)\ne = Node(3)\nf = Node(4)\na.left = b\na.right = c\nb.left = d\nb.right = e\nc.left = f\nassert get_largest_bst(a) == (a, 6)\na = Node(1)\nb = Node(2)\nc = Node(6)\nd = Node(1)\ne = Node(3)\nf = Node(4)\na.left = b\na.right = c\nb.left = d\nb.right = e\nc.left = f\nassert get_largest_bst(a) == (b, 3)\na = Node(3)\nb = Node(2)\nc = Node(6)\nd = Node(1)\ne = Node(4)\nf = Node(4)\na.left = b\na.right = c\nb.left = d\nb.right = e\nc.left = f\nassert get_largest_bst(a) == (b, 3)\na = Node(3)\nb = Node(2)\nc = Node(6)\nd = Node(1)\ne = Node(1)\nf = Node(4)\na.left = b\na.right = c\nb.left = d\nb.right = e\nc.left = f\nassert get_largest_bst(a) == (c, 2)", "entry_fn_name": "get_largest_bst"}
{"id": "94", "text": "Given a binary tree of integers, find the maximum path sum between two nodes. The path must go through at least one node, and does not need to go through the root.", "solution": "class Node:\n\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\ndef get_max_path_sum(root, current_max_sum, overall_max_sum):\n    if not root:\n        return overall_max_sum\n    current_max_sum = max(root.val, current_max_sum + root.val)\n    overall_max_sum = max(overall_max_sum, current_max_sum)\n    left_path_sum = get_max_path_sum(root.left, current_max_sum, overall_max_sum)\n    right_path_sum = get_max_path_sum(root.right, current_max_sum, overall_max_sum)\n    return max(overall_max_sum, left_path_sum, right_path_sum)", "title": "IE/94", "entry_cls_name": "Solution", "testing_code": "assert get_max_path_sum(None, 0, 0) == 0\na = Node(1)\nassert get_max_path_sum(a, 0, 0) == 1\nb = Node(2)\na.left = b\nassert get_max_path_sum(a, 0, 0) == 3\nc = Node(3)\na.right = c\nassert get_max_path_sum(a, 0, 0) == 4\na.val = -1\nassert get_max_path_sum(a, 0, 0) == 3\nd = Node(4)\nb.left = d\nassert get_max_path_sum(a, 0, 0) == 6", "entry_fn_name": "get_max_path_sum"}
{"id": "95", "text": "Given a number represented by a list of digits, find the next greater permutation of a number, in terms of lexicographic ordering. If there is not greater permutation possible, return the permutation with the lowest value/ordering.\n\nFor example, the list `[1,2,3]` should return `[1,3,2]`. The list `[1,3,2]` should return `[2,1,3]`. The list `[3,2,1]` should return `[1,2,3]`.\n\nCan you perform the operation without allocating extra memory (disregarding the input memory)?", "solution": "def get_greater_permutation(arr):\n    if len(arr) < 2:\n        return\n    for index in range(len(arr) - 1, -1, -1):\n        if index > 0 and arr[index - 1] < arr[index]:\n            break\n    if index == 0:\n        arr.reverse()\n    else:\n        for k in range(len(arr) - 1, index - 1, -1):\n            if arr[k] > arr[index - 1]:\n                tmp = arr[k]\n                arr[k] = arr[index - 1]\n                arr[index - 1] = tmp\n                break\n        sub_array = arr[index:]\n        sub_array.reverse()\n        arr[index:] = sub_array\n    return arr", "title": "IE/95", "entry_cls_name": "Solution", "testing_code": "assert get_greater_permutation([1, 2, 3]) == [1, 3, 2]\nassert get_greater_permutation([1, 3, 2]) == [2, 1, 3]\nassert get_greater_permutation([3, 2, 1]) == [1, 2, 3]\nassert get_greater_permutation([1, 1, 5]) == [1, 5, 1]\nassert get_greater_permutation([2, 3, 6, 5, 4, 1]) == [2, 4, 1, 3, 5, 6]", "entry_fn_name": "get_greater_permutation"}
{"id": "96", "text": "Given a number in the form of a list of digits, return all possible permutations.\n\nFor example, given `[1,2,3]`, return `[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]`.", "solution": "def get_permutations(arr):\n    if not arr:\n        return []\n    if len(arr) < 2:\n        return [arr]\n    permutations = list()\n    for (i, num) in enumerate(arr):\n        arr_cp = arr[:i] + arr[i + 1:]\n        child_perms = get_permutations(arr_cp)\n        for perm in child_perms:\n            permutations.append([num] + perm)\n    return permutations", "title": "IE/96", "entry_cls_name": "Solution", "testing_code": "assert get_permutations([]) == [[]]\nassert get_permutations([1]) == [[1]]\nassert get_permutations([1, 2]) == [[1, 2], [2, 1]]\nassert get_permutations([1, 2, 3]) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]", "entry_fn_name": "get_permutations"}
{"id": "98", "text": "Given a 2D board of characters and a word, find if the word exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\n\nFor example, given the following board:\n```\n[\n  ['A','B','C','E'],\n  ['S','F','C','S'],\n  ['A','D','E','E']\n]\n```\n`exists(board, \"ABCCED\")` returns true, `exists(board, \"SEE\")` returns true, `exists(board, \"ABCB\")` returns false.", "solution": "def check_new_coordinate(word, row, col, used_coordinates):\n    expected_char = word[0]\n    copy_coordinates = used_coordinates.copy()\n    char = board[row][col]\n    result = False\n    if expected_char == char and '{}-{}'.format(row, col) not in copy_coordinates:\n        copy_coordinates.add('{}-{}'.format(row, col))\n        result = existence_helper(word[1:], board, row, col, copy_coordinates)\n    return result\ndef existence_helper(word, board, crow, ccol, used_coordinates):\n    if not word:\n        return True\n    (top, bottom, left, right) = (False, False, False, False)\n    if crow > 0:\n        top = check_new_coordinate(word, crow - 1, ccol, used_coordinates)\n    if crow < len(board) - 1:\n        bottom = check_new_coordinate(word, crow + 1, ccol, used_coordinates)\n    if ccol > 0:\n        left = check_new_coordinate(word, crow, ccol - 1, used_coordinates)\n    if ccol < len(board[0]) - 1:\n        right = check_new_coordinate(word, crow, ccol + 1, used_coordinates)\n    return top or bottom or left or right\ndef exists(board, word):\n    if not word:\n        return False\n    first_char = word[0]\n    result = False\n    for row in range(len(board)):\n        for col in range(len(board[0])):\n            if board[row][col] == first_char:\n                result = result or existence_helper(word[1:], board, row, col, set(['{}-{}'.format(row, col)]))\n    return result", "title": "IE/98", "entry_cls_name": "Solution", "testing_code": "board = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']]\nassert exists(board, 'ABCCED')\nassert exists(board, 'SEE')\nassert not exists(board, 'ABCB')", "entry_fn_name": "exists"}
{"id": "99", "text": "Given an unsorted array of integers, find the length of the longest consecutive elements sequence.\n\nFor example, given [100, 4, 200, 1, 3, 2], the longest consecutive element sequence is [1, 2, 3, 4]. Return its length: 4.\n\nYour algorithm should run in O(n) complexity.", "solution": "class NumRange:\n\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\n    def __hash__(self):\n        return hash(self.start, self.end)\n\n    def __eq__(self, other):\n        return self.start == other.start and self.end == other.end\n\n    def __repr__(self):\n        return '[{}, {}]'.format(self.start, self.end)\ndef add_number(num, starts, ends):\n    if num + 1 in starts and num - 1 in ends:\n        num_range_1 = ends[num - 1]\n        num_range_2 = starts[num + 1]\n        num_range = NumRange(num_range_1.start, num_range_2.end)\n        starts[num_range.start] = num_range\n        ends[num_range.end] = num_range\n        del starts[num_range_2.start]\n        del ends[num_range_1.end]\n        return\n    elif num + 1 in starts:\n        num_range = starts[num + 1]\n        num_range.start = num\n        starts[num] = num_range\n        del starts[num + 1]\n        return\n    elif num - 1 in ends:\n        num_range = ends[num - 1]\n        num_range.end = num\n        ends[num] = num_range\n        del ends[num - 1]\n        return\n    num_range = NumRange(num, num)\n    starts[num] = num_range\n    ends[num] = num_range\ndef get_seq_length(arr):\n    starts = dict()\n    ends = dict()\n    for num in arr:\n        add_number(num, starts, ends)\n    max_len = 0\n    for start in starts:\n        num_range = starts[start]\n        length = num_range.end - num_range.start + 1\n        max_len = length if length > max_len else max_len\n    return max_len", "title": "IE/99", "entry_cls_name": "Solution", "testing_code": "assert get_seq_length([100, 4, 200, 1]) == 1\nassert get_seq_length([100, 4, 200, 1, 3]) == 2\nassert get_seq_length([100, 4, 200, 1, 3, 2]) == 4\nassert get_seq_length([100, 4, 200, 1, 3, 2, 5]) == 5\nassert get_seq_length([9, 1, 4, 7, 3, -1, 0, 5, 8, -1, 6]) == 7", "entry_fn_name": "get_seq_length"}
{"id": "100", "text": "You are in an infinite 2D grid where you can move in any of the 8 directions:\n\n```\n (x,y) to\n    (x+1, y),\n    (x - 1, y),\n    (x, y+1),\n    (x, y-1),\n    (x-1, y-1),\n    (x+1,y+1),\n    (x-1,y+1),\n    (x+1,y-1)\n```\n\nYou are given a sequence of points and the order in which you need to cover the points. Give the minimum number of steps in which you can achieve it. You start from the first point.\n\nExample:\nInput: `[(0, 0), (1, 1), (1, 2)]`\nOutput: 2\nIt takes 1 step to move from (0, 0) to (1, 1). It takes one more step to move from (1, 1) to (1, 2).", "solution": "def get_distance(current_point, next_point, accumulated_distance):\n    x_diff = next_point[0] - current_point[0]\n    y_diff = next_point[1] - current_point[1]\n    if not x_diff:\n        return abs(y_diff) + accumulated_distance\n    if not y_diff:\n        return abs(x_diff) + accumulated_distance\n    updated_current = (current_point[0] + int(x_diff / abs(x_diff)), current_point[1] + int(y_diff / abs(y_diff)))\n    return get_distance(updated_current, next_point, accumulated_distance + 1)\ndef get_min_steps_helper(current_point, remaining_points, steps):\n    if not remaining_points:\n        return steps\n    next_point = remaining_points[0]\n    min_distance = get_distance(current_point, next_point, 0)\n    return get_min_steps_helper(next_point, remaining_points[1:], steps + min_distance)\ndef get_min_steps(points):\n    if not points:\n        return 0\n    return get_min_steps_helper(points[0], points[1:], 0)", "title": "IE/100", "entry_cls_name": "Solution", "testing_code": "assert get_min_steps([]) == 0\nassert get_min_steps([(0, 0)]) == 0\nassert get_min_steps([(0, 0), (1, 1), (1, 2)]) == 2\nassert get_min_steps([(0, 0), (1, 1), (1, 2), (3, 4)]) == 4\nassert get_min_steps([(0, 0), (1, 1), (1, 2), (3, 6)]) == 6\nassert get_min_steps([[0, 0], [1, 1], [1, 2]]) == 2\nassert get_min_steps([[4, 6], [1, 2], [4, 5], [10, 12]]) == 14", "entry_fn_name": "get_min_steps"}
{"id": "101", "text": "Given an even number (greater than 2), return two prime numbers whose sum will be equal to the given number.\n\nA solution will always exist. See Goldbach\u2019s conjecture.\n\nExample:\n\nInput: 4\nOutput: 2 + 2 = 4\nIf there are more than one solution possible, return the lexicographically smaller solution.\n\nIf `[a, b]` is one solution with `a <= b`, and `[c, d]` is another solution with `c <= d`, then\n\n```python\n[a, b] < [c, d]\nif a < c or a==c and b < d.\n```", "solution": "def is_prime(num, primes):\n    for prime in primes:\n        if prime == num:\n            return True\n        if not num % prime:\n            return False\n    return True\ndef get_primes(num):\n    limit = num // 2 + 1\n    candidates = list()\n    primes = list()\n    for i in range(2, limit):\n        if is_prime(i, primes):\n            primes.append(i)\n            candidates.append((i, num - i))\n    new_candidates = list()\n    for (first, second) in candidates[::-1]:\n        if is_prime(second, primes):\n            primes.append(second)\n            new_candidates.append([first, second])\n    return new_candidates[-1]", "title": "IE/101", "entry_cls_name": "Solution", "testing_code": "assert get_primes(4) == [2, 2]\nassert get_primes(10) == [3, 7]\nassert get_primes(100) == [3, 97]", "entry_fn_name": "get_primes"}
{"id": "102", "text": "Given a list of integers and a number K, return which contiguous elements of the list sum to K.\n\nFor example, if the list is [1, 2, 3, 4, 5] and K is 9, then it should return [2, 3, 4]. If no subset is found, return an empty list.", "solution": "def get_cont_arr(arr, target):\n    summed = 0\n    sum_tracker = {0:-1}\n    for idx, v in enumerate(arr):\n        summed+=v\n        sum_tracker[summed] = idx\n        prev= sum_tracker.get(summed-target)\n        if prev is not None:\n            return arr[prev+1:idx+1]\n    return []", "title": "IE/102", "entry_cls_name": "Solution", "testing_code": "assert get_cont_arr([1, 2, 3, 4, 5], 0) == []\nassert get_cont_arr([1, 2, 3, 4, 5], 1) == [1]\nassert get_cont_arr([1, 2, 3, 4, 5], 5) == [2, 3]\nassert get_cont_arr([5, 4, 3, 4, 5], 12) == [5, 4, 3]\nassert get_cont_arr([5, 4, 3, 4, 5], 11) == [4, 3, 4]\nassert get_cont_arr([1, 2, 3, 4, 5], 9) == [2, 3, 4]\nassert get_cont_arr([1, 2, 3, 4, 5], 3) == [1, 2]", "entry_fn_name": "get_cont_arr"}
{"id": "103", "text": "Given a string and a set of characters, return the shortest substring containing all the characters in the set.\n\nFor example, given the string \"figehaeci\" and the set of characters {a, e, i}, you should return \"aeci\".\n\nIf there is no substring containing all the characters in the set, return an empty string.", "solution": "from queue import Queue\ndef get_min_string(string, charset):\n    curr_queue = list()\n    ind_queue = list()\n    curr_seen = set()\n    candidate = None\n    i = 0\n    while i < len(string):\n        if string[i] in charset:\n            curr_queue.append(string[i])\n            ind_queue.append(i)\n            curr_seen.add(string[i])\n        shift = 0\n        for k in range(len(curr_queue) // 2):\n            if curr_queue[k] == curr_queue[-k - 1]:\n                shift += 1\n        curr_queue = curr_queue[shift:]\n        ind_queue = ind_queue[shift:]\n        if len(curr_seen) == len(charset):\n            if not candidate or len(candidate) > ind_queue[-1] - ind_queue[0] + 1:\n                candidate = string[ind_queue[0]:ind_queue[-1] + 1]\n        i += 1\n    return candidate or ''", "title": "IE/103", "entry_cls_name": "Solution", "testing_code": "assert get_min_string('abcdedbc', {'g', 'f'}) == ''\nassert get_min_string('abccbbbccbcb', {'a', 'b', 'c'}) == 'abc'\nassert get_min_string('figehaeci', {'a', 'e', 'i'}) == 'aeci'\nassert get_min_string('abcdedbc', {'d', 'b', 'b'}) == 'db'\nassert get_min_string('abcdedbc', {'b', 'c'}) == 'bc'\nassert get_min_string('abcdecdb', {'b', 'c'}) == 'bc'\nassert get_min_string('abcdecdb', {'b', 'c', 'e'}) == 'bcde'", "entry_fn_name": "get_min_string"}
{"id": "104", "text": "Determine whether a doubly linked list is a palindrome. What if it\u2019s singly linked?\n\nFor example, `1 -> 4 -> 3 -> 4 -> 1` returns true while `1 -> 4` returns false.", "solution": "class Node:\n\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\n    def __repr__(self):\n        return '{} -> {}'.format(self.val, self.next)\ndef reverse(head):\n    if not head.next:\n        new_head = Node(head.val)\n        return (new_head, new_head)\n    (rev_head, rev_tail) = reverse(head.next)\n    rev_tail.next = Node(head.val)\n    return (rev_head, rev_tail.next)\ndef is_palindrome(head):\n    if not head:\n        return None\n    reversed_head = reverse(head)\n    curr = head\n    curr_rev = reversed_head[0]\n    while curr:\n        if curr.val != curr_rev.val:\n            return False\n        curr = curr.next\n        curr_rev = curr_rev.next\n    return True", "title": "IE/104", "entry_cls_name": "Solution", "testing_code": "a0 = Node('a')\na1 = Node('a')\nb0 = Node('b')\nc0 = Node('c')\na0.next = b0\nb0.next = c0\nassert not is_palindrome(a0)\nb0.next = a1\nassert is_palindrome(a0)\na0 = Node('a')\nassert is_palindrome(a0)\nb0 = Node('b')\na0.next = b0\nassert not is_palindrome(a0)", "entry_fn_name": "is_palindrome"}
{"id": "105", "text": "Given a function f, and N return a debounced f of N milliseconds.\n\nThat is, as long as the debounced f continues to be invoked, f itself will not be called for N milliseconds.", "solution": "import time\ndef debounce(s):\n    \"\"\"\n    Decorator ensures function that can only be called once every `s` seconds.\n    \"\"\"\n    interval = s * 10 ** (-3)\n\n    def decorate(f):\n        current_time = None\n\n        def wrapped(*args, **kwargs):\n            nonlocal current_time\n            start_time = time.time()\n            if current_time is None or start_time - current_time >= interval:\n                result = f(*args, **kwargs)\n                current_time = time.time()\n                return result\n        return wrapped\n    return decorate\n@debounce(3000)\ndef add_nums(x, y):\n    return x + y", "title": "IE/105", "entry_cls_name": "Solution", "testing_code": "import time\nassert add_nums(1, 1) == 2\ntime.sleep(1)\nassert not add_nums(1, 2)\ntime.sleep(1)\nassert not add_nums(1, 3)\ntime.sleep(1)\nassert add_nums(1, 4) == 5", "entry_fn_name": "add_nums"}
{"id": "106", "text": "Given an integer list where each number represents the number of hops you can make, determine whether you can reach to the last index starting at index 0.\n\nFor example, `[2, 0, 1, 0]` returns `true` while `[1, 1, 0, 1]` returns `false`.", "solution": "def reaches_last_helper(arr, start_index, target_index):\n    if start_index == target_index:\n        return True\n    hop = arr[start_index]\n    if not hop or start_index + hop > target_index:\n        return False\n    return reaches_last_helper(arr, start_index + hop, target_index)\ndef reaches_last(arr):\n    return reaches_last_helper(arr, 0, len(arr) - 1)", "title": "IE/106", "entry_cls_name": "Solution", "testing_code": "assert reaches_last([2, 0, 1, 0])\nassert not reaches_last([1, 1, 0, 1])\nassert not reaches_last([2, 1])\nassert reaches_last([2, 0, 1, 0]) == True\nassert reaches_last([1, 1, 0, 1]) == False\nassert reaches_last([2, 3, 1, 1, 4]) == True\nassert reaches_last([3, 2, 1, 0, 4]) == False", "entry_fn_name": "reaches_last"}
{"id": "108", "text": "Given two strings A and B, return whether or not A can be shifted some number of times to get B.\n\nFor example, if A is `abcde` and B is `cdeab`, return true. If A is `abc` and B is `acb`, return false.", "solution": "def can_shift(target, string):\n    return target and string and (len(target) == len(string)) and (string in target * 2)", "title": "IE/108", "entry_cls_name": "Solution", "testing_code": "assert can_shift('abcde', 'cdeab')\nassert not can_shift('abc', 'acb')\nassert can_shift('abcde', 'cdeab') == True\nassert can_shift('abc', 'acb') == False", "entry_fn_name": "can_shift"}
{"id": "109", "text": "Given an unsigned 8-bit integer, swap its even and odd bits. The 1st and 2nd bit should be swapped, the 3rd and 4th bit should be swapped, and so on.\n\nFor example, `10101010` should be `01010101`. `11100010` should be `11010001`.\n\nBonus: Can you do this in one line?", "solution": "def swap_bits(num):\n    return (num & 85) << 1 | (num & 85 << 1) >> 1", "title": "IE/109", "entry_cls_name": "Solution", "testing_code": "assert swap_bits(0) == 0\nassert swap_bits(255) == 255\nassert swap_bits(210) == 225\nassert swap_bits(170) == 85\nassert swap_bits(226) == 209\nassert swap_bits(0b10101010) == 0b01010101\nassert swap_bits(0b11100010) == 0b11010001", "entry_fn_name": "swap_bits"}
{"id": "110", "text": "Given a binary tree, return all paths from the root to leaves.\n\nFor example, given the tree\n\n```\n   1\n  / \\\n 2   3\n    / \\\n   4   5\n```\n\nit should return `[[1, 2], [1, 3, 4], [1, 3, 5]]`.", "solution": "class Node:\n\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n    def __repr__(self):\n        return str(self.val)\ndef get_all_paths(node):\n    if not node:\n        return []\n    node_paths = list()\n    left_paths = get_all_paths(node.left)\n    for path in left_paths:\n        node_paths.append([node.val] + path)\n    right_paths = get_all_paths(node.right)\n    for path in right_paths:\n        node_paths.append([node.val] + path)\n    return node_paths if node_paths else [[node.val]]", "title": "IE/110", "entry_cls_name": "Solution", "testing_code": "a = Node(1)\nb = Node(2)\nc = Node(3)\nd = Node(4)\ne = Node(5)\na.left = b\na.right = c\nc.left = d\nc.right = e\nassert get_all_paths(a) == [[1, 2], [1, 3, 4], [1, 3, 5]]\nassert get_all_paths(b) == [[2]]\nassert get_all_paths(c) == [[3, 4], [3, 5]]", "entry_fn_name": "get_all_paths"}
{"id": "111", "text": "Given a word W and a string S, find all starting indices in S which are anagrams of W.\n\nFor example, given that W is \"ab\", and S is \"abxaba\", return 0, 3, and 4.", "solution": "def is_anagram(s, p):\n\t\tcounter = [0] * 26\n    \n\t\tfor letter in p:\n\t\t\t\tcounter[ord(letter) - ord(\"a\")] += 1\n    \n\t\tfor letter in s:\n\t\t\t\tcounter[ord(letter) - ord(\"a\")] -= 1\n\t\t\t\tif counter[ord(letter) - ord(\"a\")] < 0:\n\t\t\t\t\t\treturn False\n\t\treturn True\n    \ndef get_anagram_starts(s, word):\n\t\tres = []\n\t\tm, n = len(s), len(word)\n\t\tfor i in range(m-n+1):\n\t\t\t\tif is_anagram(s[i:i+n], word):\n\t\t\t\t\t\tres.append(i)\n\t\treturn res", "title": "IE/111", "entry_cls_name": "Solution", "testing_code": "assert get_anagram_starts('abxaba', 'ab') == [0, 3, 4]\nassert get_anagram_starts('cataract', 'tac') == [0, 5]\nassert get_anagram_starts('cbbbaa','cccbba') == []\nassert get_anagram_starts('tar','tar')==[0]\nassert get_anagram_starts('cataract', 'tac') == [0, 5]\nassert get_anagram_starts('cbaebabacd', 'abc') == [0, 6]\nassert get_anagram_starts('abab', 'ab') == [0, 1, 2]", "entry_fn_name": "get_anagram_starts"}
{"id": "113", "text": "Given a string of words delimited by spaces, reverse the words in string. For example, given \"hello world here\", return \"here world hello\"\n\nFollow-up: given a mutable string representation, can you perform this operation in-place?", "solution": "def reverse_words(string):\n    return ' '.join(reversed(string.split()))", "title": "IE/113", "entry_cls_name": "Solution", "testing_code": "assert reverse_words('hello world here') == 'here world hello'", "entry_fn_name": "reverse_words"}
{"id": "114", "text": "Given a string and a set of delimiters, reverse the words in the string while maintaining the relative order of the delimiters. For example, given \"hello/world:here\", return \"here/world:hello\"\n\nFollow-up: Does your solution work for the following cases: \"hello/world:here/\", \"hello//world:here\"", "solution": "def reverse_words(string, delimiters):\n    words = list()\n    delims = list()\n    delim_positions = list()\n    start = 0\n    i = 0\n    while i < len(string):\n        char = string[i]\n        if char in delimiters:\n            word = string[start:i]\n            if i - start > 1:\n                words.append(word)\n            delims.append(char)\n            delim_positions.append(len(words) + len(delims) - 1)\n            start = i + 1\n        i += 1\n    if i - start > 1:\n        words.append(string[start:i])\n    words.reverse()\n    reversed_order = list()\n    word_index = 0\n    delim_index = 0\n    for i in range(len(words) + len(delims)):\n        if delim_index < len(delim_positions) and delim_positions[delim_index] == i:\n            reversed_order.append(delims[delim_index])\n            delim_index += 1\n        else:\n            reversed_order.append(words[word_index])\n            word_index += 1\n    reversed_string = ''.join(reversed_order)\n    return reversed_string", "title": "IE/114", "entry_cls_name": "Solution", "testing_code": "assert reverse_words('hello/world:here/', [':', '/']) == 'here/world:hello/'\nassert reverse_words(':hello//world:here/', [':', '/']) == ':here//world:hello/'\nassert reverse_words('hello//world:here', [':', '/']) == 'here//world:hello'\nassert reverse_words('hello/world:here', [':', '/']) == 'here/world:hello'\nassert reverse_words('hello world, here', [':', '/']) == 'hello world, here'\n", "entry_fn_name": "reverse_words"}
{"id": "117", "text": "Given a binary tree, return the level of the tree with minimum sum.", "solution": "class Node:\n\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n    def __repr__(self):\n        return '{}=(l={}, r={})'.format(self.val, self.left, self.right)\ndef get_maxsum_level_helper(level, nodes, parent_sum):\n    child_nodes = list()\n    nodes_sum = 0\n    for node in nodes:\n        nodes_sum += node.val\n        if node.left:\n            child_nodes.append(node.left)\n        if node.right:\n            child_nodes.append(node.right)\n    max_sum = max(nodes_sum, parent_sum)\n    if child_nodes:\n        max_sum = get_maxsum_level_helper(level + 1, child_nodes, max_sum)\n    return max_sum\ndef get_maxsum_level(root):\n    max_sum = get_maxsum_level_helper(0, [root], -sys.maxsize)\n    return max_sum", "title": "IE/117", "entry_cls_name": "Solution", "testing_code": "import sys\na = Node(1)\nb = Node(2)\nc = Node(3)\na.left = b\na.right = c\nd = Node(4)\ne = Node(5)\nb.left = d\nb.right = e\nf = Node(6)\ng = Node(7)\nc.left = f\nc.right = g\nh = Node(8)\nd.right = h\nassert get_maxsum_level(a) == 22\na.val = 100\nassert get_maxsum_level(a) == 100\nb.val = 150\nassert get_maxsum_level(a) == 153\nh.val = 200\nassert get_maxsum_level(a) == 200", "entry_fn_name": "get_maxsum_level"}
{"id": "118", "text": "Given a sorted list of integers, square the elements and give the output in sorted order.\n\nFor example, given `[-9, -2, 0, 2, 3]`, return `[0, 4, 4, 9, 81]`.", "solution": "def merge_sorted_lists(arr1, arr2):\n    (i, k) = (0, 0)\n    merged = list()\n    while i < len(arr1) and k < len(arr2):\n        if arr1[i] <= arr2[k]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[k])\n            k += 1\n    merged += arr1[i:]\n    merged += arr2[k:]\n    return merged\ndef sort_squares(arr):\n    first_pos_index = 0\n    for num in arr:\n        if num >= 0:\n            break\n        first_pos_index += 1\n    neg_nums = [x ** 2 for x in reversed(arr[:first_pos_index])]\n    pos_nums = [x ** 2 for x in arr[first_pos_index:]]\n    return merge_sorted_lists(pos_nums, neg_nums)", "title": "IE/118", "entry_cls_name": "Solution", "testing_code": "assert sort_squares([]) == []\nassert sort_squares([0]) == [0]\nassert sort_squares([-1, 1]) == [1, 1]\nassert sort_squares([0, 2, 3]) == [0, 4, 9]\nassert sort_squares([-9, -2, 0]) == [0, 4, 81]\nassert sort_squares([-9, -2, 0, 2, 3]) == [0, 4, 4, 9, 81]", "entry_fn_name": "sort_squares"}
{"id": "119", "text": "Given a set of closed intervals, find the smallest set of numbers that covers all the intervals. If there are multiple smallest sets, return any of them.\n\nFor example, given the intervals `[0, 3], [2, 6], [3, 4], [6, 9]`, one set of numbers that covers all these intervals is `{3, 6}`.", "solution": "import sys\nclass Interval:\n\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\n    def __hash__(self):\n        return hash(str(self))\n\n    def __repr__(self):\n        return '[{}-{}]'.format(self.start, self.end)\ndef get_smallest_stab_set_helper(remaining_intervals, used_points, remaining_points, num_to_intervals):\n    if not remaining_intervals:\n        return used_points\n    min_len = sys.maxsize\n    smallest_stab_set = None\n    for current_point in remaining_points:\n        if current_point not in num_to_intervals:\n            continue\n        current_point_intervals = num_to_intervals[current_point]\n        new_rem_intervals = remaining_intervals - current_point_intervals\n        new_used_points = used_points.copy()\n        new_used_points.add(current_point)\n        new_rem_points = remaining_points.copy()\n        new_rem_points.remove(current_point)\n        stab_set = get_smallest_stab_set_helper(new_rem_intervals, new_used_points, new_rem_points, num_to_intervals)\n        if len(stab_set) < min_len:\n            smallest_stab_set = stab_set\n            min_len = len(stab_set)\n    return smallest_stab_set\ndef get_smallest_stab_set(interval_tuples):\n    intervals = set()\n    num_to_intervals = dict()\n    endpoints = set()\n    for (start, end) in interval_tuples:\n        endpoints.add(end)\n        interval = Interval(start, end)\n        intervals.add(interval)\n        for num in range(start, end + 1):\n            if num not in num_to_intervals:\n                num_to_intervals[num] = set()\n            num_to_intervals[num].add(interval)\n    smallest_stab_set = get_smallest_stab_set_helper(intervals, set(), endpoints, num_to_intervals)\n    return smallest_stab_set", "title": "IE/119", "entry_cls_name": "Solution", "testing_code": "assert get_smallest_stab_set([[0, 3]]) == {3}\nassert get_smallest_stab_set([[0, 3], [2, 6]]) == {3}\nassert get_smallest_stab_set([[0, 3], [2, 6], [3, 4]]) == {3}\nassert get_smallest_stab_set([[0, 3], [2, 6], [3, 4], [6, 7]]) == {3, 6}\nassert get_smallest_stab_set([[0, 3], [2, 6], [3, 4], [6, 9]]) == {3, 9}\nassert get_smallest_stab_set([[0, 3], [2, 6], [3, 4], [6, 100]]) == {3, 100}", "entry_fn_name": "get_smallest_stab_set"}
{"id": "121", "text": "Given a string which we can delete at most k, return whether you can make a palindrome.\n\nFor example, given 'waterrfetawx' and a k of 2, you could delete f and x to get 'waterretaw'.", "solution": "def is_palindrome(string):\n    return bool(string) and string == string[::-1]\ndef make_palindrome(string, num_delete):\n    if is_palindrome(string):\n        return True\n    if not num_delete:\n        return False\n    for (i, _) in enumerate(string):\n        new_string = string[:i] + string[i + 1:]\n        if make_palindrome(new_string, num_delete - 1):\n            return True\n    return False", "title": "IE/121", "entry_cls_name": "Solution", "testing_code": "assert make_palindrome('a', 0)\nassert make_palindrome('aaa', 2)\nassert not make_palindrome('add', 0)\nassert make_palindrome('waterrfetawx', 2)\nassert not make_palindrome('waterrfetawx', 1)\nassert make_palindrome('waterrfetawx', 3)\nassert make_palindrome('malayalam', 0)\nassert make_palindrome('malayalam', 1)\nassert make_palindrome('asdf', 5)\nassert not make_palindrome('asdf', 2)", "entry_fn_name": "make_palindrome"}
{"id": "122", "text": "You are given a 2-d matrix where each cell represents number of coins in that cell. Assuming we start at `matrix[0][0]`, and can only move right or down, find the maximum number of coins you can collect by the bottom right corner.\n\nFor example, in this matrix\n```\n0 3 1 1\n2 0 0 4\n1 5 3 1\n```\n\nThe most we can collect is `0 + 2 + 1 + 5 + 3 + 1 = 12` coins.", "solution": "def get_max_coins_helper(matrix, crow, ccol, rows, cols):\n    cval = matrix[crow][ccol]\n    if crow == rows - 1 and ccol == cols - 1:\n        return cval\n    (down, right) = (cval, cval)\n    if crow < rows - 1:\n        down += get_max_coins_helper(matrix, crow + 1, ccol, rows, cols)\n    if ccol < cols - 1:\n        right += get_max_coins_helper(matrix, crow, ccol + 1, rows, cols)\n    return max(down, right)\ndef get_max_coins(matrix):\n    if matrix:\n        return get_max_coins_helper(matrix, 0, 0, len(matrix), len(matrix[0]))", "title": "IE/122", "entry_cls_name": "Solution", "testing_code": "coins = [[0, 3, 1, 1], [2, 0, 0, 4], [1, 5, 3, 1]]\nassert get_max_coins(coins) == 12\ncoins = [[0, 3, 1, 1], [2, 8, 9, 4], [1, 5, 3, 1]]\nassert get_max_coins(coins) == 25", "entry_fn_name": "get_max_coins"}
{"id": "123", "text": "Given a string, return whether it represents a number. Here are the different kinds of numbers:\n* \"10\", a positive integer\n* \"-10\", a negative integer\n* \"10.1\", a positive real number\n* \"-10.1\", a negative real number\n* \"1e5\", a number in scientific notation\n\nAnd here are examples of non-numbers:\n* \"a\"\n* \"x 1\"\n* \"a -2\"\n* \"-\"", "solution": "def strip_neg(num):\n    if num[0] != '-':\n        return num\n    elif len(num) > 1:\n        return num[1:]\ndef is_valid_number_helper(string, dec):\n    if not string:\n        return True\n    char = string[0]\n    if dec and char == '.' or (not char.isdigit() and char != '.'):\n        return False\n    elif char == '.':\n        dec = True\n    return is_valid_number_helper(string[1:], dec)\ndef is_valid_number(string):\n    if not string:\n        return False\n    split_list = string.split('e')\n    if len(split_list) > 2:\n        return False\n    if len(split_list) == 2:\n        string_1 = strip_neg(split_list[0])\n        string_2 = strip_neg(split_list[1])\n        return string_1 and string_2 and is_valid_number_helper(string_1, False) and is_valid_number_helper(string_2, False)\n    else:\n        string = strip_neg(split_list[0])\n        return string and is_valid_number_helper(string, False)\n    return False", "title": "IE/123", "entry_cls_name": "Solution", "testing_code": "assert is_valid_number('10')\nassert is_valid_number('-10')\nassert is_valid_number('10.1')\nassert is_valid_number('-10.1')\nassert is_valid_number('1e5')\nassert is_valid_number('-5')\nassert is_valid_number('1e-5')\nassert is_valid_number('1e-5.2')\nassert not is_valid_number('a')\nassert not is_valid_number('x 1')\nassert not is_valid_number('a -2')\nassert not is_valid_number('-')", "entry_fn_name": "is_valid_number"}
{"id": "124", "text": "You have 100 fair coins and you flip them all at the same time. Any that come up tails you set aside. The ones that come up heads you flip again. How many rounds do you expect to play before only one coin remains?\n\nWrite a function that, given $n$, returns the number of rounds you'd expect to play until one coin remains.", "solution": "from math import log, ceil\ndef get_num_expected(coin_tosses):\n    return ceil(log(coin_tosses, 2))", "title": "IE/124", "entry_cls_name": "Solution", "testing_code": "assert get_num_expected(1) == 0\nassert get_num_expected(2) == 1\nassert get_num_expected(100) == 7\nassert get_num_expected(200) == 8", "entry_fn_name": "get_num_expected"}
{"id": "125", "text": "Given the root of a binary search tree, and a target K, return two nodes in the tree whose sum equals K.\n\nFor example, given the following tree and K of 20\n\n```\n    10\n   /   \\\n 5      15\n       /  \\\n     11    15\n```\n\nReturn the nodes 5 and 15.", "solution": "class Node:\n\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n    def __repr__(self):\n        return str(self.val)\ndef get_array(root):\n    arr = [root]\n    if not root.left and (not root.right):\n        return arr\n    if root.left:\n        arr = get_array(root.left) + arr\n    if root.right:\n        arr = arr + get_array(root.right)\n    return arr\ndef search_pair(root, val):\n    arr = get_array(root)\n    (i, k) = (0, len(arr) - 1)\n    while i < k:\n        summed = arr[i].val + arr[k].val\n        if summed == val:\n            return (arr[i], arr[k])\n        elif summed < val:\n            i += 1\n        else:\n            k -= 1", "title": "IE/125", "entry_cls_name": "Solution", "testing_code": "a = Node(10)\nb = Node(5)\nc = Node(15)\nd = Node(11)\ne = Node(15)\na.left = b\na.right = c\nc.left = d\nc.right = e\nassert search_pair(a, 15) == (b, a)\nassert search_pair(a, 20) == (b, e)\nassert search_pair(a, 30) == (c, e)\nassert search_pair(a, 26) == (d, e)", "entry_fn_name": "search_pair"}
{"id": "130", "text": "Given an array of numbers representing the stock prices of a company in chronological order and an integer k, return the maximum profit you can make from k buys and sells. You must buy the stock before you can sell it, and you must sell the stock before you can buy it again.\n\nFor example, given `k = 2` and the array `[5, 2, 4, 0, 1]`, you should return `3`.", "solution": "def profit_helper(prices, curr_index, curr_profit, buys_left, sells_left):\n    if curr_index == len(prices) or not sells_left:\n        return curr_profit\n    if buys_left == sells_left:\n        return max(profit_helper(prices, curr_index + 1, curr_profit - prices[curr_index], buys_left - 1, sells_left), profit_helper(prices, curr_index + 1, curr_profit, buys_left, sells_left))\n    else:\n        return max(profit_helper(prices, curr_index + 1, curr_profit + prices[curr_index], buys_left, sells_left - 1), profit_helper(prices, curr_index + 1, curr_profit, buys_left, sells_left))\ndef get_max_profit(prices, k):\n    return profit_helper(prices, 0, 0, k, k)", "title": "IE/130", "entry_cls_name": "Solution", "testing_code": "assert get_max_profit([5, 2, 4, 0, 1], 2) == 3\nassert get_max_profit([5, 2, 4], 2) == 2\nassert get_max_profit([5, 2, 4], 1) == 2", "entry_fn_name": "get_max_profit"}
{"id": "133", "text": "Given a node in a binary tree, return the next bigger element, also known as the inorder successor.\n(NOTE: I'm assuming this is a binary search tree, because otherwise, the problem makes no sense at all)\n\nFor example, the inorder successor of 22 is 30.\n\n```\n   10\n  /  \\\n 5    30\n     /  \\\n   22    35\n```\nYou can assume each node has a parent pointer.", "solution": "class Node:\n\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.parent = None\n\n    def __repr__(self):\n        return str(self.val)\ndef inorder_helper(root):\n    list_rep = [root]\n    if root.left:\n        list_rep = inorder_helper(root.left) + list_rep\n    if root.right:\n        list_rep = list_rep + inorder_helper(root.right)\n    return list_rep\ndef find_next_inorder(target_node):\n    root = target_node\n    while root.parent:\n        root = root.parent\n    all_nodes = inorder_helper(root)\n    for (i, node) in enumerate(all_nodes):\n        if node == target_node:\n            if i == len(all_nodes) - 1:\n                return None\n            return all_nodes[i + 1]", "title": "IE/133", "entry_cls_name": "Solution", "testing_code": "root = Node(10)\nroot.left = Node(5)\nroot.right = Node(30)\nroot.left.parent = root\nroot.right.parent = root\nroot.right.left = Node(22)\nroot.right.right = Node(35)\nroot.right.left.parent = root.right\nroot.right.right.parent = root.right\nassert not find_next_inorder(root.right.right)\nassert find_next_inorder(root.right.left) == root.right\nassert find_next_inorder(root) == root.right.left\nassert find_next_inorder(root.left) == root", "entry_fn_name": "find_next_inorder"}
{"id": "135", "text": "Given a binary tree, find a minimum path sum from root to a leaf.\n\nFor example, the minimum path in this tree is `[10, 5, 1, -1]`, which has sum 15.\n\n```\n  10\n /  \\\n5    5\n \\     \\\n   2    1\n       /\n     -1\n```", "solution": "class Node:\n\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n    def __repr__(self):\n        return str(self.val)\ndef min_path_helper(root, path, path_sum):\n    candidate_sum = path_sum + root.val\n    candidate_path = path + [root.val]\n    if not root.left and (not root.right):\n        return (candidate_sum, candidate_path)\n    (left_min_val, right_min_val) = (sys.maxsize, sys.maxsize)\n    if root.left:\n        (left_min_val, left_path) = min_path_helper(root.left, candidate_path, candidate_sum)\n    if root.right:\n        (right_min_val, right_path) = min_path_helper(root.right, candidate_path, candidate_sum)\n    return (left_min_val, left_path) if left_min_val < right_min_val else (right_min_val, right_path)\ndef find_min_path(root):\n    (_, min_path) = min_path_helper(root, list(), 0)\n    return min_path", "title": "IE/135", "entry_cls_name": "Solution", "testing_code": "import sys\na = Node(10)\nb = Node(5)\nc = Node(5)\na.left = b\na.right = c\nd = Node(2)\nb.right = d\ne = Node(1)\nc.right = e\nf = Node(-1)\ne.left = f\nassert find_min_path(a) == [10, 5, 1, -1]\nf.val = 5\nassert find_min_path(a) == [10, 5, 2]", "entry_fn_name": "find_min_path"}
{"id": "136", "text": "Given an N by M matrix consisting only of 1's and 0's, find the largest rectangle containing only 1's and return its area.\n\nFor example, given the following matrix:\n\n```\n[[1, 0, 0, 0],\n [1, 0, 1, 1],\n [1, 0, 1, 1],\n [0, 1, 0, 0]]\n```\n\nReturn 4.", "solution": "def extendable_row(matrix, erow, scol, ecol):\n    return all(matrix[erow][scol:ecol])\ndef extendable_col(matrix, ecol, srow, erow):\n    for row in range(srow, erow):\n        if not matrix[row][ecol]:\n            return False\n    return True\ndef area_helper(matrix, num_rows, num_cols, srow, erow, scol, ecol):\n    current_area = (erow - srow) * (ecol - scol)\n    (row_ex_area, col_ex_area) = (0, 0)\n    ex_row = erow < num_rows and extendable_row(matrix, erow, scol, ecol)\n    if ex_row:\n        row_ex_area = area_helper(matrix, num_rows, num_cols, srow, erow + 1, scol, ecol)\n    ex_col = ecol < num_cols and extendable_col(matrix, ecol, srow, erow)\n    if ex_col:\n        col_ex_area = area_helper(matrix, num_rows, num_cols, srow, erow, scol, ecol + 1)\n    return max(current_area, row_ex_area, col_ex_area)\ndef get_largest_area(matrix):\n    max_area = 0\n    if not matrix:\n        return max_area\n    (num_rows, num_cols) = (len(matrix), len(matrix[0]))\n    for i in range(num_rows):\n        for j in range(num_cols):\n            upper_bound_area = (num_rows - i) * (num_cols - j)\n            if matrix[i][j] and upper_bound_area > max_area:\n                area = area_helper(matrix, num_rows, num_cols, i, i + 1, j, j + 1)\n                max_area = area if area > max_area else max_area\n    return max_area", "title": "IE/136", "entry_cls_name": "Solution", "testing_code": "matrix = [[1, 0, 0, 0], [1, 0, 1, 1], [1, 0, 1, 1], [0, 1, 0, 0]]\nassert get_largest_area(matrix) == 4\nmatrix = [[1, 0, 0, 0], [1, 0, 1, 1], [1, 0, 1, 1], [0, 1, 1, 1]]\nassert get_largest_area(matrix) == 6\nmatrix = [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]\nassert get_largest_area(matrix) == 16\nmatrix = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\nassert get_largest_area(matrix) == 0\nmatrix = [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 0, 0], [0, 0, 0, 0]]\nassert get_largest_area(matrix) == 8\nmatrix = [[1, 1, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0]]\nassert get_largest_area(matrix) == 4", "entry_fn_name": "get_largest_area"}
{"id": "138", "text": "Find the minimum number of coins required to make n cents.\n\nYou can use standard American denominations, that is, 1\u00a2, 5\u00a2, 10\u00a2, and 25\u00a2.\n\nFor example, given n = 16, return 3 since we can make it with a 10\u00a2, a 5\u00a2, and a 1\u00a2.", "solution": "def get_min_coins(amount, denoms):\n    if amount == 0:\n        return 0\n    (denom_to_use, index_cutoff) = (None, None)\n    for (i, denom) in enumerate(denoms):\n        if amount >= denom:\n            denom_to_use = denom\n            index_cutoff = i\n            break\n    coins_used = amount // denom_to_use\n    return coins_used + get_min_coins(amount - denom_to_use * coins_used, denoms[index_cutoff + 1:])", "title": "IE/138", "entry_cls_name": "Solution", "testing_code": "denoms = [25, 10, 5, 1]\nassert get_min_coins(16, denoms) == 3\nassert get_min_coins(90, denoms) == 5\nassert get_min_coins(100, denoms) == 4", "entry_fn_name": "get_min_coins"}
{"id": "142", "text": "You're given a string consisting solely of `(`, `)`, and `*`. \n`*` can represent either a `(`, `)`, or an empty string. Determine whether the parentheses are balanced.\n\nFor example, `(()*` and `(*)` are balanced. `)*(` is not balanced.", "solution": "def valid_paren(string):\n    def _valid_paren(string, stack=list()):\n        stack=stack or []\n        if not string and (not stack):\n            return True\n        elif not string:\n            return False\n        cchar = string[0]\n        remaining = string[1:]\n        if cchar == '*':\n            return _valid_paren('(' + remaining, stack) or _valid_paren(')' + remaining, stack) or _valid_paren(remaining, stack)\n        cstack = stack.copy()\n        if cchar == ')' and (not stack):\n            return False\n        elif cchar == ')':\n            cstack.pop()\n        else:\n            cstack.append(cchar)\n        return _valid_paren(remaining, cstack)\n    return _valid_paren(string)", "title": "IE/142", "entry_cls_name": "Solution", "testing_code": "assert valid_paren('(()*')\nassert valid_paren('(*)')\nassert not valid_paren(')*(')", "entry_fn_name": "valid_paren"}
{"id": "143", "text": "Given a pivot `x`, and a list `lst`, partition the list into three parts.\n* The first part contains all elements in `lst` that are less than `x`\n* The second part contains all elements in `lst` that are equal to `x`\n* The third part contains all elements in `lst` that are larger than `x`\nOrdering within a part can be arbitrary.\n\nFor example, given `x = 10` and `lst = [9, 12, 3, 5, 14, 10, 10]`, one partition may be `[9, 3, 5, 10, 10, 12, 14]`", "solution": "def swap_indices(arr, i, k):\n    tmp = arr[i]\n    arr[i] = arr[k]\n    arr[k] = tmp\ndef separate_with_pivot(arr, i, k, x):\n    if not arr:\n        return\n    while i < k:\n        if arr[i] >= x and arr[k] < x:\n            swap_indices(arr, i, k)\n        else:\n            if arr[i] < x:\n                i += 1\n            if arr[k] >= x:\n                k -= 1\n    return i + 1 if arr[i] < x and i + 1 < len(arr) else i\ndef pivot_list(arr, x):\n    mid = separate_with_pivot(arr, 0, len(arr) - 1, x)\n    separate_with_pivot(arr, mid, len(arr) - 1, x + 1)\n    return arr", "title": "IE/143", "entry_cls_name": "Solution", "testing_code": "assert pivot_list([9, 12, 3, 5, 14, 10, 10], 10) == [9, 5, 3, 10, 10, 14, 12]\nassert pivot_list([9, 12, 3, 5, 14, 10, 10], 8) == [5, 3, 12, 9, 14, 10, 10]\nassert pivot_list([9, 12, 14, 10, 10], 8) == [9, 12, 14, 10, 10]\nassert pivot_list([3, 5], 8) == [3, 5]\nassert pivot_list([8, 8, 8], 8) == [8, 8, 8]\nassert pivot_list([], 8) == []", "entry_fn_name": "pivot_list"}
{"id": "144", "text": "Given an array of numbers and an index `i`, return the index of the nearest larger number of the number at index `i`, where distance is measured in array indices.\n\nFor example, given `[4, 1, 3, 5, 6]` and index `0`, you should return `3`.\n\nIf two distances to larger numbers are equal, then return any one of them. If the array at `i` doesn't have a nearest larger integer, then return `-1`.\n\nFollow-up: If you can preprocess the array, can you do this in constant time?\n\n", "solution": "def get_mapping_indices(arr):\n    nl_indices = dict()\n    sorted_tuples = [(x, i) for (i, x) in enumerate(arr)]\n    sorted_tuples.sort(key=lambda x: x[0])\n    for (k, (_, i)) in enumerate(sorted_tuples[:-1]):\n        min_dist = len(arr)\n        for m in range(k + 1, len(sorted_tuples)):\n            dist = abs(i - sorted_tuples[m][1])\n            if dist < min_dist:\n                min_dist = dist\n                nl_indices[i] = sorted_tuples[m][1]\n    return nl_indices\ndef nearest_larger(arr, index):\n    nl_indices = get_mapping_indices(arr)\n    if index not in nl_indices:\n        return -1\n    return nl_indices[index]\n", "title": "IE/144", "entry_cls_name": "Solution", "testing_code": "assert nearest_larger([4, 1, 3, 5, 6], 0) == 3\nassert nearest_larger([4, 1, 3, 5, 6], 1) == 2\nassert nearest_larger([4, 1, 3, 5, 6], 4) == -1\nassert nearest_larger([4, 1, 3, 5, 6], 3) == 4\n", "entry_fn_name": "nearest_larger"}
{"id": "147", "text": "Given a list, sort it using this method: `reverse(lst, i, j)`, which sorts `lst` from `i` to `j`.", "solution": "def merge_sorted(arr_1, arr_2):\n    merged_array = list()\n    (ind_1, ind_2) = (0, 0)\n    while ind_1 < len(arr_1) and ind_2 < len(arr_2):\n        if arr_1[ind_1] <= arr_2[ind_2]:\n            merged_array.append(arr_1[ind_1])\n            ind_1 += 1\n        else:\n            merged_array.append(arr_2[ind_2])\n            ind_2 += 1\n    while ind_1 < len(arr_1):\n        merged_array.append(arr_1[ind_1])\n        ind_1 += 1\n    while ind_2 < len(arr_2):\n        merged_array.append(arr_2[ind_2])\n        ind_2 += 1\n    return merged_array\ndef reverse(lst, i, j):\n    return list(reversed(lst[i:j + 1]))\ndef custom_sort(lst):\n    (start, end) = (None, None)\n    last_end = -1\n    sorted_segments = list()\n    for i in range(1, len(lst)):\n        if lst[i] < lst[i - 1]:\n            if not start:\n                segment = lst[last_end + 1:i - 1]\n                if segment:\n                    sorted_segments.append(segment)\n                start = i - 1\n        elif start:\n            end = i - 1\n            if end > start:\n                sorted_segments.append(reverse(lst, start, end))\n                last_end = end\n                (start, end) = (None, None)\n    if start:\n        end = len(lst) - 1\n        if end > start:\n            sorted_segments.append(reverse(lst, start, end))\n    else:\n        segment = lst[last_end + 1:]\n        if segment:\n            sorted_segments.append(segment)\n    final_sorted = list()\n    for segment in sorted_segments:\n        final_sorted = merge_sorted(final_sorted, segment)\n    return final_sorted", "title": "IE/147", "entry_cls_name": "Solution", "testing_code": "assert custom_sort([0, 6, 4, 2, 5, 3, 1]) == [0, 1, 2, 3, 4, 5, 6]\nassert custom_sort([0, 6, 4, 2, 5, 3, 1, 10, 9]) == [0, 1, 2, 3, 4, 5, 6, 9, 10]\nassert custom_sort([0, 6, 4, 2, 5, 3, 1, 2, 3]) == [0, 1, 2, 2, 3, 3, 4, 5, 6]\nassert custom_sort([0, 6, 4, 2, 5, 3, 1, 11]) == [0, 1, 2, 3, 4, 5, 6, 11]", "entry_fn_name": "custom_sort"}
{"id": "148", "text": "Gray code is a binary code where each successive value differ in only one bit, as well as when wrapping around. Gray code is common in hardware so that we don't see temporary spurious values during transitions.\n\nGiven a number of bits `n`, generate a possible gray code for it.\n\nFor example, for `n = 2`, one gray code would be `[00, 01, 11, 10]`.", "solution": "def get_gray_code(n):\n    \"\"\"\n    n: bits \n    \"\"\"\n    if n == 0:\n        return ['']\n    lower_grey_codes = get_gray_code(n - 1)\n    l0 = ['0' + x for x in lower_grey_codes]\n    l1 = ['1' + x for x in reversed(lower_grey_codes)]\n    return l0 + l1", "title": "IE/148", "entry_cls_name": "Solution", "testing_code": "assert get_gray_code(1) == ['0', '1']\nassert get_gray_code(2) == ['00', '01', '11', '10']\nassert get_gray_code(3) == ['000', '001', '011', '010', '110', '111', '101', '100']\nassert get_gray_code(4) == ['0000', '0001', '0011', '0010', '0110', '0111', '0101', '0100', '1100', '1101', '1111', '1110', '1010', '1011', '1001', '1000']", "entry_fn_name": "get_gray_code"}
{"id": "151", "text": "Given a 2-D matrix representing an image, a location of a pixel in the screen and a color C, replace the color of the given pixel and all adjacent same colored pixels with C.\n\nFor example, given the following matrix, and location pixel of `(2, 2)`, and `'G'` for green:\n```\nB B W\nW W W\nW W W\nB B B\n```\n\nBecomes\n```\nB B G\nG G G\nG G G\nB B B\n```", "solution": "def get_adj_pixels(pixel, matrix, rows, cols):\n    adj_pixels = list()\n    if pixel[0] > 0:\n        adj_pixels.append((pixel[0] - 1, pixel[1]))\n        if pixel[1] > 0:\n            adj_pixels.append((pixel[0] - 1, pixel[1] - 1))\n        if pixel[1] < cols - 1:\n            adj_pixels.append((pixel[0] - 1, pixel[1] + 1))\n    if pixel[0] < rows - 1:\n        adj_pixels.append((pixel[0] + 1, pixel[1]))\n        if pixel[1] > 0:\n            adj_pixels.append((pixel[0] + 1, pixel[1] - 1))\n        if pixel[1] < cols - 1:\n            adj_pixels.append((pixel[0] + 1, pixel[1] + 1))\n    if pixel[1] > 0:\n        adj_pixels.append((pixel[0], pixel[1] - 1))\n    if pixel[1] < cols - 1:\n        adj_pixels.append((pixel[0], pixel[1] + 1))\n    return adj_pixels\ndef change_color(pixel, matrix, new_color):\n    if not matrix:\n        return matrix\n    (x, y) = (pixel[0] - 1, pixel[1] - 1)\n    rows = len(matrix)\n    cols = len(matrix[0])\n    if x < 0 or y < 0 or x >= rows or (y >= cols):\n        return matrix\n    c = matrix[x][y]\n    adj_pixels = get_adj_pixels((x, y), matrix, rows, cols)\n    for ap in adj_pixels:\n        if matrix[ap[0]][ap[1]] == c:\n            matrix[ap[0]][ap[1]] = new_color\n    matrix[x][y] = new_color\n    return matrix", "title": "IE/151", "entry_cls_name": "Solution", "testing_code": "matrix = [['B', 'B', 'W'], ['W', 'W', 'W'], ['W', 'W', 'W'], ['B', 'B', 'B']]\nassert change_color((2, 2), matrix, 'G') == [['B', 'B', 'G'], ['G', 'G', 'G'], ['G', 'G', 'G'], ['B', 'B', 'B']]", "entry_fn_name": "change_color"}
{"id": "153", "text": "Find an efficient algorithm to find the smallest distance (measured in number of words) between any two given words in a string. If it is not possible return -1.\n\nFor example, given words \"hello\", and \"world\" and a text content of \"dog cat hello cat dog dog hello cat world\", return 1 because there's only one word \"cat\" in between the two words.\n", "solution": "def get_smallest_dist(text, w1, w2):\n    dist = -1\n    (ls_word, ls_index) = (None, None)\n    for (index, word) in enumerate(text.split()):\n        if word == w1 or word == w2:\n            if word == w1 and ls_word == w2 or (word == w2 and ls_word == w1):\n                dist = index - ls_index - 1\n            ls_word = word\n            ls_index = index\n    return dist\n", "title": "IE/153", "entry_cls_name": "Solution", "testing_code": "assert get_smallest_dist('hello', 'hello', 'world') == -1\nassert get_smallest_dist('hello world', 'hello', 'world') == 0\nassert get_smallest_dist('dog cat hello cat dog dog hello cat world', 'hello', 'world') == 1\nassert get_smallest_dist('dog cat hello cat dog dog hello cat world', 'dog', 'world') == 2", "entry_fn_name": "get_smallest_dist"}
{"id": "155", "text": "Given a list of elements, find the majority element, which appears more than half the times `(> floor(len(lst) / 2.0))`.\n\nYou can assume that such an element exists.\n\nFor example, given `[1, 2, 1, 1, 3, 4, 0]`, return `1`.", "solution": "import math\ndef get_majority_element(arr):\n    threshold = math.floor(len(arr) / 2)\n    occurrences = dict()\n    for num in arr:\n        if num not in occurrences:\n            occurrences[num] = 0\n        occurrences[num] += 1\n    for num in occurrences:\n        if occurrences[num] > threshold:\n            return num", "title": "IE/155", "entry_cls_name": "Solution", "testing_code": "assert get_majority_element([]) == None\nassert get_majority_element([0]) == 0\nassert get_majority_element([0, 2, 2]) == 2\nassert get_majority_element([1, 2, 1, 1, 3, 4, 1]) == 1", "entry_fn_name": "get_majority_element"}
{"id": "156", "text": "Given a positive integer `n`, find the smallest number of squared integers which sum to `n`.\n\nFor example, given n = `13`, return `2` since `13 = 3^2 + 2^2 = 9 + 4`.\n\nGiven `n = 27`, return `3` since `27 = 3^2 + 3^2 + 3^2 = 9 + 9 + 9`.", "solution": "import math\ndef get_candidate_squares(num):\n    candidates = list()\n    for candidate_root in range(1, int(num / 2)):\n        candidate = candidate_root * candidate_root\n        if candidate > num:\n            break\n        candidates.append(candidate)\n    candidates.reverse()\n    return candidates\ndef get_min_squares_helper(num, candidates):\n    candidate_square = candidates[0]\n    max_used = int(num / candidate_square)\n    remaining = num % candidate_square\n    if remaining == 0:\n        return max_used\n    return max_used + get_min_squares_helper(remaining, candidates[1:])\ndef get_min_squares(num):\n    candidates = get_candidate_squares(num)\n    return get_min_squares_helper(num, candidates)", "title": "IE/156", "entry_cls_name": "Solution", "testing_code": "assert get_min_squares(13) == 2\nassert get_min_squares(25) == 1\nassert get_min_squares(27) == 3", "entry_fn_name": "get_min_squares"}
{"id": "157", "text": "Given a string, determine whether any permutation of it is a palindrome.\n\nFor example, `carrace` should return `true`, since it can be rearranged to form `racecar`, which is a palindrome. `daily` should return `false`, since there's no rearrangement that can form a palindrome.", "solution": "def check_palindrome_rearrangement(string):\n    chars = set()\n    for char in string:\n        if char not in chars:\n            chars.add(char)\n        else:\n            chars.remove(char)\n    return len(chars) < 2", "title": "IE/157", "entry_cls_name": "Solution", "testing_code": "assert check_palindrome_rearrangement('carrace')\nassert not check_palindrome_rearrangement('daily')\nassert not check_palindrome_rearrangement('abac')\nassert check_palindrome_rearrangement('abacc')\nassert check_palindrome_rearrangement('aabb')\nassert not check_palindrome_rearrangement('aabbcccd')", "entry_fn_name": "check_palindrome_rearrangement"}
{"id": "158", "text": "You are given an `N * M` matrix of `0`s and `1`s. Starting from the top left corner, how many ways are there to reach the bottom right corner?\n\nYou can only move right and down. `0` represents an empty space while `1` represents a wall you cannot walk through.\n\nFor example, given the following matrix:\n\n```\n[[0, 0, 1],\n [0, 0, 1],\n [1, 0, 0]]\n```\nReturn `2`, as there are only two ways to get to the bottom right:\n* `Right, down, down, right`\n* `Down, right, down, right`\n\nThe top left corner and bottom right corner will always be `0`.", "solution": "class Coord:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __repr__(self):\n        return 'Coord=(x={}, y={})'.format(self.x, self.y)\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def __hash__(self):\n        return hash((self.x, self.y))\ndef get_adjacent_cells(coord, rows, cols):\n    adj_cells = set()\n    if coord.x > 0:\n        adj_cells.add(Coord(coord.x - 1, coord.y))\n    if coord.x < rows - 1:\n        adj_cells.add(Coord(coord.x + 1, coord.y))\n    if coord.y > 0:\n        adj_cells.add(Coord(coord.x, coord.y - 1))\n    if coord.y < cols - 1:\n        adj_cells.add(Coord(coord.x, coord.y + 1))\n    return adj_cells\ndef valid_path_helper(matrix, coord, rows, cols, current_path):\n    if coord.x == rows - 1 and coord.y == cols - 1:\n        return 1\n    adj_cells = get_adjacent_cells(coord, rows, cols)\n    next_candidates = adj_cells - current_path\n    next_candidates = [nc for nc in next_candidates if matrix[nc.x][nc.y] == 0]\n    new_path = current_path.copy()\n    new_path.add(coord)\n    path_count = 0\n    for cand in next_candidates:\n        sub_path_count = valid_path_helper(matrix, cand, rows, cols, new_path)\n        path_count += sub_path_count\n    return path_count\ndef find_paths(matrix):\n    num_paths = valid_path_helper(matrix, Coord(0, 0), len(matrix), len(matrix[0]), set())\n    return num_paths", "title": "IE/158", "entry_cls_name": "Solution", "testing_code": "matrix = [[0, 0, 1], [0, 0, 1], [1, 0, 0]]\nassert find_paths(matrix) == 2\nmatrix = [[0, 0, 1], [1, 0, 1], [1, 0, 0]]\nassert find_paths(matrix) == 1\nmatrix = [[0, 0, 0], [1, 1, 0], [0, 0, 0], [0, 1, 1], [0, 0, 0]]\nassert find_paths(matrix) == 1\nmatrix = [[0, 0, 0], [1, 0, 0], [0, 0, 0], [0, 1, 1], [0, 0, 0]]\nassert find_paths(matrix) == 4", "entry_fn_name": "find_paths"}
{"id": "159", "text": "Given a string, return the first recurring character in it, or `null` if there is no recurring chracter.\n\nFor example, given the string `\"acbbac\"`, return `\"b\"`. Given the string `\"abcdef\"`, return `\"\"`.\n", "solution": "def get_first_recurring(string):\n    seen = set()\n    for char in string:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''\n", "title": "IE/159", "entry_cls_name": "Solution", "testing_code": "assert get_first_recurring('acbbac') == 'b'\nassert get_first_recurring('abcdef') == ''\nassert get_first_recurring('abcdefghijklmnopqrstuvwxyz_1234567890!@#$%^&*()-=[]|;:\"?><,.a') == 'a'", "entry_fn_name": "get_first_recurring"}
{"id": "160", "text": "Given a tree where each edge has a weight, compute the length of the longest path in the tree.\n\nFor example, given the following tree:\n\n```\n   a\n  /|\\\n b c d\n    / \\\n   e   f\n  / \\\n g   h\n```\n\nand the weights: `a-b: 3`, `a-c: 5`, `a-d: 8`, `d-e: 2`, `d-f: 4`, `e-g: 1`, `e-h: 1`, the longest path would be `c -> a -> d -> f`, with a length of `17`.\n\nThe path does not have to pass through the root, and each node can have any amount of children.", "solution": "class Node:\n\n    def __init__(self, iden):\n        self.iden = iden\n        self.max_path = 0\n        self.child_dists = list()\n\n    def __repr__(self):\n        return 'Node(id={},chi={},mp={})'.format(self.iden, self.child_dists, self.max_path)\ndef get_path_maxlen(root):\n    if not root.child_dists:\n        return 0\n    path_lens = list()\n    child_max_path_lens = list()\n    for (child, dist) in root.child_dists:\n        path_lens.append(child.max_path + dist)\n        child_max_path_lens.append(get_path_maxlen(child))\n    child_max_path_len = max(child_max_path_lens)\n    return max(sum(sorted(path_lens)[-2:]), child_max_path_len)\ndef update_max_paths(root):\n    if not root.child_dists:\n        root.max_path = 0\n        return\n    root_paths = list()\n    for (child, dist) in root.child_dists:\n        update_max_paths(child)\n        root_paths.append(child.max_path + dist)\n    root.max_path = max(root_paths)\ndef get_longest_path(root):\n    update_max_paths(root)\n    return get_path_maxlen(root)", "title": "IE/160", "entry_cls_name": "Solution", "testing_code": "a = Node('a')\nb = Node('b')\nc = Node('c')\nd = Node('d')\ne = Node('e')\nf = Node('f')\ng = Node('g')\nh = Node('h')\ne.child_dists = [(g, 1), (h, 1)]\nd.child_dists = [(e, 2), (f, 4)]\na.child_dists = [(b, 3), (c, 5), (d, 8)]\nassert get_longest_path(a) == 17", "entry_fn_name": "get_longest_path"}
{"id": "161", "text": "Given a 32-bit integer, return the number with its bits reversed.\n\nFor example, given the binary number `1111 0000 1111 0000 1111 0000 1111 0000`, return `0000 1111 0000 1111 0000 1111 0000 1111`.", "solution": "def reverse_bits(num):\n    inverted = list()\n    for char in num:\n        if char == '0':\n            inverted.append('1')\n        else:\n            inverted.append('0')\n    return ''.join(inverted)", "title": "IE/161", "entry_cls_name": "Solution", "testing_code": "assert reverse_bits('101') == '010'\nassert reverse_bits('11110000111100001111000011110000') == '00001111000011110000111100001111'", "entry_fn_name": "reverse_bits"}
{"id": "162", "text": "Given a list of words, return the shortest unique prefix of each word. For example, given the list:\n* dog\n* cat\n* apple\n* apricot\n* fish\n\nReturn the list:\n* d\n* c\n* app\n* apr\n* f", "solution": "class Trie:\n\n    def __init__(self):\n        self.size = 0\n        self.letter_map = dict()\n\n    def __repr__(self):\n        return str(self.letter_map)\n\n    def add_word(self, word):\n        if not word:\n            return\n        letter = word[0]\n        sub_trie = None\n        if letter in self.letter_map:\n            sub_trie = self.letter_map[letter]\n        else:\n            sub_trie = Trie()\n            self.letter_map[letter] = sub_trie\n        self.size += 1\n        sub_trie.add_word(word[1:])\n\n    def get_sup(self, word, prev):\n        if self.size < 2:\n            return prev\n        letter = word[0]\n        sub_trie = self.letter_map[letter]\n        return sub_trie.get_sup(word[1:], prev + letter)\ndef get_sups(words):\n    trie = Trie()\n    for word in words:\n        trie.add_word(word)\n    sups = list()\n    for word in words:\n        sups.append(trie.get_sup(word, ''))\n    return sups", "title": "IE/162", "entry_cls_name": "Solution", "testing_code": "assert get_sups(['dog', 'cat', 'apple', 'apricot', 'fish']) == ['d', 'c', 'app', 'apr', 'f']", "entry_fn_name": "get_sups"}
{"id": "163", "text": "Given an arithmetic expression in Reverse Polish Notation, write a program to evaluate it.\n\nThe expression is given as a list of numbers and operands. For example: `[\"5\", \"3\", '+']` should return `5 + 3 = 8`.\n\nFor example, `[\"2\",\"1\",\"+\",\"3\",\"*\"]` should return `9`, since it is equivalent to `((2 + 1) * 3) = 9`.\n\nYou can assume the given expression is always valid and division of integers should be truncated towards 0.\n", "solution": "def evaluate_expression(tokens):\n    stack = []\n    for t in tokens:\n        if t not in \"+-*/\":\n            stack.append(int(t))\n        else:\n            r, l = stack.pop(), stack.pop()\n            if t == \"+\":\n                stack.append(l+r)\n            elif t == \"-\":\n                stack.append(l-r)\n            elif t == \"*\":\n                stack.append(l*r)\n            else:\n                stack.append(int(float(l)/r))\n    return stack.pop()\n", "title": "IE/163", "entry_cls_name": "Solution", "testing_code": "assert evaluate_expression([\"5\", \"3\", \"+\"]) == 8\nassert evaluate_expression([\"2\",\"1\",\"+\",\"3\",\"*\"]) == 9\nassert evaluate_expression([\"4\",\"13\",\"5\",\"/\",\"+\"]) == 6\nassert evaluate_expression([\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]) == 22\nassert evaluate_expression(['15', '7', '1', '1', '+', '-', '/', '3', '*', '2', '1', '1', '+', '+', '-']) == 5\n", "entry_fn_name": "evaluate_expression"}
{"id": "164", "text": "You are given an array of length n + 1 whose elements belong to the set `{1, 2, ..., n}`. By the pigeonhole principle, there must be a duplicate. Find it in linear time and space.", "solution": "def find_duplicate(arr, n):\n    expected_sum = int(n * (n + 1) / 2)\n    actual_sum = sum(arr)\n    return actual_sum - expected_sum", "title": "IE/164", "entry_cls_name": "Solution", "testing_code": "assert find_duplicate([1, 1, 2], 2) == 1\nassert find_duplicate([1, 2, 3, 3], 3) == 3\nassert find_duplicate([1, 2, 3, 4, 3], 4) == 3", "entry_fn_name": "find_duplicate"}
{"id": "165", "text": "Given an array of integers, return a new array where each element in the new array is the number of smaller elements to the right of that element in the original input array.\n\nFor example, given the array `[3, 4, 9, 6, 1]`, return `[1, 1, 2, 1, 0]`, since:\n* There is 1 smaller element to the right of `3`\n* There is 1 smaller element to the right of `4`\n* There are 2 smaller elements to the right of `9`\n* There is 1 smaller element to the right of `6`\n* There are no smaller elements to the right of `1`", "solution": "def get_smaller_right(arr):\n    smaller_right_arr = list()\n    for i in range(len(arr)):\n        smaller_count = 0\n        for j in range(i + 1, len(arr)):\n            if arr[j] < arr[i]:\n                smaller_count += 1\n        smaller_right_arr.append(smaller_count)\n    return smaller_right_arr", "title": "IE/165", "entry_cls_name": "Solution", "testing_code": "assert get_smaller_right([3, 4, 9, 6, 1]) == [1, 1, 2, 1, 0]", "entry_fn_name": "get_smaller_right"}
{"id": "167", "text": "Given a list of words, find all pairs of unique indices such that the concatenation of the two words is a palindrome.\n\nFor example, given the list `[\"code\", \"edoc\", \"da\", \"d\"]`, return `[[0, 1], [1, 0], [2, 3]]`.", "solution": "def is_palindrome(word):\n    return word == word[::-1]\ndef get_unique_index_pairs(words):\n    index_tuples = list()\n    for (i, word_i) in enumerate(words):\n        for (j, word_j) in enumerate(words):\n            if i != j:\n                composite = word_i + word_j\n                if is_palindrome(composite):\n                    index_tuples.append([i, j])\n    return index_tuples", "title": "IE/167", "entry_cls_name": "Solution", "testing_code": "assert get_unique_index_pairs(['code', 'edoc', 'da', 'd']) == [[0, 1], [1, 0], [2, 3]]\nassert get_unique_index_pairs([\"geekf\", \"geeks\", \"or\", \"keeg\", \"abc\", \"bc\"]) == [[0, 3], [1, 3]]\nassert get_unique_index_pairs([\"geekf\"]) == []", "entry_fn_name": "get_unique_index_pairs"}
{"id": "170", "text": "Given a start word, an end word, and a dictionary of valid words, find the shortest transformation sequence from start to end such that only one letter is changed at each step of the sequence, and each transformed word exists in the dictionary. If there is no possible transformation, return null. Each word in the dictionary have the same length as start and end and is lowercase.\n\nFor example, given `start = \"dog\"`, `end = \"cat\"`, and `dictionary = {\"dot\", \"dop\", \"dat\", \"cat\"}`, return `[\"dog\", \"dot\", \"dat\", \"cat\"]`.\n\nGiven `start = \"dog\"`, `end = \"cat\"`, and `dictionary = {\"dot\", \"tod\", \"dat\", \"dar\"}`, return null as there is no possible transformation from dog to cat.", "solution": "import sys\nchars = set('abcdefghijklmnopqrstuvwxyz')\ndef transition_helper(start, end, dictionary, changes, seen):\n    if start == end:\n        return changes\n    candidates = list()\n    for (index, _) in enumerate(start):\n        for char in chars:\n            candidate = start[:index] + char + start[index + 1:]\n            if candidate in dictionary and candidate not in seen:\n                candidates.append(candidate)\n    min_results = list()\n    min_len = sys.maxsize\n    for candidate in candidates:\n        new_seen = seen.copy()\n        new_seen.add(candidate)\n        result_changes = transition_helper(candidate, end, dictionary, changes + [candidate], new_seen)\n        if result_changes and len(result_changes) < min_len:\n            min_len = len(result_changes)\n            min_results = result_changes\n    return min_results\ndef get_transition(start, end, dictionary):\n    result = transition_helper(start, end, dictionary, [start], {start})\n    return result", "title": "IE/170", "entry_cls_name": "Solution", "testing_code": "assert get_transition('dog', 'cat', {'dot', 'dop', 'dat', 'cat'}) == ['dog', 'dot', 'dat', 'cat']\nassert not get_transition('dog', 'cat', {'dot', 'tod', 'dat', 'dar'})", "entry_fn_name": "get_transition"}
{"id": "171", "text": "You are given a list of data entries that represent entries and exits of groups of people into a building. An entry looks like this:\n\n`{\"timestamp\": 1526579928, \"count\": 3, \"type\": \"enter\"}`\n\nThis means 3 people entered the building. An exit looks like this:\n\n`{\"timestamp\": 1526580382, \"count\": 2, \"type\": \"exit\"}`\n\nThis means that 2 people exited the building. timestamp is in Unix time.\n\nFind the busiest period in the building, that is, the time with the most people in the building. Return it as a pair of `(start, end)` timestamps. You can assume the building always starts off and ends up empty, i.e. with 0 people inside.", "solution": "import sys\nENTER = 'enter'\nEXIT = 'exit'\ndef get_busiest_slot(events):\n    (ts_entries, ts_exits) = (dict(), dict())\n    (max_time, min_time) = (-sys.maxsize, sys.maxsize)\n    for event in events:\n        ts_dict = None\n        timestamp = event['timestamp']\n        if event['type'] == ENTER:\n            ts_dict = ts_entries\n        else:\n            ts_dict = ts_exits\n        ts_dict[timestamp] = event['count']\n        if timestamp < min_time:\n            min_time = timestamp\n        elif timestamp > max_time:\n            max_time = timestamp\n    people_inside = 0\n    max_people_inside = 0\n    (start_time, end_time) = (None, None)\n    for timestamp in range(min_time, max_time + 1):\n        if timestamp in ts_entries:\n            people_inside += ts_entries[timestamp]\n            if people_inside > max_people_inside:\n                max_people_inside = people_inside\n                start_time = timestamp\n        if timestamp in ts_exits:\n            if people_inside == max_people_inside:\n                end_time = timestamp\n            people_inside -= ts_exits[timestamp]\n    return (start_time, end_time)", "title": "IE/171", "entry_cls_name": "Solution", "testing_code": "events = [{'timestamp': 1526579928, 'count': 3, 'type': 'enter'}, {'timestamp': 1526579982, 'count': 4, 'type': 'enter'}, {'timestamp': 1526580054, 'count': 5, 'type': 'exit'}, {'timestamp': 1526580128, 'count': 1, 'type': 'enter'}, {'timestamp': 1526580382, 'count': 3, 'type': 'exit'}]\nassert get_busiest_slot(events) == (1526579982, 1526580054)", "entry_fn_name": "get_busiest_slot"}
{"id": "172", "text": "Given a string `s` and a list of words `words`, where each word is the same length, find all starting indices of substrings in `s` that is a concatenation of every word in `words` exactly once.\n\nFor example, given `s = \"dogcatcatcodecatdog\"` and `words = [\"cat\", \"dog\"]`, return `[0, 13]`, since `\"dogcat\"` starts at index `0` and `\"catdog\"` starts at index `13`.\n\nGiven `s = \"barfoobazbitbyte\"` and `words = [\"dog\", \"cat\"]`, return `[]` since there are no substrings composed of `\"dog\"` and `\"cat\"` in `s`.\n\nThe order of the indices does not matter.", "solution": "from itertools import permutations\ndef get_indices(s, words):\n    perms = list(permutations(words))\n    perms = [x + y for (x, y) in perms]\n    indices = [s.find(x) for x in perms]\n    indices = [x for x in indices if x >= 0]\n    return sorted(indices)", "title": "IE/172", "entry_cls_name": "Solution", "testing_code": "assert get_indices('dogcatcatcodecatdog', ['cat', 'dog']) == [0, 13]\nassert not get_indices('barfoobazbitbyte', ['cat', 'dog'])", "entry_fn_name": "get_indices"}
{"id": "173", "text": "Write a function to flatten a nested dictionary. Namespace the keys with a period.\n\nFor example, given the following dictionary:\n\n```\n{\n    \"key\": 3,\n    \"foo\": {\n        \"a\": 5,\n        \"bar\": {\n            \"baz\": 8\n        }\n    }\n}\n```\n\nit should become:\n\n```\n{\n    \"key\": 3,\n    \"foo.a\": 5,\n    \"foo.bar.baz\": 8\n}\n```\n\nYou can assume keys do not contain dots in them, i.e. no clobbering will occur.", "solution": "def is_dict(var):\n    return str(type(var)) == \"<class 'dict'>\"\ndef flatten_helper(d, flat_d, path):\n    if not is_dict(d):\n        flat_d[path] = d\n        return\n    for key in d:\n        new_keypath = '{}.{}'.format(path, key) if path else key\n        flatten_helper(d[key], flat_d, new_keypath)\ndef flatten(d):\n    flat_d = dict()\n    flatten_helper(d, flat_d, '')\n    return flat_d", "title": "IE/173", "entry_cls_name": "Solution", "testing_code": "d = {'key': 3, 'foo': {'a': 5, 'bar': {'baz': 8}}}\nassert flatten(d) == {'key': 3, 'foo.a': 5, 'foo.bar.baz': 8}", "entry_fn_name": "flatten"}
{"id": "176", "text": "Determine whether there exists a one-to-one character mapping from one string `s1` to another `s2`.\n\nFor example, given `s1 = abc` and `s2 = bcd`, return `true` since we can map `a` to `b`, `b` to `c`, and `c` to `d`.\n\nGiven `s1 = foo` and `s2 = bar`, return `false` since the `o` cannot map to two characters.", "solution": "def is_char_mapped(str_a, str_b):\n    if len(str_a) != len(str_b):\n        return False\n    char_map = dict()\n    for (char_a, char_b) in zip(str_a, str_b):\n        if char_a not in char_map:\n            char_map[char_a] = char_b\n        elif char_map[char_a] != char_b:\n            return False\n    return True", "title": "IE/176", "entry_cls_name": "Solution", "testing_code": "assert is_char_mapped('abc', 'bcd')\nassert not is_char_mapped('foo', 'bar')", "entry_fn_name": "is_char_mapped"}
{"id": "181", "text": "Given a string, split it into as few strings as possible such that each string is a palindrome.\n\nFor example, given the input string `\"racecarannakayak\"`, return `[\"racecar\", \"anna\", \"kayak\"]`.\n\nGiven the input string `\"abc\"`, return `[\"a\", \"b\", \"c\"]`.", "solution": "def is_palindrome(string):\n    return bool(string) and string == string[::-1]\ndef split_into_pals(string):\n    def _split_into_pals(string, curr, prev_pals):\n        if not string and (not curr):\n            return prev_pals\n        elif not string:\n            return prev_pals + list(curr)\n        candidate = curr + string[0]\n        alt_1 = []\n        if is_palindrome(candidate):\n            alt_1 = _split_into_pals(string[1:], '', prev_pals + [candidate])\n        alt_2 = _split_into_pals(string[1:], candidate, prev_pals)\n        return alt_1 if bool(alt_1) and len(alt_1) < len(alt_2) else alt_2\n    return _split_into_pals(string, '', [])\n", "title": "IE/181", "entry_cls_name": "Solution", "testing_code": "assert split_into_pals('racecarannakayak') == ['racecar', 'anna', 'kayak']\nassert split_into_pals('abc') == ['a', 'b', 'c']\nassert split_into_pals('madam') == ['madam']\nassert split_into_pals('madama') == ['madam', 'a']", "entry_fn_name": "split_into_pals"}
{"id": "182", "text": "A graph is minimally-connected if it is connected and there is no edge that can be removed while still leaving the graph connected. For example, any binary tree is minimally-connected.\n\nGiven an undirected graph, check if the graph is minimally-connected. You can choose to represent the graph as either an adjacency matrix or adjacency list.", "solution": "class Node:\n\n    def __init__(self, id_str):\n        self.id = id_str\n\n    def __repr__(self):\n        return str(self.id)\n\n    def __hash__(self):\n        return hash(self.id)\n\n    def __eq__(self, other):\n        return self.id == other.id\nclass Graph:\n\n    def __init__(self):\n        self.nodes = set()\n        self.adj_lists = dict()\n\n    def add_edge(self, node_a, node_b):\n        for node in [node_a, node_b]:\n            if node not in self.nodes:\n                self.nodes.add(node)\n                self.adj_lists[node] = set()\n        self.adj_lists[node_a].add(node_b)\n        self.adj_lists[node_b].add(node_a)\ndef are_connected(g, source, target, seen=set()):\n    if source == target:\n        return True\n    seen_cp = seen.copy()\n    seen_cp.add(source)\n    return any((are_connected(g, x, target, seen_cp) for x in g.adj_lists[source] if x not in seen))\ndef is_min_graph(g):\n    if all((len(x) == 1 for x in g.adj_lists.values())):\n        return True\n    for node in g.nodes:\n        cp_g = deepcopy(g)\n        assert node in cp_g.nodes\n        adj_nodes = list(cp_g.adj_lists[node])\n        cp_g.adj_lists.pop(node)\n        for an in adj_nodes:\n            cp_g.adj_lists[an].remove(node)\n        for i in range(len(adj_nodes)):\n            for j in range(i + 1, len(adj_nodes)):\n                if are_connected(cp_g, adj_nodes[i], adj_nodes[j]):\n                    return False\n    return True", "title": "IE/182", "entry_cls_name": "Solution", "testing_code": "from copy import deepcopy\na = Node('a')\nb = Node('b')\nc = Node('c')\nd = Node('d')\ng = Graph()\ng.add_edge(a, b)\nassert is_min_graph(g)\ng.add_edge(b, c)\nassert is_min_graph(g)\ng.add_edge(a, c)\nassert not is_min_graph(g)\ng.add_edge(a, d)\nassert not is_min_graph(g)", "entry_fn_name": "is_min_graph"}
{"id": "184", "text": "Given n numbers, find the greatest common denominator between them.\n\nFor example, given the numbers `[42, 56, 14]`, return `14`.", "solution": "SMALLEST_PRIME = 2\ndef is_prime(cand, primes):\n    for prime in primes:\n        res = cand / prime\n        if not res % 1:\n            return False\n    return True\ndef get_possible_primes(num):\n    primes = [SMALLEST_PRIME]\n    for cand in range(SMALLEST_PRIME + 1, num // 2 + 1):\n        if is_prime(cand, primes):\n            primes.append(cand)\n    return primes\ndef get_factors(num, primes):\n    factors = dict()\n    pi = 0\n    while num > 1:\n        if pi >= len(primes):\n            break\n        if not num % primes[pi]:\n            if primes[pi] not in factors:\n                factors[primes[pi]] = 0\n            factors[primes[pi]] += 1\n            num /= primes[pi]\n        else:\n            pi += 1\n    return factors\ndef get_gcd(nums):\n    min_num = min(nums)\n    primes = get_possible_primes(min_num)\n    base_factors = get_factors(min_num, primes)\n    factorized_nums = dict()\n    for num in nums:\n        factorized_nums[num] = get_factors(num, primes)\n    common_factors = dict()\n    for base_factor in base_factors:\n        common_factors[base_factor] = 0\n        num_factors = list()\n        for num in nums:\n            factors = factorized_nums[num]\n            num_factors.append(factors[base_factor])\n        common_factors[base_factor] = min(num_factors)\n    gcd = 1\n    for factor in common_factors:\n        gcd *= factor ** common_factors[factor]\n    return gcd", "title": "IE/184", "entry_cls_name": "Solution", "testing_code": "assert get_gcd([42, 56, 14]) == 14\nassert get_gcd([3, 5]) == 1\nassert get_gcd([9, 15]) == 3", "entry_fn_name": "get_gcd"}
{"id": "185", "text": "Given two rectangles on a 2D graph, return the area of their intersection. If the rectangles don't intersect, return `0`.\n\nFor example, given the following rectangles:\n```\n{\n    \"top_left\": (1, 4),\n    \"dimensions\": (3, 3) # width, height\n}\n```\nand\n```\n{\n    \"top_left\": (0, 5),\n    \"dimensions\" (4, 3) # width, height\n}\n```\nreturn `6`.", "solution": "class Point:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __repr__(self):\n        return '(x={},y={})'.format(self.x, self.y)\nclass Rectangle:\n\n    def __init__(self, json):\n        self.tl = Point(json['top_left'][0], json['top_left'][1])\n        (width, height) = json['dimensions']\n        self.br = Point(self.tl.x + width, self.tl.y - height)\n\n    def __repr__(self):\n        return '(tl={},br={})'.format(self.tl, self.br)\n\n    def get_area(self):\n        return (self.br.x - self.tl.x) * (self.tl.y - self.br.y)\n\n    def envelopes(self, other):\n        return self.tl.x < other.tl.x and self.tl.y > other.tl.y and (self.br.x > other.br.x) and (self.br.y < other.br.y)\n\n    def is_disjoint_with(self, other):\n        return self.br.y > other.tl.y or other.br.y > self.tl.y or self.tl.x > other.br.x or (other.tl.x > self.br.x)\ndef calculate_intersect_area(r1, r2):\n    if r1.envelopes(r2):\n        area = r2.get_area()\n    elif r2.envelopes(r1):\n        area = r1.get_area()\n    elif r1.is_disjoint_with(r2) or r2.is_disjoint_with(r1):\n        area = 0\n    else:\n        heights = list(sorted([r1.tl.y, r1.br.y, r2.tl.y, r2.br.y]))[1:-1]\n        height = heights[1] - heights[0]\n        widths = list(sorted([r1.tl.x, r1.br.x, r2.tl.x, r2.br.x]))[1:-1]\n        width = widths[1] - widths[0]\n        area = height * width\n    return area", "title": "IE/185", "entry_cls_name": "Solution", "testing_code": "r1 = Rectangle({'top_left': (1, 4), 'dimensions': (3, 3)})\nr2 = Rectangle({'top_left': (0, 5), 'dimensions': (4, 3)})\nassert calculate_intersect_area(r1, r2) == 6\nr1 = Rectangle({'top_left': (1, 1), 'dimensions': (1, 1)})\nr2 = Rectangle({'top_left': (5, 5), 'dimensions': (1, 1)})\nassert calculate_intersect_area(r1, r2) == 0\nr1 = Rectangle({'top_left': (0, 5), 'dimensions': (5, 5)})\nr2 = Rectangle({'top_left': (1, 4), 'dimensions': (2, 2)})\nassert calculate_intersect_area(r1, r2) == 4\nr1 = Rectangle({'top_left': (0, 5), 'dimensions': (5, 5)})\nr2 = Rectangle({'top_left': (4, 4), 'dimensions': (3, 3)})\nassert calculate_intersect_area(r1, r2) == 3", "entry_fn_name": "calculate_intersect_area"}
{"id": "186", "text": "Given an array of positive integers, divide the array into two subsets such that the difference between the sum of the subsets is as small as possible.\n\nFor example, given `[5, 10, 15, 20, 25]`, return the sets `{10, 25}` and `{5, 15, 20}`, which has a difference of `5`, which is the smallest possible difference.", "solution": "def get_diff(s1, s1_sum, s2, s2_sum, score):\n    (min_diff, min_cand) = (score, None)\n    for (i, num) in enumerate(s1):\n        (new_s1_sum, new_s2_sum) = (s1_sum - num, s2_sum + num)\n        new_score = abs(new_s1_sum - new_s2_sum)\n        if new_score < min_diff:\n            min_diff = new_score\n            min_cand = (s1[:i] + s1[i + 1:], new_s1_sum, s2 + [num], new_s2_sum)\n    if not min_cand:\n        return (set(s1), set(s2))\n    return get_diff(min_cand[0], min_cand[1], min_cand[2], min_cand[3], min_diff)\ndef divide_numbers(nums):\n    sum_nums = sum(nums)\n    best_sets = get_diff(nums.copy(), sum_nums, [], 0, sum_nums)\n    return list(best_sets)", "title": "IE/186", "entry_cls_name": "Solution", "testing_code": "assert divide_numbers([5, 10, 15, 20, 25]) == [{5, 15, 20}, {10, 25}]\nassert divide_numbers([5, 10, 15, 20]) == [{10, 15}, {20, 5}]\nassert divide_numbers([56,12,30]) == [{12, 30}, {56}]", "entry_fn_name": "divide_numbers"}
{"id": "187", "text": "You are given given a list of rectangles represented by min and max x- and y-coordinates. Compute whether or not a pair of rectangles overlap each other. If one rectangle completely covers another, it is considered overlapping.\n\nFor example, given the following rectangles:\n```\n{\n    \"top_left\": (1, 4),\n    \"dimensions\": (3, 3) # width, height\n},\n{\n    \"top_left\": (-1, 3),\n    \"dimensions\": (2, 1)\n},\n{\n    \"top_left\": (0, 5),\n    \"dimensions\": (4, 3)\n}\n```\n\nreturn `true` as the first and third rectangle overlap each other.", "solution": "class Point:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __repr__(self):\n        return '(x={},y={})'.format(self.x, self.y)\nclass Rectangle:\n\n    def __init__(self, json):\n        self.tl = Point(json['top_left'][0], json['top_left'][1])\n        (width, height) = json['dimensions']\n        self.br = Point(self.tl.x + width, self.tl.y - height)\n\n    def __repr__(self):\n        return '(tl={},br={})'.format(self.tl, self.br)\n\n    def envelopes(self, other):\n        return self.tl.x <= other.tl.x and self.tl.y >= other.tl.y and (self.br.x >= other.br.x) and (self.br.y <= other.br.y)\ndef contains_overlapping_pair(rectangles):\n    for i in range(len(rectangles) - 1):\n        for j in range(i + 1, len(rectangles)):\n            if rectangles[i].envelopes(rectangles[j]) or rectangles[j].envelopes(rectangles[i]):\n                return True\n    return False", "title": "IE/187", "entry_cls_name": "Solution", "testing_code": "r1 = Rectangle({'top_left': (1, 4), 'dimensions': (3, 3)})\nr2 = Rectangle({'top_left': (-1, 3), 'dimensions': (2, 1)})\nr3 = Rectangle({'top_left': (0, 5), 'dimensions': (4, 4)})\nassert contains_overlapping_pair([r1, r2, r3])\nr1 = Rectangle({'top_left': (1, 4), 'dimensions': (3, 3)})\nr2 = Rectangle({'top_left': (-1, 3), 'dimensions': (2, 1)})\nr3 = Rectangle({'top_left': (0, 5), 'dimensions': (4, 3)})\nassert not contains_overlapping_pair([r1, r2, r3])", "entry_fn_name": "contains_overlapping_pair"}
{"id": "189", "text": "Given an array of elements, return the length of the longest subarray where all its elements are distinct.\n\nFor example, given the array `[5, 1, 3, 5, 2, 3, 4, 1]`, return `5` as the longest subarray of distinct elements is `[5, 2, 3, 4, 1]`.", "solution": "def get_longest_uqsub(arr):\n    def _get_longest_uqsub(arr, seen):\n        if not arr:\n            return len(seen)\n        curr = arr[0]\n        if curr in seen:\n            return len(seen)\n        seen_cp = seen.copy()\n        seen_cp.add(curr)\n        return max(_get_longest_uqsub(arr[1:], seen_cp), _get_longest_uqsub(arr[1:],set()))\n    return _get_longest_uqsub(arr, set())\n", "title": "IE/189", "entry_cls_name": "Solution", "testing_code": "assert get_longest_uqsub([]) == 0\nassert get_longest_uqsub([5, 5, 5]) == 1\nassert get_longest_uqsub([5, 1, 3, 5, 2, 3, 4, 1]) == 5\nassert get_longest_uqsub([5, 1, 3, 5, 2, 3, 4]) == 4\nassert get_longest_uqsub([5, 1, 3, 5, 2, 3]) == 4", "entry_fn_name": "get_longest_uqsub"}
{"id": "190", "text": "Given a circular array, compute its maximum subarray sum in `O(n)` time.\n\nFor example, given `[8, -1, 3, 4]`, return `15` as we choose the numbers `3`, `4`, and `8` where the `8` is obtained from wrapping around.\n\nGiven `[-4, 5, 1, 0]`, return `6` as we choose the numbers `5` and `1`.", "solution": "def get_max_circ_sarray(arr):\n    warr = arr * 2\n    items = []\n    csum = msum = 0\n    for num in warr:\n        while len(items) >= len(arr) or (items and items[0] < 1):\n            csum -= items[0]\n            items = items[1:]\n        items.append(num)\n        csum += num\n        msum = max(msum, csum)\n    return msum", "title": "IE/190", "entry_cls_name": "Solution", "testing_code": "assert get_max_circ_sarray([8, -1, 3, 4]) == 15\nassert get_max_circ_sarray([-4, 5, 1, 0]) == 6", "entry_fn_name": "get_max_circ_sarray"}
{"id": "191", "text": "Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\n\nIntervals can \"touch\", such as `[0, 1]` and `[1, 2]`, but they won't be considered overlapping.\n\nFor example, given the intervals `(7, 9), (2, 4), (5, 8)`, return `1` as the last interval can be removed and the first two won't overlap.\n\nThe intervals are not necessarily sorted in any order.", "solution": "def get_min_removals(intervals):\n    def _get_min_removals(intervals, reserved_intervals, removed):\n        if not intervals:\n            return removed\n\n        curr_interval = intervals[0]\n        if_removed = _get_min_removals(\n            intervals[1:], reserved_intervals, removed + 1)\n\n        for ri in reserved_intervals:\n            if curr_interval[0] in ri or curr_interval[1] in ri:\n                return if_removed\n\n        new_reserved_intervals = reserved_intervals +             [range(curr_interval[0], curr_interval[1])]\n\n        return min(if_removed, _get_min_removals(intervals[1:], new_reserved_intervals, removed))\n    return _get_min_removals(intervals, reserved_intervals=list(), removed=0)\n", "title": "IE/191", "entry_cls_name": "Solution", "testing_code": "assert get_min_removals([(0, 1), (1, 2)]) == 0\nassert get_min_removals([(7, 9), (2, 4), (5, 8)]) == 1\nassert get_min_removals([(7, 9), (2, 4), (5, 8), (1, 3)]) == 2", "entry_fn_name": "get_min_removals"}
{"id": "192", "text": "You are given an array of nonnegative integers. Let's say you start at the beginning of the array and are trying to advance to the end. You can advance at most, the number of steps that you're currently on. Determine whether you can get to the end of the array.\n\nFor example, given the array `[1, 3, 1, 2, 0, 1]`, we can go from indices `0 -> 1 -> 3 -> 5`, so return `true`.\n\nGiven the array `[1, 2, 1, 0, 0]`, we can't reach the end, so return `false`.", "solution": "def end_reachable(arr):\n    if len(arr) < 2:\n        return True\n    for i in range(2, len(arr) + 1):\n        if arr[len(arr) - i] >= i - 1:\n            return end_reachable(arr[:len(arr) - i + 1])\n    return False", "title": "IE/192", "entry_cls_name": "Solution", "testing_code": "assert end_reachable([1, 3, 1, 2, 0, 1])\nassert not end_reachable([1, 2, 1, 0, 0])\nassert not end_reachable([3, 2, 1, 0, 4])\nassert end_reachable([2, 3, 1, 1, 4])", "entry_fn_name": "end_reachable"}
{"id": "193", "text": "Given a array of numbers representing the stock prices of a company in chronological order, write a function that calculates the maximum profit you could have made from buying and selling that stock. You're also given a number fee that represents a transaction fee for each buy and sell transaction.\n\nYou must buy before you can sell the stock, but you can make as many transactions as you like.\n\nFor example, given `[1, 3, 2, 8, 4, 10]` and `fee = 2`, you should return `9`, since you could buy the stock at `$1`, and sell at `$8`, and then buy it at `$4` and sell it at `$10`. Since we did two transactions, there is a `$4` fee, so we have `7 + 6 = 13` profit minus `$4` of fees.", "solution": "def get_max_profit(prices, fee):\n    def _get_max_profit(prices, fee, reserve=0, buyable=True):\n        if not prices:\n            return reserve\n        price_offset = -prices[0] - fee if buyable else prices[0]\n        return max(_get_max_profit(prices[1:], fee, reserve, buyable), _get_max_profit(prices[1:], fee, reserve + price_offset, not buyable))\n    return _get_max_profit(prices, fee)\n", "title": "IE/193", "entry_cls_name": "Solution", "testing_code": "assert get_max_profit([1, 3, 2, 8, 4, 10], 2) == 9\nassert get_max_profit([1, 3, 2, 1, 4, 10], 2) == 7", "entry_fn_name": "get_max_profit"}
{"id": "194", "text": "Suppose you are given two lists of n points, one list `p1, p2, ..., pn` on the line `y = 0` and the other list `q1, q2, ..., qn` on the line `y = 1`. Imagine a set of `n` line segments connecting each point `pi` to `qi`. Write an algorithm to determine how many pairs of the line segments intersect.", "solution": "def get_intersections(parr, qarr):\n    segments = list(zip(parr, qarr))\n    count = 0\n    for i in range(len(segments)):\n        for k in range(i):\n            (p1, p2) = (segments[i], segments[k])\n            if p1[0] < p2[0] and p1[1] > p2[1] or (p1[0] > p2[0] and p1[1] < p2[1]):\n                count += 1\n    return count", "title": "IE/194", "entry_cls_name": "Solution", "testing_code": "assert get_intersections([1, 4, 5], [4, 2, 3]) == 2\nassert get_intersections([1, 4, 5], [2, 3, 4]) == 0", "entry_fn_name": "get_intersections"}
{"id": "195", "text": "Let `M` be an `N` by `N` matrix in which every row and every column is sorted. No two elements of `M` are equal.\n\nGiven `i1`, `j1`, `i2`, and `j2`, compute the number of elements of `M` smaller than `M[i1, j1]` and larger than `M[i2, j2]`.", "solution": "def get_num_betn(matrix, i1, j1, i2, j2):\n    (num_1, num_2) = (matrix[i1][j1], matrix[i2][j2])\n    (sm, lg) = (num_1, num_2) if num_1 < num_2 else (num_2, num_1)\n    count = 0\n    for row in matrix:\n        count += len([x for x in row if x > sm and x < lg])\n    return count", "title": "IE/195", "entry_cls_name": "Solution", "testing_code": "matrix = [[1, 2, 3, 4], [5, 8, 9, 13], [6, 10, 12, 14], [7, 11, 15, 16]]\nassert get_num_betn(matrix, 1, 3, 3, 1) == 1\nmatrix = [[1, 2, 3, 4], [5, 6, 7, 8], [10, 11, 12, 13], [20, 21, 22, 23]]\nassert get_num_betn(matrix, 1, 0, 3, 3) == 10", "entry_fn_name": "get_num_betn"}
{"id": "196", "text": "Given the root of a binary tree, find the most frequent subtree sum. The subtree sum of a node is the sum of all values under a node, including the node itself.\n\nFor example, given the following tree:\n\n```\n  5\n / \\\n2  -5\n```\n\nReturn `2` as it occurs twice: once as the left leaf, and once as the sum of `2 + 5 - 5.`", "solution": "class Node:\n\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\ndef get_freq_tree_sum(root, counts):\n    if not root:\n        return 0\n    tree_sum = root.val + get_freq_tree_sum(root.left, counts) + get_freq_tree_sum(root.right, counts)\n    if not tree_sum in counts:\n        counts[tree_sum] = 0\n    counts[tree_sum] += 1\n    return tree_sum\ndef get_freq_tree_sum_helper(root):\n    counts = dict()\n    get_freq_tree_sum(root, counts)\n    return max(counts.items(), key=lambda x: x[1])[0]", "title": "IE/196", "entry_cls_name": "Solution", "testing_code": "root = Node(5)\nroot.left = Node(2)\nroot.right = Node(-5)\nassert get_freq_tree_sum_helper(root) == 2", "entry_fn_name": "get_freq_tree_sum_helper"}
{"id": "198", "text": "Given a set of distinct positive integers, find the largest subset such that every pair of elements in the subset `(i, j)` satisfies either `i % j = 0` or `j % i = 0`.\n\nFor example, given the set `[3, 5, 10, 20, 21]`, you should return `[5, 10, 20]`. Given `[1, 3, 6, 24]`, return `[1, 3, 6, 24]`.", "solution": "def get_largest_subset(arr, prev_num=1, curr_ind=0, prev_subset=[]):\n    if curr_ind == len(arr):\n        return prev_subset\n    curr_num = arr[curr_ind]\n    alt_0 = get_largest_subset(arr, prev_num, curr_ind + 1, prev_subset)\n    if curr_num % prev_num == 0:\n        alt_1 = get_largest_subset(arr, curr_num, curr_ind + 1, prev_subset + [curr_num])\n        return alt_1 if len(alt_1) > len(alt_0) else alt_0\n    return alt_0\ndef get_largest_subset_helper(arr):\n    arr.sort()\n    return get_largest_subset(arr)", "title": "IE/198", "entry_cls_name": "Solution", "testing_code": "assert get_largest_subset([]) == []\nassert get_largest_subset([2]) == [2]\nassert get_largest_subset([2, 3]) == [3]\nassert get_largest_subset([3, 5, 10, 20, 21]) == [5, 10, 20]\nassert get_largest_subset([1, 3, 6, 24]) == [1, 3, 6, 24]\nassert get_largest_subset([3, 9, 15, 30]) == [3, 15, 30]", "entry_fn_name": "get_largest_subset"}
{"id": "199", "text": "Given a string of parentheses, find the balanced string that can be produced from it using the minimum number of insertions and deletions. If there are multiple solutions, return any of them.\n\nFor example, given `\"(()\"`, you could return `\"(())\"`. Given `\"))()(\"`, you could return `\"()()()()\"`.", "solution": "def correct_braces(braces):\n    i = 0\n    while i < len(braces) and braces[i] == ')':\n        i += 1\n    braces = braces[i:]\n    if not braces:\n        return ''\n    open_braces = 0\n    for (i, brace) in enumerate(braces):\n        if brace == '(':\n            open_braces += 1\n        elif brace == ')':\n            open_braces -= 1\n        if not open_braces:\n            break\n    return braces[open_braces:] if open_braces else braces[:i + 1] + correct_braces(braces[i + 1:])", "title": "IE/199", "entry_cls_name": "Solution", "testing_code": "assert correct_braces('()(()') == '()()'\nassert correct_braces('()(()))') == '()(())'\nassert correct_braces(')(())') == '(())'\nassert correct_braces('())(') == '()'", "entry_fn_name": "correct_braces"}
{"id": "200", "text": "Let `X` be a set of `n` intervals on the real line. We say that a set of points `P` \"stabs\" `X` if every interval in `X` contains at least one point in `P`. Compute the smallest set of points that stabs `X`.\n\nFor example, given the intervals `[[1, 4], [4, 5], [7, 9], [9, 12]]`, you should return `[4, 9]`.", "solution": "def get_stab_points(intervals):\n    (starts, ends) = zip(*intervals)\n    return [min(ends), max(starts)]", "title": "IE/200", "entry_cls_name": "Solution", "testing_code": "assert get_stab_points([[1, 4], [4, 5], [7, 9], [9, 12]]) == [4, 9]\nassert get_stab_points([[1, 4], [-2, 6], [4, 5], [7, 9], [9, 12]]) == [4, 9]\nassert get_stab_points([[1, 4], [-2, 0], [4, 5], [7, 9]]) == [0, 7]", "entry_fn_name": "get_stab_points"}
{"id": "201", "text": "You are given an array of arrays of integers, where each array corresponds to a row in a triangle of numbers. For example, `[[1], [2, 3], [1, 5, 1]]` represents the triangle:\n\n```\n  1\n 2 3\n1 5 1\n```\n\nWe define a path in the triangle to start at the top and go down one row at a time to an adjacent value, eventually ending with an entry on the bottom row. For example, `1 -> 3 -> 5`. The weight of the path is the sum of the entries.\n\nWrite a program that returns the weight of the maximum weight path.", "solution": "def get_max_path(triangle, index, level, path, path_val):\n    if level == len(triangle):\n        return (path, path_val)\n    (ind_a, ind_b) = (index, index + 1)\n    (val_a, val_b) = (triangle[level][ind_a], triangle[level][ind_b])\n    (path_a, path_val_a) = get_max_path(triangle, ind_a, level + 1, path + [val_a], path_val + val_a)\n    (path_b, path_val_b) = get_max_path(triangle, ind_b, level + 1, path + [val_b], path_val + val_b)\n    return (path_a, path_val_a) if path_val_a > path_val_b else (path_b, path_val_b)\ndef get_max_path_helper(triangle):\n    return get_max_path(triangle, index=0, level=1, path=[triangle[0][0]], path_val=triangle[0][0])[0]", "title": "IE/201", "entry_cls_name": "Solution", "testing_code": "assert get_max_path_helper([[1], [2, 3], [1, 5, 1]]) == [1, 3, 5]\nassert get_max_path_helper([[1], [2, 3], [7, 5, 1]]) == [1, 2, 7]", "entry_fn_name": "get_max_path_helper"}
{"id": "202", "text": "Write a program that checks whether an integer is a palindrome. For example, `121` is a palindrome, as well as `888`. `678` is not a palindrome. Do not convert the integer into a string.", "solution": "DEC_FACT = 10\ndef is_palindrome(num, size):\n    if size == 0 or size == 1:\n        return True\n    fdig_factor = DEC_FACT ** (size - 1)\n    fdig = num // fdig_factor\n    ldig = num % DEC_FACT\n    if fdig != ldig:\n        return False\n    new_num = (num - fdig * fdig_factor) // DEC_FACT\n    return is_palindrome(new_num, size - 2)\ndef is_palindrome_helper(num):\n    size = 0\n    num_cp = num\n    while num_cp:\n        num_cp = num_cp // DEC_FACT\n        size += 1\n    return is_palindrome(num, size)", "title": "IE/202", "entry_cls_name": "Solution", "testing_code": "assert is_palindrome_helper(121)\nassert is_palindrome_helper(888)\nassert not is_palindrome_helper(678)\nassert not is_palindrome_helper(1678)\nassert is_palindrome_helper(1661)", "entry_fn_name": "is_palindrome_helper"}
{"id": "203", "text": "Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. Find the minimum element in `O(log N)` time. You may assume the array does not contain duplicates.\n\nFor example, given `[5, 7, 10, 3, 4]`, return `3`.", "solution": "def get_smallest(arr, start, end):\n    mid = start + (end - start) // 2\n    if arr[start] <= arr[mid]:\n        if arr[end] < arr[mid]:\n            return get_smallest(arr, mid + 1, end)\n        else:\n            return arr[start]\n    elif arr[start] >= arr[mid]:\n        if arr[end] > arr[mid]:\n            return get_smallest(arr, start, end)\n        else:\n            return arr[end]\ndef get_smallest_helper(arr):\n    smallest = get_smallest(arr, 0, len(arr) - 1)\n    return smallest", "title": "IE/203", "entry_cls_name": "Solution", "testing_code": "assert get_smallest_helper([5, 7, 10, 3, 4]) == 3\nassert get_smallest_helper([4, 5, 7, 10, 3]) == 3\nassert get_smallest_helper([3, 4, 5, 7, 10]) == 3", "entry_fn_name": "get_smallest_helper"}
{"id": "204", "text": "Given a complete binary tree, count the number of nodes in faster than `O(n)` time. Recall that a complete binary tree has every level filled except the last, and the nodes in the last level are filled starting from the left.", "solution": "class Node:\n\n    def __init__(self):\n        self.left = None\n        self.right = None\ndef count_nodes(root, lspine=0, rspine=0):\n    if not root:\n        return 0\n    if not lspine:\n        node = root\n        while node:\n            node = node.left\n            lspine += 1\n    if not rspine:\n        node = root\n        while node:\n            node = node.right\n            rspine += 1\n    if lspine == rspine:\n        return 2 ** lspine - 1\n    return 1 + count_nodes(root.left, lspine=lspine - 1) + count_nodes(root.right, rspine=rspine - 1)", "title": "IE/204", "entry_cls_name": "Solution", "testing_code": "a = Node()\nb = Node()\nc = Node()\na.left = b\na.right = c\nassert count_nodes(a) == 3\nd = Node()\nb.left = d\nassert count_nodes(a) == 4\ne = Node()\nb.right = e\nassert count_nodes(a) == 5\nf = Node()\nc.left = f\nassert count_nodes(a) == 6", "entry_fn_name": "count_nodes"}
{"id": "205", "text": "Given an integer, find the next permutation of it in absolute order. For example, given `48975`, the next permutation would be `49578`.", "solution": "from bisect import bisect\ndef get_next_perm(num):\n    num_str = str(num)\n    max_val_str = ''.join(sorted(num_str, reverse=True))\n    if max_val_str == num_str:\n        return num\n    right_nums = list()\n    num_to_replace = None\n    for i in range(len(num_str) - 2, -1, -1):\n        right_nums.append(num_str[i + 1])\n        if num_str[i] < num_str[i + 1]:\n            num_to_replace = num_str[i]\n            break\n    rep_index = bisect(right_nums, num_to_replace)\n    replacement = right_nums[rep_index]\n    right_nums[rep_index] = num_to_replace\n    leftover_nums = num_str[:i]\n    final_str = '{}{}{}'.format(leftover_nums, replacement, ''.join(sorted(right_nums)))\n    return int(final_str)", "title": "IE/205", "entry_cls_name": "Solution", "testing_code": "assert get_next_perm(98754) == 98754\nassert get_next_perm(48975) == 49578\nassert get_next_perm(48759) == 48795\nassert get_next_perm(49875) == 54789\nassert get_next_perm(408975) == 409578", "entry_fn_name": "get_next_perm"}
{"id": "206", "text": "A permutation can be specified by an array `P`, where `P[i]` represents the location of the element at `i` in the permutation. For example, `[2, 1, 0]` represents the permutation where elements at the index `0` and `2` are swapped.\n\nGiven an array and a permutation, apply the permutation to the array. For example, given the array `[\"a\", \"b\", \"c\"]` and the permutation `[2, 1, 0]`, return `[\"c\", \"b\", \"a\"]`.", "solution": "def permute(arr, perms):\n    evicted = dict()\n    for (i, (num, new_pos)) in enumerate(zip(arr, perms)):\n        if i in evicted:\n            num = evicted[i]\n            del evicted[i]\n        if new_pos > i:\n            evicted[new_pos] = arr[new_pos]\n        arr[new_pos] = num\n    return arr", "title": "IE/206", "entry_cls_name": "Solution", "testing_code": "assert permute(['a', 'b', 'c'], [2, 1, 0]) == ['c', 'b', 'a']\nassert permute(['a', 'b', 'c', 'd'], [2, 1, 0, 3]) == ['c', 'b', 'a', 'd']\nassert permute(['a', 'b', 'c', 'd'], [3, 0, 1, 2]) == ['b', 'c', 'd', 'a']", "entry_fn_name": "permute"}
{"id": "209", "text": "Write a program that computes the length of the longest common subsequence of three given strings. For example, given \"epidemiologist\", \"refrigeration\", and \"supercalifragilisticexpialodocious\", it should return `5`, since the longest common subsequence is \"eieio\".", "solution": "ALPHABET = 'abcdefghijklmnopqrstuvwxyz'\ndef get_lcs(strings, context, indices):\n    lcs_len = len(context)\n    for letter in ALPHABET:\n        new_indices = list()\n        for (j, string) in enumerate(strings):\n            index = string.find(letter, indices[j] + 1)\n            if index == -1:\n                break\n            new_indices.append(index)\n        if len(new_indices) == 3:\n            length_cs = get_lcs(strings, context + letter, new_indices)\n            if length_cs > lcs_len:\n                lcs_len = length_cs\n    return lcs_len\ndef get_lcs_helper(strings):\n    return get_lcs(strings, '', [-1] * len(strings))", "title": "IE/209", "entry_cls_name": "Solution", "testing_code": "assert get_lcs_helper(['epidemiologist', 'refrigeration', 'supercalifragilisticexpialodocious']) == 5", "entry_fn_name": "get_lcs_helper"}
{"id": "211", "text": "Given a string and a pattern, find the starting indices of all occurrences of the pattern in the string. For example, given the string \"abracadabra\" and the pattern \"abr\", you should return `[0, 7]`.", "solution": "def get_occurrences(string, pattern):\n    (sl, pl) = (len(string), len(pattern))\n    occurrences = list()\n    for i in range(sl - pl + 1):\n        if string[i:i + pl] == pattern:\n            occurrences.append(i)\n    return occurrences", "title": "IE/211", "entry_cls_name": "Solution", "testing_code": "assert get_occurrences('abracadabra', 'abr') == [0, 7]\nassert not get_occurrences('abracadabra', 'xyz')\nassert not get_occurrences('abr', 'abracadabra')\nassert get_occurrences('aaaa', 'aa') == [0, 1, 2]", "entry_fn_name": "get_occurrences"}
{"id": "212", "text": "Spreadsheets often use this alphabetical encoding for its columns: \"A\", \"B\", \"C\", ..., \"AA\", \"AB\", ..., \"ZZ\", \"AAA\", \"AAB\", ....\n\nGiven a column number, return its alphabetical column id. For example, given `1`, return \"A\". Given `27`, return \"AA\".", "solution": "alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\ndef get_alpha_encoding(num):\n    num_chars = 1\n    (min_range, max_range) = (1, 26)\n    while num > max_range:\n        num_chars += 1\n        min_range = max_range\n        max_range += len(alphabet) ** num_chars\n    chars = list()\n    for _ in range(num_chars):\n        interval = (max_range - min_range + 1) // len(alphabet)\n        char_pos = 0\n        (prev, curr) = (min_range, min_range + interval)\n        while num >= curr:\n            char_pos += 1\n            prev = curr\n            curr = prev + interval\n        chars.append(alphabet[char_pos])\n        num -= prev\n        (min_range, max_range) = (prev, curr)\n    return ''.join(chars)", "title": "IE/212", "entry_cls_name": "Solution", "testing_code": "assert get_alpha_encoding(1) == 'A'\nassert get_alpha_encoding(20) == 'T'\nassert get_alpha_encoding(27) == 'AA'", "entry_fn_name": "get_alpha_encoding"}
{"id": "213", "text": "Given a string of digits, generate all possible valid IP address combinations.\n\nIP addresses must follow the format `A.B.C.D`, where `A`, `B`, `C`, and `D` are numbers between `0` and `255`. Zero-prefixed numbers, such as `01` and `065`, are not allowed, except for `0` itself.\n\nFor example, given \"2542540123\", you should return `['254.25.40.123', '254.254.0.123']`.", "solution": "def generate_valid_ips(string, curr, all_ips):\n    if len(curr) > 4 or (len(curr) < 4 and (not string)):\n        return\n    elif len(curr) == 4 and (not string):\n        all_ips.add('.'.join(curr))\n        return\n\n    def recurse(index):\n        generate_valid_ips(string[index:], curr + [string[0:index]], all_ips)\n    recurse(1)\n    first = int(string[0])\n    if first and len(string) > 1:\n        recurse(2)\n        if len(string) > 2 and first < 3:\n            recurse(3)\ndef generate_valid_ip_helper(string):\n    all_ips = set()\n    generate_valid_ips(string, list(), all_ips)\n    return all_ips", "title": "IE/213", "entry_cls_name": "Solution", "testing_code": "assert generate_valid_ip_helper('2542540123') == {'254.25.40.123', '254.254.0.123'}\nassert generate_valid_ip_helper('0000') == {'0.0.0.0'}\nassert generate_valid_ip_helper('255255255255') == {'255.255.255.255'}\nassert generate_valid_ip_helper('100100110') == {'100.10.0.110', '10.0.100.110', '100.100.11.0', '100.100.1.10'}", "entry_fn_name": "generate_valid_ip_helper"}
{"id": "214", "text": "Given an integer `n`, return the length of the longest consecutive run of `1`s in its binary representation.\n\nFor example, given `156`, you should return `3`.", "solution": "def get_lcos(num):\n    current = longest = 0\n\n    def reset_current():\n        nonlocal current, longest\n        if current > longest:\n            longest = current\n        current = 0\n    while num:\n        if num % 2:\n            current += 1\n        else:\n            reset_current()\n        num = num >> 1\n    reset_current()\n    return longest", "title": "IE/214", "entry_cls_name": "Solution", "testing_code": "assert get_lcos(0) == 0\nassert get_lcos(4) == 1\nassert get_lcos(6) == 2\nassert get_lcos(15) == 4\nassert get_lcos(21) == 1\nassert get_lcos(156) == 3", "entry_fn_name": "get_lcos"}
{"id": "215", "text": "The horizontal distance of a binary tree node describes how far left or right the node will be when the tree is printed out.\n\nMore rigorously, we can define it as follows:\n* The horizontal distance of the root is `0`.\n* The horizontal distance of a left child is `hd(parent) - 1`.\n* The horizontal distance of a right child is `hd(parent) + 1`.\n\nFor example, for the following tree, `hd(1) = -2`, and `hd(6) = 0`.\n\n```\n             5\n          /     \\\n        3         7\n      /  \\      /   \\\n    1     4    6     9\n   /                /\n  0                8\n```\n  \nThe bottom view of a tree, then, consists of the lowest node at each horizontal distance. If there are two nodes at the same depth and horizontal distance, either is acceptable.\n\nFor this tree, for example, the bottom view could be `[0, 1, 3, 6, 8, 9]`.\n\nGiven the root to a binary tree, return its bottom view.", "solution": "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n        self.depth = None\n\n    def __repr__(self):\n        return 'Node[val={}]'.format(self.data)\ndef compute_bottom_view(root, depths, depth, width):\n    root.depth = depth\n    if width not in depths or depths[width].depth < depth:\n        depths[width] = root\n    if root.right:\n        compute_bottom_view(root.right, depths, depth + 1, width + 1)\n    if root.left:\n        compute_bottom_view(root.left, depths, depth + 1, width - 1)\ndef get_bottom_view(root):\n    depths = dict()\n    compute_bottom_view(root, depths, 0, 0)\n    sorted_items = sorted(depths.items(), key=lambda x: x[0])\n    return [x[1].data for x in sorted_items]", "title": "IE/215", "entry_cls_name": "Solution", "testing_code": "root = Node(5)\nroot.left = Node(3)\nroot.left.left = Node(1)\nroot.left.left.left = Node(0)\nroot.left.right = Node(4)\nroot.right = Node(7)\nroot.right.left = Node(6)\nroot.right.right = Node(9)\nroot.right.right.left = Node(8)\nassert get_bottom_view(root) == [0, 1, 3, 6, 8, 9]", "entry_fn_name": "get_bottom_view"}
{"id": "216", "text": "Given a number in Roman numeral format, convert it to decimal.\n\nThe values of Roman numerals are as follows:\n```\n{\n    'M': 1000,\n    'D': 500,\n    'C': 100,\n    'L': 50,\n    'X': 10,\n    'V': 5,\n    'I': 1\n}\n```\n\nIn addition, note that the Roman numeral system uses subtractive notation for numbers such as `IV` and `XL`.\n\nFor the input `XIV`, for instance, you should return `14`.", "solution": "values = {'M': 1000, 'D': 500, 'C': 100, 'L': 50, 'X': 10, 'V': 5, 'I': 1}\ndef convert_roman_to_decimal(roman):\n    if not roman:\n        return 0\n    pchar = roman[-1]\n    decimal = values[pchar]\n    for char in reversed(roman[:-1]):\n        decimal += values[char] * (-1 if values[char] < values[pchar] else 1)\n        pchar = char\n    return decimal", "title": "IE/216", "entry_cls_name": "Solution", "testing_code": "assert convert_roman_to_decimal('I') == 1\nassert convert_roman_to_decimal('IV') == 4\nassert convert_roman_to_decimal('XL') == 40\nassert convert_roman_to_decimal('XIV') == 14", "entry_fn_name": "convert_roman_to_decimal"}
{"id": "217", "text": "We say a number is sparse if there are no adjacent ones in its binary representation. For example, `21` (`10101`) is sparse, but `22` (`10110`) is not. For a given input `N`, find the smallest sparse number greater than or equal to `N`.\n\nDo this in faster than `O(N log N)` time.", "solution": "def get_next_sparse(num):\n    str_bin = str(bin(num))[2:]\n    new_str_bin = ''\n    prev_digit = None\n    flag = False\n    for (i, digit) in enumerate(str_bin):\n        if digit == '1' and prev_digit == '1':\n            flag = True\n        if flag:\n            new_str_bin += '0' * (len(str_bin) - i)\n            break\n        else:\n            new_str_bin += digit\n        prev_digit = digit\n    if flag:\n        if new_str_bin[0] == '1':\n            new_str_bin = '10' + new_str_bin[1:]\n        else:\n            new_str_bin = '1' + new_str_bin\n    new_num = int(new_str_bin, base=2)\n    return new_num", "title": "IE/217", "entry_cls_name": "Solution", "testing_code": "assert get_next_sparse(21) == 21\nassert get_next_sparse(25) == 32\nassert get_next_sparse(255) == 256", "entry_fn_name": "get_next_sparse"}
{"id": "218", "text": "Write an algorithm that computes the reversal of a directed graph. For example, if a graph consists of `A -> B -> C`, it should become `A <- B <- C`.", "solution": "class Node:\n\n    def __init__(self, iden):\n        self.iden = iden\n\n    def __hash__(self):\n        return hash(self.iden)\n\n    def __eq__(self, other):\n        return self.iden == other.iden\n\n    def __repr__(self):\n        return str(self.iden)\nclass edge:\n\n    def __init__(self, src, tgt):\n        self.src = src\n        self.tgt = tgt\n\n    def __hash__(self):\n        return hash((self.src, self.tgt))\n\n    def __eq__(self, other):\n        return self.src == other.src and self.tgt == other.tgt\n\n    def __repr__(self):\n        return '{}->{}'.format(self.src, self.tgt)\n\n    def reverse(self):\n        tmp_node = self.src\n        self.src = self.tgt\n        self.tgt = tmp_node\nclass Graph:\n\n    def __init__(self):\n        self.nodes = set()\n        self.edges = set()\n\n    def add_node(self, node):\n        if node in self.nodes:\n            return\n        self.nodes.add(node)\n\n    def add_edge(self, src_node, tgt_node):\n        self.edges.add(edge(src_node, tgt_node))\n\n    def reverse_edges(self):\n        self.edges = [edge(x.tgt, x.src) for x in self.edges]\n\n    def get_edges(self):\n        return self.edges", "title": "IE/218", "entry_cls_name": "Solution", "testing_code": "g = Graph()\na = Node('a')\nb = Node('b')\nc = Node('c')\ng.add_node(a)\ng.add_node(b)\ng.add_node(c)\ng.add_edge(a, b)\ng.add_edge(b, c)\nedges = g.get_edges()\nassert edge(a, b) in edges and edge(b, c) in edges and (len(edges) == 2)\ng.reverse_edges()\nedges = g.get_edges()\nassert edge(b, a) in edges and edge(c, b) in edges and (len(edges) == 2)", "entry_fn_name": "edge"}
{"id": "220", "text": "In front of you is a row of N coins, with values `v_1, v_2, ..., v_n`.\n\nYou are asked to play the following game. You and an opponent take turns choosing either the first or last coin from the row, removing it from the row, and receiving the value of the coin.\n\nWrite a program that returns the maximum amount of money you can win with certainty, if you move first, assuming your opponent plays optimally.", "solution": "def get_max_possible(coins, amount=0, turn=True):\n    if not coins:\n        return amount\n    if turn:\n        alt_1 = get_max_possible(coins[1:], amount + coins[0], False)\n        alt_2 = get_max_possible(coins[:-1], amount + coins[-1], False)\n        return max(alt_1, alt_2)\n    (first, last) = (coins[0], coins[-1])\n    if first > last:\n        coins = coins[1:]\n    else:\n        coins = coins[:-1]\n    return get_max_possible(coins, amount, True)", "title": "IE/220", "entry_cls_name": "Solution", "testing_code": "assert get_max_possible([1, 2, 3, 4, 5]) == 9", "entry_fn_name": "get_max_possible"}
{"id": "221", "text": "Let's define a \"sevenish\" number to be one which is either a power of `7`, or the sum of unique powers of `7`. The first few sevenish numbers are `1, 7, 8, 49`, and so on. Create an algorithm to find the `n`th sevenish number.", "solution": "def get_nth_sevenish(n):\n    if n < 1:\n        raise Exception(\"Invalid value for 'n'\")\n    power = 0\n    sevenish_nums = list()\n    while len(sevenish_nums) < n:\n        num = 7 ** power\n        new_sevenish_nums = [num]\n        for old in sevenish_nums:\n            if len(sevenish_nums) + len(new_sevenish_nums) == n:\n                return new_sevenish_nums[-1]\n            new_sevenish_nums.append(num + old)\n        sevenish_nums += new_sevenish_nums\n        power += 1\n    return sevenish_nums[-1]", "title": "IE/221", "entry_cls_name": "Solution", "testing_code": "assert get_nth_sevenish(1) == 1\nassert get_nth_sevenish(2) == 7\nassert get_nth_sevenish(3) == 8\nassert get_nth_sevenish(10) == 350", "entry_fn_name": "get_nth_sevenish"}
{"id": "222", "text": "Given an absolute pathname that may have `.` or `..` as part of it, return the shortest standardized path.\n\nFor example, given `/usr/bin/../bin/./scripts/../`, return `/usr/bin/`.", "solution": "PATH_SEPARATOR = '/'\ndef shorten_path(path):\n    stack = list()\n    dirs = path.split(PATH_SEPARATOR)\n    for dir_name in dirs:\n        if dir_name == '.':\n            continue\n        elif dir_name == '..':\n            stack.pop()\n        else:\n            stack.append(dir_name)\n    spath = PATH_SEPARATOR.join(stack)\n    return spath", "title": "IE/222", "entry_cls_name": "Solution", "testing_code": "assert shorten_path('/usr/bin/../bin/./scripts/../') == '/usr/bin/'", "entry_fn_name": "shorten_path"}
{"id": "224", "text": "Given a sorted array, find the smallest positive integer that is not the sum of a subset of the array.\n\nFor example, for the input `[1, 2, 3, 10]`, you should return `7`.\n\nDo this in `O(N)` time.", "solution": "def find_smallest(arr):\n    res = 1\n    for num in arr:\n        if num > res:\n            break\n        res += num\n    return res", "title": "IE/224", "entry_cls_name": "Solution", "testing_code": "assert find_smallest([1, 2, 3, 10]) == 7\nassert find_smallest([1, 2, 10]) == 4\nassert find_smallest([0, 10]) == 1", "entry_fn_name": "find_smallest"}
{"id": "225", "text": "There are `N` prisoners standing in a circle, waiting to be executed. The executions are carried out starting with the `k`th person, and removing every successive `k`th person going clockwise until there is no one left.\n\nGiven `N` and `k`, write an algorithm to determine where a prisoner should stand in order to be the last survivor.\n\nFor example, if `N = 5` and `k = 2`, the order of executions would be `[2, 4, 1, 5, 3]`, so you should return `3`.\n\nBonus: Find an `O(log N)` solution if `k = 2`.", "solution": "def last_exec(n, k):\n    last_exec = None\n    next_exec_index = 0\n    prisoners = list(range(1, n + 1))\n    while prisoners:\n        next_exec_index = (next_exec_index + k - 1) % len(prisoners)\n        last_exec = prisoners[next_exec_index]\n        prisoners = prisoners[:next_exec_index] + prisoners[next_exec_index + 1:]\n    return last_exec", "title": "IE/225", "entry_cls_name": "Solution", "testing_code": "assert last_exec(5, 2) == 3\nassert last_exec(3, 2) == 3\nassert last_exec(5, 3) == 4", "entry_fn_name": "last_exec"}
{"id": "226", "text": "You come across a dictionary of sorted words in a language you've never seen before. Write a program that returns the correct order of letters in this language.\n\nFor example, given `['xww', 'wxyz', 'wxyw', 'ywx', 'ywz']`, you should return `['x', 'z', 'w', 'y']`.", "solution": "def update_letter_order(sorted_words, letters):\n    order = list()\n    new_words = dict()\n    prev_char = None\n    for word in sorted_words:\n        if word:\n            char = word[0]\n            if char != prev_char:\n                order.append(char)\n            if char not in new_words:\n                new_words[char] = list()\n            new_words[char].append(word[1:])\n            prev_char = char\n    for (index, char) in enumerate(order):\n        letters[char] |= set(order[index + 1:])\n    for char in new_words:\n        update_letter_order(new_words[char], letters)\ndef find_path(letters, start, path, length):\n    if len(path) == length:\n        return path\n    if not letters[start]:\n        return None\n    for next_start in letters[start]:\n        new_path = find_path(letters, next_start, path + [next_start], length)\n        if new_path:\n            return new_path\ndef update_letter_order_helper(sorted_words):\n    letters = dict()\n    for word in sorted_words:\n        for letter in word:\n            if letter not in letters:\n                letters[letter] = set()\n    update_letter_order(sorted_words, letters)\n    max_children = max([len(x) for x in letters.values()])\n    potential_heads = [x for x in letters if len(letters[x]) == max_children]\n    path = None\n    for head in potential_heads:\n        path = find_path(letters, head, path=[head], length=len(letters))\n        if path:\n            break\n    return path", "title": "IE/226", "entry_cls_name": "Solution", "testing_code": "assert update_letter_order_helper(['xww', 'wxyz', 'wxyw', 'ywx', 'ywz']) == ['x', 'z', 'w', 'y']", "entry_fn_name": "update_letter_order_helper"}
{"id": "228", "text": "Given a list of numbers, create an algorithm that arranges them in order to form the largest possible integer. For example, given `[10, 7, 76, 415]`, you should return `77641510`.", "solution": "def get_largest(nums, prefix=''):\n    num_dict = dict()\n    for num in nums:\n        str_num = str(num)\n        fdig = str_num[0]\n        if fdig not in num_dict:\n            num_dict[fdig] = list()\n        num_dict[fdig].append(str_num)\n    sorted_arrs = sorted(num_dict.values(), key=lambda x: x[0], reverse=True)\n    combined = list()\n    for arr in sorted_arrs:\n        if len(arr) == 1:\n            combined.extend(arr)\n            continue\n        split_dict = dict()\n        for num in arr:\n            len_num = len(num)\n            if len_num not in split_dict:\n                split_dict[len_num] = list()\n            split_dict[len_num].append(num)\n        sorted_val_arrs = sorted(split_dict.values(), key=lambda x: len(x[0]))\n        for val_arr in sorted_val_arrs:\n            combined.extend(sorted(val_arr, reverse=True))\n    return int(prefix.join(combined))", "title": "IE/228", "entry_cls_name": "Solution", "testing_code": "assert get_largest([10, 7, 76, 415]) == 77641510", "entry_fn_name": "get_largest"}
{"id": "229", "text": "Snakes and Ladders is a game played on a `10 x 10` board, the goal of which is get from square `1` to square `100`. On each turn players will roll a six-sided die and move forward a number of spaces equal to the result. If they land on a square that represents a snake or ladder, they will be transported ahead or behind, respectively, to a new square.\n\nFind the smallest number of turns it takes to play snakes and ladders.\n\nFor convenience, here are the squares representing snakes and ladders, and their outcomes:\n\n```\nsnakes = {16: 6, 48: 26, 49: 11, 56: 53, 62: 19, 64: 60, 87: 24, 93: 73, 95: 75, 98: 78}\nladders = {1: 38, 4: 14, 9: 31, 21: 42, 28: 84, 36: 44, 51: 67, 71: 91, 80: 100}\n```", "solution": "import sys\nSNAKES = {16: 6, 48: 26, 49: 11, 56: 53, 62: 19, 64: 60, 87: 24, 93: 73, 95: 75, 98: 78}\nLADDERS = {1: 38, 4: 14, 9: 31, 21: 42, 28: 84, 36: 44, 51: 67, 71: 91, 80: 100}\nSHORCUTS = {**SNAKES, **LADDERS}\nCACHE = dict()\ndef get_num_turns(pos, played_turns):\n    if played_turns > 100 or pos > 100:\n        return sys.maxsize\n    if pos == 100:\n        return played_turns\n    if pos in CACHE:\n        return CACHE[pos]\n    if pos in SHORCUTS:\n        num_turns = get_num_turns(SHORCUTS[pos], played_turns)\n        CACHE[pos] = num_turns\n        return CACHE[pos]\n    possible_num_turns = list()\n    for i in range(1, 7):\n        num_turns = get_num_turns(pos + i, played_turns + 1)\n        CACHE[pos + i] = num_turns\n        possible_num_turns.append(num_turns)\n    return min(possible_num_turns)", "title": "IE/229", "entry_cls_name": "Solution", "testing_code": "assert get_num_turns(0, 0) == 24", "entry_fn_name": "get_num_turns"}
{"id": "230", "text": "You are given `N` identical eggs and access to a building with `k` floors. Your task is to find the lowest floor that will cause an egg to break, if dropped from that floor. Once an egg breaks, it cannot be dropped again. If an egg breaks when dropped from the `x`th floor, you can assume it will also break when dropped from any floor greater than `x`.\n\nWrite an algorithm that finds the minimum number of trial drops it will take, in the worst case, to identify this floor.\n\nFor example, if `N = 1` and `k = 5`, we will need to try dropping the egg at every floor, beginning with the first, until we reach the fifth floor, so our solution will be `5`.", "solution": "def get_min_drops(N, k):\n    if N == 0 or N == 1 or k == 1:\n        return N\n    possibilities = list()\n    for i in range(1, N + 1):\n        possibilities.append(max(get_min_drops(i - 1, k - 1), get_min_drops(N - i, k)))\n    return min(possibilities) + 1", "title": "IE/230", "entry_cls_name": "Solution", "testing_code": "assert get_min_drops(20, 2) == 6\nassert get_min_drops(15, 3) == 5", "entry_fn_name": "get_min_drops"}
{"id": "231", "text": "Given a string with repeated characters, rearrange the string so that no two adjacent characters are the same. If this is not possible, return None.\n\nFor example, given \"aaabbc\", you could return \"ababac\". Given \"aaab\", return \"\".", "solution": "def rearrange(string):\n    from collections import Counter\n    from queue import Queue\n    c = Counter(string)\n    sitems = sorted(c.items(), key=lambda x: x[1], reverse=True)\n    strlen = len(string)\n    if strlen % 2:\n        if sitems[0][1] > strlen // 2 + 1:\n            return ''\n    elif sitems[0][1] > strlen // 2:\n        return ''\n    q = Queue()\n    for item in sitems:\n        q.put(item)\n    new_str = ''\n    while not q.empty():\n        item = q.get()\n        new_str += item[0]\n        item = (item[0], item[1] - 1)\n        if item[1]:\n            q.put(item)\n    return new_str", "title": "IE/231", "entry_cls_name": "Solution", "testing_code": "assert rearrange('aaabbc') == 'abcaba'\nassert rearrange('aaab') == ''\nassert rearrange('aaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbcccccccccccccccccz') == 'baczbacbacbacbacbacbacbacbacbacbacbacbacbacbacbacbacbababababababababababbb'", "entry_fn_name": "rearrange"}
{"id": "233", "text": "Implement the function `fib(n)`, which returns the nth number in the Fibonacci sequence, using only `O(1)` space.", "solution": "def get_fib(n):\n    assert n > 0\n    fib_a = 0\n    fib_b = 1\n    if n == 1:\n        return fib_a\n    elif n == 2:\n        return fib_b\n    fib_c = None\n    for _ in range(n - 2):\n        fib_c = fib_a + fib_b\n        fib_a = fib_b\n        fib_b = fib_c\n    return fib_c", "title": "IE/233", "entry_cls_name": "Solution", "testing_code": "assert get_fib(5) == 3\nassert get_fib(2) == 1\nassert get_fib(7) == 8", "entry_fn_name": "get_fib"}
{"id": "234", "text": "Recall that the minimum spanning tree is the subset of edges of a tree that connect all its vertices with the smallest possible total edge weight. Given an undirected graph with weighted edges, compute the maximum weight spanning tree.", "solution": "class Node:\n\n    def __init__(self, val):\n        self.val = val\n\n    def __hash__(self):\n        return hash(self.val)\n\n    def __repr__(self):\n        return str(self.val)\nclass Edge:\n\n    def __init__(self, target, weight):\n        self.target = target\n        self.weight = weight\n\n    def __hash__(self):\n        return hash(self.target)\n\n    def __repr__(self):\n        return '-{}-> {}'.format(self.weight, self.target)\nclass Graph:\n\n    def __init__(self):\n        self.nodes = set()\n        self.edges = dict()\n\n    def add_node(self, node):\n        self.nodes.add(node)\n        self.edges[node] = set()\n\n    def add_edge(self, source, target, weight):\n        if source not in self.nodes:\n            self.add_node(source)\n        if target not in self.nodes:\n            self.add_node(target)\n        self.edges[source].add(Edge(target, weight))\n        self.edges[target].add(Edge(source, weight))\ndef get_max_span_helper(g, start, remaining, score):\n    if not remaining:\n        return score\n    scores = list()\n    for edge in g.edges[start]:\n        if edge.target in remaining:\n            rem_cp = remaining.copy()\n            rem_cp.remove(edge.target)\n            new_score = get_max_span_helper(g, edge.target, rem_cp, score + edge.weight)\n            scores.append(new_score)\n    return max(scores)\ndef get_max_span(g):\n    remaining = g.nodes.copy()\n    start_node = list(remaining)[0]\n    remaining.remove(start_node)\n    score = get_max_span_helper(g, start_node, remaining, 0)\n    return score", "title": "IE/234", "entry_cls_name": "Solution", "testing_code": "g = Graph()\na = Node('a')\nb = Node('b')\nc = Node('c')\ng.add_edge(a, b, 1)\ng.add_edge(a, c, 2)\ng.add_edge(b, c, 3)\nassert get_max_span(g) == 5", "entry_fn_name": "get_max_span"}
{"id": "235", "text": "Given an array of numbers of length `N`, find both the minimum and maximum using less than `2 * (N - 2)` comparisons.", "solution": "def find_min_max(nums):\n    mini = maxi = nums[0]\n    for num in nums[1:]:\n        if num < mini:\n            mini = num\n            continue\n        elif num > maxi:\n            maxi = num\n    return [mini, maxi]", "title": "IE/235", "entry_cls_name": "Solution", "testing_code": "assert find_min_max([4, 3, 1, 2, 5]) == [1, 5]\nassert find_min_max([1,1,1,1,1,1,1]) == [1, 1]\nassert find_min_max([1,1,1,1,-1,-1,-1]) == [-1, 1]", "entry_fn_name": "find_min_max"}
{"id": "237", "text": "A tree is symmetric if its data and shape remain unchanged when it is reflected about the root node. The following tree is an example:\n\n```\n        4\n      / | \\\n    3   5   3\n  /           \\\n9              9\n```\n\nGiven a k-ary tree, determine whether it is symmetric.", "solution": "class Node:\n\n    def __init__(self, val):\n        self.val = val\n        self.children = list()\n\n    def __repr__(self):\n        return '{} -> {}'.format(self.val, self.children)\ndef update_levels_dict(root, levels, lnum):\n    if lnum not in levels:\n        levels[lnum] = list()\n    levels[lnum].append(root.val)\n    for child in root.children:\n        update_levels_dict(child, levels, lnum + 1)\ndef is_symmetric(tree):\n    levels = dict()\n    update_levels_dict(tree, levels, 0)\n    for level in levels:\n        arr = levels[level]\n        if arr != arr[::-1]:\n            return False\n    return True", "title": "IE/237", "entry_cls_name": "Solution", "testing_code": "e = Node(9)\nf = Node(9)\nd = Node(3)\nd.children = [e]\nc = Node(3)\nc.children = [f]\nb = Node(5)\na = Node(4)\na.children = [c, b, d]\nassert is_symmetric(a)\nc.val = 4\nassert not is_symmetric(a)", "entry_fn_name": "is_symmetric"}
{"id": "239", "text": "One way to unlock an Android phone is through a pattern of swipes across a 1-9 keypad.\n\nFor a pattern to be valid, it must satisfy the following:\n\nAll of its keys must be distinct.\nIt must not connect two keys by jumping over a third key, unless that key has already been used.\nFor example, `4 - 2 - 1 - 7` is a valid pattern, whereas `2 - 1 - 7` is not.\n\nFind the total number of valid unlock patterns of length N, where `1 <= N <= 9`.", "solution": "class Dialpad:\n\n    def __init__(self):\n        self.nodes = set(range(1, 10))\n        self.edges = dict()\n        self.edges[1] = {2, 4}\n        self.edges[2] = {1, 3, 5}\n        self.edges[3] = {2, 6}\n        self.edges[4] = {1, 5, 7}\n        self.edges[5] = {2, 4, 6, 8}\n        self.edges[6] = {3, 5, 9}\n        self.edges[7] = {4, 8}\n        self.edges[8] = {5, 7, 9}\n        self.edges[9] = {6, 8}\ndef count_code_helper(dp, code_len, curr, seen):\n    if code_len == 0:\n        return 1\n    seen_cp = seen.copy()\n    seen_cp.add(curr)\n    nodes = dp.edges[curr]\n    sub_count = 0\n    for node in nodes:\n        sub_count += count_code_helper(dp, code_len - 1, node, seen_cp)\n    return sub_count\ndef count_codes(dp, code_len):\n    if code_len == 1:\n        return len(dp.nodes)\n    count = 0\n    for node in dp.nodes:\n        count += count_code_helper(dp, code_len, node, set())\n    return count", "title": "IE/239", "entry_cls_name": "Solution", "testing_code": "dp = Dialpad()\nassert count_codes(dp, 1) == 9\nassert count_codes(dp, 2) == 68\nassert count_codes(dp, 3) == 192", "entry_fn_name": "count_codes"}
{"id": "241", "text": "In academia, the h-index is a metric used to calculate the impact of a researcher's papers. It is calculated as follows:\n\nA researcher has index `h` if at least `h` of her `N` papers have `h` citations each. If there are multiple `h` satisfying this formula, the maximum is chosen.\n\nFor example, suppose `N = 5`, and the respective citations of each paper are `[4, 3, 0, 1, 5]`. Then the h-index would be `3`, since the researcher has `3` papers with at least `3` citations.\n\nGiven a list of paper citations of a researcher, calculate their h-index.", "solution": "def get_h_index(citations):\n    citations.sort(reverse=True)\n    for (i, cit_count) in enumerate(citations):\n        if i >= cit_count:\n            return i", "title": "IE/241", "entry_cls_name": "Solution", "testing_code": "assert get_h_index([4, 3, 0, 1, 5]) == 3\nassert get_h_index([4, 1, 0, 1, 1]) == 1\nassert get_h_index([4, 4, 4, 5, 4]) == 4", "entry_fn_name": "get_h_index"}
{"id": "243", "text": "Given an array of numbers `N` and an integer `k`, your task is to split `N` into `k` partitions such that the maximum sum of any partition is minimized. Return this sum.\n\nFor example, given `N = [5, 1, 2, 7, 3, 4]` and `k = 3`, you should return `8`, since the optimal partition is `[5, 1, 2], [7], [3, 4]`.", "solution": "import sys\ndef split(arr, k):\n    if k == 1:\n        return ([arr], sum(arr))\n    min_val = sys.maxsize\n    min_cand = None\n    for i in range(len(arr)):\n        (arr_1, sum_1) = ([arr[:i]], sum(arr[:i]))\n        (arr_2, sum_2) = split(arr[i:], k - 1)\n        candidate = (arr_1 + arr_2, max(sum_1, sum_2))\n        if candidate[1] < min_val:\n            min_val = candidate[1]\n            min_cand = candidate\n    return min_cand\ndef split_helper(arr, k):\n    return split(arr, k)[1]", "title": "IE/243", "entry_cls_name": "Solution", "testing_code": "assert split_helper([5, 1, 2, 7, 3, 4], 3) == 8", "entry_fn_name": "split_helper"}
{"id": "245", "text": "You are given an array of integers, where each element represents the maximum number of steps that can be jumped going forward from that element. Write a function to return the minimum number of jumps you must take in order to get from the start to the end of the array.\n\nFor example, given `[6, 2, 4, 0, 5, 1, 1, 4, 2, 9]`, you should return `2`, as the optimal solution involves jumping from `6` to `5`, and then from `5` to `9`.", "solution": "def get_min_jumps(arr):\n    if len(arr) < 2:\n        return 0\n    start = arr[0]\n    candidates = list()\n    for i in range(1, min(start + 1, len(arr))):\n        if arr[i] == 0:\n            continue\n        candidate = 1 + get_min_jumps(arr[i:])\n        candidates.append(candidate)\n    return min(candidates)", "title": "IE/245", "entry_cls_name": "Solution", "testing_code": "assert get_min_jumps([6, 2, 4, 0, 5, 1, 1, 4, 2, 9]) == 2", "entry_fn_name": "get_min_jumps"}
{"id": "246", "text": "Given a list of words, determine whether the words can be chained to form a circle. A word `X` can be placed in front of another word `Y` in a circle if the last character of `X` is same as the first character of `Y`.\n\nFor example, the words `['chair', 'height', 'racket', 'touch', 'tunic']` can form the following circle: `chair -> racket -> touch -> height -> tunic -> chair`.", "solution": "def create_word_dict(words):\n    word_dict = dict()\n    for word in words:\n        start_char = word[0]\n        if not start_char in word_dict:\n            word_dict[start_char] = set()\n        word_dict[start_char].add(word)\n    return word_dict\ndef circle_helper(words):\n    words = set(words)\n    word_dict = create_word_dict(words)\n    for word in words:\n        curr_char = word[-1]\n        if can_form_circle(curr_char, words - {word}, [word], word_dict):\n            return True\n    return False", "title": "IE/246", "entry_cls_name": "Solution", "testing_code": "assert circle_helper(['chair', 'height', 'racket', 'touch', 'tunic'])\nassert not circle_helper(['height', 'racket', 'touch', 'tunic'])\nassert circle_helper(['abc', 'cba'])", "entry_fn_name": "circle_helper"}
{"id": "247", "text": "Given a binary tree, determine whether or not it is height-balanced. A height-balanced binary tree can be defined as one in which the heights of the two subtrees of any node never differ by more than one.", "solution": "class Node:\n\n    def __init__(self):\n        self.left = None\n        self.right = None\ndef get_height(root):\n    if not root:\n        return 0\n    left_height = get_height(root.left)\n    right_height = get_height(root.right)\n    return max(left_height, right_height) + 1\ndef is_balanced(root):\n    left_height = get_height(root.left)\n    right_height = get_height(root.right)\n    return True if abs(left_height - right_height) < 2 else False", "title": "IE/247", "entry_cls_name": "Solution", "testing_code": "a = Node()\nb = Node()\nc = Node()\na.left = b\nassert is_balanced(a)\na.right = c\nassert is_balanced(a)\nd = Node()\ne = Node()\nb.left = d\nd.left = e\nassert not is_balanced(a)", "entry_fn_name": "is_balanced"}
{"id": "248", "text": "Find the maximum of two numbers without using any if-else statements, branching, or direct comparisons.", "solution": "def get_max(a, b):\n    c = a - b\n    k = c >> 31 & 1\n    return a - k * c", "title": "IE/248", "entry_cls_name": "Solution", "testing_code": "assert get_max(5, 3) == 5\nassert get_max(5, 10) == 10", "entry_fn_name": "get_max"}
{"id": "249", "text": "Given an array of integers, find the maximum XOR of any two elements.", "solution": "import sys\ndef max_xor(arr):\n    maxx = -sys.maxsize\n    for i in range(len(arr) - 1):\n        for k in range(i + 1, len(arr)):\n            maxx = max(maxx, arr[i] ^ arr[k])\n    return maxx", "title": "IE/249", "entry_cls_name": "Solution", "testing_code": "assert max_xor([1, 2, 3, 4]) == 7", "entry_fn_name": "max_xor"}
{"id": "250", "text": "A cryptarithmetic puzzle is a mathematical game where the digits of some numbers are represented by letters. Each letter represents a unique digit.\n\nFor example, a puzzle of the form:\n\n```\n  SEND\n+ MORE\n--------\n MONEY\n```\nmay have the solution:\n\n`{'S': 9, 'E': 5, 'N': 6, 'D': 7, 'M': 1, 'O': 0, 'R': 8, 'Y': 2}`\n\nGiven a three-word puzzle like the one above, create an algorithm that finds a solution.", "solution": "def get_num_from_string(char_map, string):\n    power = 0\n    total = 0\n    for char in string[::-1]:\n        total += char_map[char] * 10 ** power\n        power += 1\n    return total\ndef is_valid_map(exp1, exp2, res, char_map):\n    num1 = get_num_from_string(char_map, exp1)\n    num2 = get_num_from_string(char_map, exp2)\n    num3 = get_num_from_string(char_map, res)\n    return num1 + num2 == num3\ndef evaluate_char_maps(exp1, exp2, res, char_maps):\n    for char_map in char_maps:\n        if is_valid_map(exp1, exp2, res, char_map):\n            return char_map\ndef assign_letters(chars_left, nums_left, restrictions, char_map=dict()):\n    if not chars_left:\n        return [char_map]\n    curr_char = list(chars_left)[0]\n    char_maps = list()\n    for num in nums_left:\n        if num in restrictions[curr_char]:\n            continue\n        char_map_cp = char_map.copy()\n        char_map_cp[curr_char] = num\n        child_char_maps = assign_letters(chars_left - set([curr_char]), nums_left - set([num]), restrictions, char_map_cp)\n        char_maps.extend(child_char_maps)\n    return char_maps\ndef decode(exp1, exp2, res):\n    characters = set(exp1) | set(exp2) | set(res)\n    assert len(characters) < 11\n    nums = set(range(0, 10))\n    restrictions = dict()\n    for char in characters:\n        restrictions[char] = set()\n    for word in [exp1, exp2, res]:\n        restrictions[word[0]].add(0)\n    char_maps = assign_letters(characters, nums, restrictions)\n    return evaluate_char_maps(exp1, exp2, res, char_maps)", "title": "IE/250", "entry_cls_name": "Solution", "testing_code": "assert decode('SEND', 'MORE', 'MONEY') == {'S': 9, 'E': 5, 'N': 6, 'D': 7, 'M': 1, 'O': 0, 'R': 8, 'Y': 2}", "entry_fn_name": "decode"}
{"id": "255", "text": "The transitive closure of a graph is a measure of which vertices are reachable from other vertices. It can be represented as a matrix `M`, where `M[i][j] == 1` if there is a path between vertices `i` and `j`, and otherwise `0`.\n\nFor example, suppose we are given the following graph in adjacency list form:\n```\ngraph = [\n    [0, 1, 3],\n    [1, 2],\n    [2],\n    [3]\n]\n```\n\nThe transitive closure of this graph would be:\n```\n[1, 1, 1, 1]\n[0, 1, 1, 0]\n[0, 0, 1, 0]\n[0, 0, 0, 1]\n```\n\nGiven a graph, find its transitive closure.", "solution": "def update_transitive_closure(orig, node, adjacency_list, transitive_closure):\n    if len(adjacency_list[node]) == 1:\n        return\n    for adj_node in adjacency_list[node]:\n        if orig == adj_node or node == adj_node:\n            continue\n        transitive_closure[orig][adj_node] = 1\n        update_transitive_closure(orig, adj_node, adjacency_list, transitive_closure)\ndef get_transitive_closure(adjacency_list):\n    transitive_closure = [[0 for _ in range(len(adjacency_list))] for _ in range(len(adjacency_list))]\n    for i in range(len(adjacency_list)):\n        transitive_closure[i][i] = 1\n    for i in adjacency_list:\n        update_transitive_closure(i, i, adjacency_list, transitive_closure)\n    return transitive_closure", "title": "IE/255", "entry_cls_name": "Solution", "testing_code": "adjacency_list = {0: [0, 1, 3], 1: [1, 2], 2: [2], 3: [3]}\nassert get_transitive_closure(adjacency_list) == [[1, 1, 1, 1], [0, 1, 1, 0], [0, 0, 1, 0], [0, 0, 0, 1]]", "entry_fn_name": "get_transitive_closure"}
{"id": "257", "text": "Given an array of integers out of order, determine the bounds of the smallest window that must be sorted in order for the entire array to be sorted. For example, given `[3, 7, 5, 6, 9]`, you should return `[1, 3]`.", "solution": "def get_sort_range(arr):\n    from heapq import heappush as hp\n    if arr == sorted(arr):\n        return []\n    options = list()\n    for sort_start in range(len(arr) - 1):\n        for sort_end in range(1, len(arr) + 1):\n            a1 = arr[:sort_start]\n            a2 = arr[sort_start:sort_end]\n            a3 = arr[sort_end:]\n            new_arr = a1 + sorted(a2) + a3\n            if new_arr == sorted(new_arr):\n                hp(options, (sort_end - sort_start, [sort_start, sort_end - 1]))\n    return options[0][1]", "title": "IE/257", "entry_cls_name": "Solution", "testing_code": "assert get_sort_range([3, 5, 6, 7, 9]) == []\nassert get_sort_range([3, 7, 5, 6, 9]) == [1, 3]\nassert get_sort_range([5, 4, 3, 2, 1]) == [0, 4]", "entry_fn_name": "get_sort_range"}
{"id": "258", "text": "In Ancient Greece, it was common to write text with the first line going left to right, the second line going right to left, and continuing to go back and forth. This style was called \"boustrophedon\".\n\nGiven a binary tree, write an algorithm to print the nodes in boustrophedon order.\n\nFor example, given the following tree:\n\n```\n       1\n    /     \\\n  2         3\n / \\       / \\\n4   5     6   7\n```\n\nYou should return `[1, 3, 2, 4, 5, 6, 7]`.", "solution": "class Node:\n\n    def __init__(self, val):\n        self.val = val\n        self.ln = None\n        self.rn = None\n\n    def __repr__(self):\n        return 'Node=({}, ln={}, rn={})'.format(self.val, self.ln, self.rn)\ndef get_bfs_alt(root, level, level_dict):\n    if not root:\n        return\n    if level not in level_dict:\n        level_dict[level] = list()\n    level_dict[level].append(root.val)\n    get_bfs_alt(root.ln, level + 1, level_dict)\n    get_bfs_alt(root.rn, level + 1, level_dict)\ndef get_boustrophedon(root):\n    level_dict = dict()\n    get_bfs_alt(root, 0, level_dict)\n    final_order = list()\n    for i in range(len(level_dict)):\n        final_order.extend(reversed(level_dict[i]) if i % 2 else level_dict[i])\n    return final_order", "title": "IE/258", "entry_cls_name": "Solution", "testing_code": "n1 = Node(1)\nn2 = Node(2)\nn3 = Node(3)\nn4 = Node(4)\nn5 = Node(5)\nn6 = Node(6)\nn7 = Node(7)\nn2.ln = n4\nn2.rn = n5\nn3.ln = n6\nn3.rn = n7\nn1.ln = n2\nn1.rn = n3\nassert get_boustrophedon(n1) == [1, 3, 2, 4, 5, 6, 7]", "entry_fn_name": "get_boustrophedon"}
{"id": "259", "text": "Ghost is a two-person word game where players alternate appending letters to a word. The first person who spells out a word, or creates a prefix for which there is no possible continuation, loses. Here is a sample game:\n\n```\nPlayer 1: g\nPlayer 2: h\nPlayer 1: o\nPlayer 2: s\nPlayer 1: t [loses]\n```\n\nGiven a dictionary of words, determine the letters the first player should start with, such that with optimal play they cannot lose.\n\nFor example, if the dictionary is `[\"cat\", \"calf\", \"dog\", \"bear\"]`, the only winning start letter would be b.", "solution": "def get_optimal_chars(words):\n    candidates = dict()\n    for word in words:\n        fc = word[0]\n        if fc not in candidates:\n            candidates[fc] = set()\n        candidates[fc].add(len(word))\n    opt_chars = set()\n    for char in candidates:\n        if all((not x % 2 for x in candidates[char])):\n            opt_chars.add(char)\n    return opt_chars", "title": "IE/259", "entry_cls_name": "Solution", "testing_code": "assert get_optimal_chars(['cat', 'calf', 'dog', 'bear']) == {'b'}\nassert get_optimal_chars(['cat', 'calf', 'dog', 'bear', 'ao']) == {'b', 'a'}\nassert get_optimal_chars([\"ghost\", \"ghostbuster\", \"gas\"]) == {}\n\n", "entry_fn_name": "get_optimal_chars"}
{"id": "260", "text": "The sequence `[0, 1, ..., N]` has been jumbled, and the only clue you have for its order is an array representing whether each number is larger or smaller than the last. Given this information, reconstruct an array that is consistent with it. For example, given `[\"\", +, +, -, +]`, you could return `[1, 2, 3, 0, 4]`.", "solution": "def deduce_nums(arr):\n    ln = len(arr)\n    count_gt = sum([1 for x in arr if x == '+'])\n    first = ln - count_gt - 1\n    nums = [first]\n    (small, large) = (first - 1, first + 1)\n    for sym in arr[1:]:\n        if sym == '+':\n            nums.append(large)\n            large += 1\n        else:\n            nums.append(small)\n            small -= 1\n    return nums", "title": "IE/260", "entry_cls_name": "Solution", "testing_code": "assert deduce_nums(['0','+','+']) == [0,1,2]\nassert deduce_nums(['0','-','-']) == [2,1,0]\nassert deduce_nums(['', '+', '+', '-', '+']) == [1, 2, 3, 0, 4]\nassert deduce_nums(['0','-','-','-','-','-']) == [5, 4, 3, 2, 1, 0]\n", "entry_fn_name": "deduce_nums"}
{"id": "263", "text": "Create a basic sentence checker that takes in a stream of characters and determines whether they form valid sentences. If a sentence is valid, the program should print it out.\n\nWe can consider a sentence valid if it conforms to the following rules:\n* The sentence must start with a capital letter, followed by a lowercase letter or a space.\n* All other characters must be lowercase letters, separators `(,,;,:)` or terminal marks `(.,?,!,\u203d)`.\n* There must be a single space between each word.\n* The sentence must end with a terminal mark immediately following a word.", "solution": "SEPARATORS = {',', ';', ':'}\nTERM_MARKS = {'.', '?', '!'}\ndef is_valid(context, char, next_chars):\n    curr_valid = True\n    if not context and (not char.istitle()):\n        return False\n    if len(context) == 1:\n        if char == ' ' or not char.istitle():\n            pass\n        else:\n            return False\n    if char in TERM_MARKS:\n        return context[-1] not in SEPARATORS | TERM_MARKS\n    if not next_chars:\n        return char in TERM_MARKS and curr_valid\n    return is_valid(context + char, next_chars[0], next_chars[1:]) if curr_valid else False\ndef is_valid_sentence(sentence):\n    return is_valid('', sentence[0], sentence[1:])", "title": "IE/263", "entry_cls_name": "Solution", "testing_code": "assert is_valid_sentence('Valid sentence.')\nassert not is_valid_sentence('Invalid sentence')\nassert not is_valid_sentence('INvalid sentence.')\nassert is_valid_sentence('A valid sentence.')", "entry_fn_name": "is_valid_sentence"}
{"id": "265", "text": "MegaCorp wants to give bonuses to its employees based on how many lines of codes they have written. They would like to give the smallest positive amount to each worker consistent with the constraint that if a developer has written more lines of code than their neighbor, they should receive more money.\n\nGiven an array representing a line of seats of employees at MegaCorp, determine how much each one should get paid.\n\nFor example, given `[10, 40, 200, 1000, 60, 30]`, you should return `[1, 2, 3, 4, 2, 1]`.", "solution": "def get_segments(arr):\n    asc = arr[1] > arr[0]\n    prev = arr[0]\n    start = 0\n    segments = []\n    for (i, num) in enumerate(arr[1:]):\n        if asc and num < prev or (not asc and num > prev):\n            segments.append((asc, i - start + 1))\n            start = i + 1\n            asc = not asc\n        prev = num\n    segments.append((asc, len(arr) - start))\n    return segments\ndef get_bonuses(arr):\n    if not arr:\n        return []\n    if len(arr) == 1:\n        return [1]\n    segments = get_segments(arr)\n    bonuses = list()\n    for segment in segments:\n        (asc, length) = segment\n        seg_bonuses = list(range(length))\n        if not asc:\n            seg_bonuses.reverse()\n        bonuses.extend(seg_bonuses)\n    bonuses = [x + 1 for x in bonuses]\n    return bonuses", "title": "IE/265", "entry_cls_name": "Solution", "testing_code": "assert get_bonuses([1000]) == [1]\nassert get_bonuses([10, 40, 200, 1000, 60, 30]) == [1, 2, 3, 4, 2, 1]\nassert get_bonuses([10, 40, 200, 1000, 900, 800, 30]) == [1, 2, 3, 4, 3, 2, 1]", "entry_fn_name": "get_bonuses"}
{"id": "266", "text": "A step word is formed by taking a given word, adding a letter, and anagramming the result. For example, starting with the word \"APPLE\", you can add an \"A\" and anagram to get \"APPEAL\".\n\nGiven a dictionary of words and an input word, create a function that returns all valid step words.", "solution": "ALPHA_SIZE = 26\nAPLHA_ASCII_OFFSET = 65\nclass WordCode:\n\n    def __init__(self, word):\n        self.word = word\n        self.vec = [0 for _ in range(ALPHA_SIZE)]\n        for ch in word:\n            ind = ord(ch) - APLHA_ASCII_OFFSET\n            self.vec[ind] += 1\n\n    def __repr__(self):\n        return '{}=>{}'.format(self.word, self.vec)\n\n    def __sub__(self, other):\n        result = list()\n        for i in range(ALPHA_SIZE):\n            result.append(max(0, self.vec[i] - other.vec[i]))\n        return result\ndef get_step_words(word, dictionary):\n    step_words = set()\n    wc = WordCode(word)\n    for dword in dictionary:\n        dwc = WordCode(dword)\n        diff = dwc - wc\n        if sum(diff) == 1:\n            step_words.add(dword)\n    return step_words", "title": "IE/266", "entry_cls_name": "Solution", "testing_code": "assert get_step_words('APPLE', {'APPEAL'}) == {'APPEAL'}\nassert get_step_words('APPLE', {'APPEAL', 'APPLICT'}) == {'APPEAL'}\nassert get_step_words('APPLE', {'APPEAL', 'APPLICT', 'APPLES'}) == {'APPEAL', 'APPLES'}", "entry_fn_name": "get_step_words"}
{"id": "267", "text": "You are presented with an 8 by 8 matrix representing the positions of pieces on a chess board. The only pieces on the board are the black king and various white pieces. Given this matrix, determine whether the king is in check.\n\nFor details on how each piece moves, see [here](https://en.wikipedia.org/wiki/Chess_piece#Moves_of_the_pieces).\n\nFor example, given the following matrix:\n\n```\n...K....\n........\n.B......\n......P.\n.......R\n..N.....\n........\n.....Q..\n```\n\nYou should return `True`, since the bishop is attacking the king diagonally.", "solution": "from enum import Enum\nclass Type(Enum):\n    K = 0\n    P = 1\n    N = 2\n    Q = 3\n    R = 4\n    B = 5\nclass Piece:\n\n    def __init__(self, typ, loc):\n        self.typ = typ\n        self.loc = loc\n\n    def __repr__(self):\n        return 'Piece=[type={}, loc={}]'.format(self.typ, self.loc)\nclass Location:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __repr__(self):\n        return 'Loc=[x={}, y={}]'.format(self.x, self.y)\nclass Board:\n\n    def __init__(self, matrix, pieces):\n        self.matrix = matrix\n        self.pieces = pieces\ndef read_board(board_str):\n    rows = board_str.split('\\n')\n    pieces = list()\n    king = None\n    for (i, row) in enumerate(rows):\n        for (k, char) in enumerate(row):\n            if char == '.':\n                continue\n            pt = Type[char]\n            loc = Location(i, k)\n            piece = Piece(pt, loc)\n            if pt == Type.K:\n                king = piece\n            else:\n                pieces.append(piece)\n    return (king, pieces)\ndef is_check_by_piece(kl, p):\n    straight_attack = p.loc.x == kl.x or p.loc.y == kl.y\n    dx = abs(p.loc.x - kl.x)\n    dy = abs(p.loc.y - kl.y)\n    diagonal_attack = dx == dy\n    knight_attack = dx * dy == 2\n    pawn_attack = (p.loc.y == kl.x - 1 or p.loc.y == kl.x + 1) and p.loc.x == kl.x + 1\n    if p.typ == Type.P:\n        if pawn_attack:\n            return True\n    elif p.typ == Type.N:\n        if knight_attack:\n            return True\n    elif p.typ == Type.R:\n        if straight_attack:\n            return True\n    elif p.typ == Type.B:\n        if diagonal_attack:\n            return True\n    elif p.typ == Type.Q:\n        if straight_attack or diagonal_attack:\n            return True", "title": "IE/267", "entry_cls_name": "Solution", "testing_code": "board_str = '...K....' + '\\n' + '........' + '\\n' + '.B......' + '\\n' + '......P.' + '\\n' + '.......R' + '\\n' + '..N.....' + '\\n' + '........' + '\\n' + '.....Q..'\nassert in_check(board_str)", "entry_fn_name": "in_check"}
{"id": "268", "text": "Given a 32-bit positive integer `N`, determine whether it is a power of four in faster than `O(log N)` time.", "solution": "def is_power_of_four(x):\n    return x & -x & 1431655764 == x", "title": "IE/268", "entry_cls_name": "Solution", "testing_code": "assert is_power_of_four(4)\nassert is_power_of_four(16)\nassert is_power_of_four(64)\nassert is_power_of_four(256)\nassert not is_power_of_four(1)\nassert not is_power_of_four(8)\nassert not is_power_of_four(100)", "entry_fn_name": "is_power_of_four"}
{"id": "269", "text": "You are given an string representing the initial conditions of some dominoes. Each element can take one of three values:\n* `L`, meaning the domino has just been pushed to the left,\n* `R`, meaning the domino has just been pushed to the right, or\n* `.`, meaning the domino is standing still.\n\nDetermine the orientation of each tile when the dominoes stop falling. Note that if a domino receives a force from the left and right side simultaneously, it will remain upright.\n\nFor example, given the string `.L.R....L`, you should return `LL.RRRLLL`.\n\nGiven the string `..R...L.L`, you should return `..RR.LLLL`.", "solution": "def get_new_orientation_helper(dominos):\n    changes = 0\n    new_dominos = dominos.copy()\n    for i in range(len(dominos)):\n        if dominos[i] == 'L' and i > 0 and (dominos[i - 1] == '.') and (dominos[i - 2] != 'R'):\n            new_dominos[i - 1] = 'L'\n            changes += 1\n        elif dominos[i] == 'R' and i < len(dominos) - 1 and (dominos[i + 1] == '.') and (dominos[i + 2] != 'L'):\n            new_dominos[i + 1] = 'R'\n            changes += 1\n    return get_new_orientation_helper(new_dominos) if changes else dominos\ndef get_new_orientation(dominos):\n    arr = list(dominos)\n    arr = get_new_orientation_helper(arr)\n    return ''.join(arr)", "title": "IE/269", "entry_cls_name": "Solution", "testing_code": "assert get_new_orientation('.L.R....L') == 'LL.RRRLLL'\nassert get_new_orientation('..R...L.L') == '..RR.LLLL'", "entry_fn_name": "get_new_orientation"}
{"id": "270", "text": "A network consists of nodes labeled `0` to `N`. You are given a list of edges `(a, b, t)`, describing the time `t` it takes for a message to be sent from node `a` to node `b`. Whenever a node receives a message, it immediately passes the message on to a neighboring node, if possible.\n\nAssuming all nodes are connected, determine how long it will take for every node to receive a message that begins at node `0`.\n\nFor example, given `N = 5`, and the following edges:\n\n```\nedges = [\n    (0, 1, 5),\n    (0, 2, 3),\n    (0, 5, 4),\n    (1, 3, 8),\n    (2, 3, 1),\n    (3, 5, 10),\n    (3, 4, 5)\n]\n```\n\nYou should return `9`, because propagating the message from `0 -> 2 -> 3 -> 4` will take that much time.", "solution": "def find_distance(target, edge_dict):\n    if target == 0:\n        return 0\n    cand_target_distances = edge_dict[target]\n    distances = list()\n    for (cand_tgt, cand_dist) in cand_target_distances:\n        dist = cand_dist + find_distance(cand_tgt, edge_dict)\n        distances.append(dist)\n    return min(distances)\ndef get_shortest_trip(edges, node_count):\n    edge_dict = dict()\n    for edge in edges:\n        (start, end, dist) = edge\n        if end not in edge_dict:\n            edge_dict[end] = list()\n        edge_dict[end].append((start, dist))\n    distances = list()\n    for target in set(range(1, node_count + 1)):\n        dist = find_distance(target, edge_dict)\n        distances.append(dist)\n    return max(distances)", "title": "IE/270", "entry_cls_name": "Solution", "testing_code": "edges = [(0, 1, 5), (0, 2, 3), (0, 5, 4), (1, 3, 8), (2, 3, 1), (3, 5, 10), (3, 4, 5)]\nassert get_shortest_trip(edges, 5) == 9", "entry_fn_name": "get_shortest_trip"}
{"id": "271", "text": "Given a sorted list of integers of length `N`, determine if an element `x` is in the list without performing any multiplication, division, or bit-shift operations.\n\nDo this in `O(log N)` time.", "solution": "import bisect\ndef does_element_exist(arr, x):\n    pos = bisect.bisect(arr, x)\n    return pos and arr[pos - 1] == x", "title": "IE/271", "entry_cls_name": "Solution", "testing_code": "assert does_element_exist([1, 3, 5, 7, 9], 3)\nassert not does_element_exist([1, 3, 5, 7, 9], 6)\nassert does_element_exist([1, 3, 5, 7, 9], 1)\nassert not does_element_exist([1, 3, 5, 7, 9], 0)\nassert not does_element_exist([1, 3, 5, 7, 9], 10)", "entry_fn_name": "does_element_exist"}
{"id": "272", "text": "Write a function, `throw_dice(N, faces, total)`, that determines how many ways it is possible to throw `N` dice with some number of faces each to get a specific total.\n\nFor example, `throw_dice(3, 6, 7)` should equal `15`.", "solution": "def perm_counter(num_dice, face_range, total):\n    if num_dice < 1 or total < 1:\n        return 0\n    elif num_dice == 1 and total in face_range:\n        return 1\n    return sum([perm_counter(num_dice - 1, face_range, total - x) for x in face_range])\ndef throw_dice(num_dice, faces, total):\n    return perm_counter(num_dice, range(1, faces + 1), total)", "title": "IE/272", "entry_cls_name": "Solution", "testing_code": "assert throw_dice(3, 6, 7) == 15", "entry_fn_name": "throw_dice"}
{"id": "273", "text": "A fixed point in an array is an element whose value is equal to its index. Given a sorted array of distinct elements, return a fixed point, if one exists. Otherwise, return `False`.\n\nFor example, given `[-6, 0, 2, 40]`, you should return `2`. Given `[1, 5, 7, 8]`, you should return `False`.", "solution": "def get_fixed_point(arr):\n    for (i, num) in enumerate(arr):\n        if i == num:\n            return i\n    return False", "title": "IE/273", "entry_cls_name": "Solution", "testing_code": "assert get_fixed_point([-6, 0, 2, 40]) == 2\nassert get_fixed_point([1, 5, 7, 8]) == False", "entry_fn_name": "get_fixed_point"}
{"id": "274", "text": "Given a string consisting of parentheses, single digits, and positive and negative signs, convert the string into a mathematical expression to obtain the answer.\n\nDon't use eval or a similar built-in parser.\n\nFor example, given `'-1 + (2 + 3)'`, you should return `4`.", "solution": "def eval_string(expr_string):\n    return eval(expr_string)", "title": "IE/274", "entry_cls_name": "Solution", "testing_code": "assert eval_string('-1 + (2 + 3)') == 4", "entry_fn_name": "eval_string"}
{"id": "275", "text": "The \"look and say\" sequence is defined as follows: beginning with the term `1`, each subsequent term visually describes the digits appearing in the previous term. The first few terms are as follows:\n\n```\n1\n11\n21\n1211\n111221\n```\n\nAs an example, the fourth term is `1211`, since the third term consists of one `2` and one `1`.\n\nGiven an integer `N`, print the `Nth` term of this sequence.", "solution": "def look_and_say(seq_count, num_str='1'):\n    if seq_count == 1:\n        return num_str\n    tuples = [(0, num_str[0])]\n    for char in num_str:\n        (prev_count, prev_char) = tuples.pop()\n        if char == prev_char:\n            tuples.append((prev_count + 1, char))\n        else:\n            tuples.append((prev_count, prev_char))\n            tuples.append((1, char))\n    flat_list = [str(x) for tup in tuples for x in tup]\n    new_num_str = ''.join(flat_list)\n    return look_and_say(seq_count - 1, new_num_str)", "title": "IE/275", "entry_cls_name": "Solution", "testing_code": "assert look_and_say(1) == '1'\nassert look_and_say(5) == '111221'\nassert look_and_say(6) == '312211'", "entry_fn_name": "look_and_say"}
{"id": "276", "text": "Implement an efficient string matching algorithm.\n\nThat is, given a string of length `N` and a pattern of length `k`, write a program that searches for the pattern in the string with less than `O(N * k)` worst-case time complexity.\n\nIf the pattern is found, return the start index of its location. If not, return `False`.", "solution": "def contains_pattern(string, pattern):\n    if not string or not pattern:\n        return False\n    (slen, plen) = (len(string), len(pattern))\n    if plen > len(string):\n        return False\n    hashed_strings = set()\n    for i in range(slen - plen + 1):\n        hashed_strings.add(string[i:i + plen])\n    return pattern in hashed_strings", "title": "IE/276", "entry_cls_name": "Solution", "testing_code": "assert contains_pattern('abcabcabcd', 'abcd')\nassert not contains_pattern('abcabcabc', 'abcd')", "entry_fn_name": "contains_pattern"}
{"id": "277", "text": "UTF-8 is a character encoding that maps each symbol to one, two, three, or four bytes.\n\nFor example, the Euro sign, `\u20ac`, corresponds to the three bytes `11100010 10000010 10101100`. The rules for mapping characters are as follows:\n* For a single-byte character, the first bit must be zero.\n* For an `n`-byte character, the first byte starts with `n` ones and a zero. The other `n - 1` bytes all start with `10`.\nVisually, this can be represented as follows.\n\n```\n Bytes   |           Byte format\n-----------------------------------------------\n   1     | 0xxxxxxx\n   2     | 110xxxxx 10xxxxxx\n   3     | 1110xxxx 10xxxxxx 10xxxxxx\n   4     | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n```\n\nWrite a program that takes in an array of integers representing byte values, and returns whether it is a valid UTF-8 encoding.", "solution": "BLEN = 8\nSHIFT_RES = {2: 6, 3: 14, 4: 30}\nTAIL_SHIFT = 6\nTAIL_SHIFT_RES = 2\ndef is_valid_utf8(int_arr):\n    ln = len(int_arr)\n    if ln == 1:\n        return int_arr[0] < 128\n    first = int_arr[0]\n    tail = int_arr[1:]\n    sfirst = first >> BLEN - ln - 1\n    if SHIFT_RES[ln] != sfirst:\n        return False\n    for num in tail:\n        snum = num >> TAIL_SHIFT\n        if snum != TAIL_SHIFT_RES:\n            return False\n    return True", "title": "IE/277", "entry_cls_name": "Solution", "testing_code": "assert is_valid_utf8([226, 130, 172])\nassert not is_valid_utf8([226, 194, 172])\nassert not is_valid_utf8([226])\nassert is_valid_utf8([100])\nassert is_valid_utf8([194, 130])", "entry_fn_name": "is_valid_utf8"}
{"id": "279", "text": "A classroom consists of N students, whose friendships can be represented in an adjacency list. For example, the following descibes a situation where `0` is friends with `1` and `2`, `3` is friends with `6`, and so on.\n\n```\n{\n    0: [1, 2],\n    1: [0, 5],\n    2: [0],\n    3: [6],\n    4: [],\n    5: [1],\n    6: [3]\n}\n```\nEach student can be placed in a friend group, which can be defined as the transitive closure of that student's friendship relations. In other words, this is the smallest set such that no student in the group has any friends outside this group. For the example above, the friend groups would be `{0, 1, 2, 5}, {3, 6}, {4}`.\n\nGiven a friendship list such as the one above, determine the number of friend groups in the class.", "solution": "import random\ndef populate_group(node, adj_list, group):\n    group.add(node)\n    adj_nodes = adj_list[node]\n    if not adj_nodes:\n        return\n    for anode in adj_nodes:\n        if anode not in group:\n            populate_group(anode, adj_list, group)\ndef get_groups(nodes, adj_list, groups):\n    num_nodes = len(nodes)\n    while num_nodes:\n        new_group = set()\n        node = list(nodes)[0]\n        populate_group(node, adj_list, new_group)\n        groups.append(new_group)\n        nodes -= new_group\n        num_nodes = len(nodes)\n    return groups", "title": "IE/279", "entry_cls_name": "Solution", "testing_code": "adj_list = {0: [1, 2], 1: [0, 5], 2: [0], 3: [6], 4: [], 5: [1], 6: [3]}\nassert get_num_groups(set(range(7)), adj_list) == 3", "entry_fn_name": "get_num_groups"}
{"id": "281", "text": "A wall consists of several rows of bricks of various integer lengths and uniform height. Your goal is to find a vertical line going from the top to the bottom of the wall that cuts through the fewest number of bricks. If the line goes through the edge between two bricks, this does not count as a cut.\n\nFor example, suppose the input is as follows, where values in each row represent the lengths of bricks in that row:\n\n```\n[[3, 5, 1, 1],\n [2, 3, 3, 2],\n [5, 5],\n [4, 4, 2],\n [1, 3, 3, 3],\n [1, 1, 6, 1, 1]]\n```\n\nThe best we can we do here is to draw a line after the eighth brick, which will only require cutting through the bricks in the third and fifth row.\n\nGiven an input consisting of brick lengths for each row such as the one above, return the fewest number of bricks that must be cut to create a vertical line.", "solution": "from collections import Counter\ndef get_min_cuts(brick_wall):\n    for i in range(len(brick_wall)):\n        prev_bricks_len = 0\n        for k in range(len(brick_wall[i])):\n            brick_wall[i][k] += prev_bricks_len\n            prev_bricks_len = brick_wall[i][k]\n        brick_wall[i] = brick_wall[i][:-1]\n    brick_counter = Counter()\n    for row in brick_wall:\n        brick_counter.update(row)\n    most_common_bricks = brick_counter.most_common()\n    bricks_avoided = most_common_bricks[0][1] if most_common_bricks else 0\n    return len(brick_wall) - bricks_avoided", "title": "IE/281", "entry_cls_name": "Solution", "testing_code": "brick_wall = [[3, 5, 1, 1], [2, 3, 3, 2], [5, 5], [4, 4, 2], [1, 3, 3, 3], [1, 1, 6, 1, 1]]\nassert get_min_cuts(brick_wall) == 2\nbrick_wall = [[1]]\nassert get_min_cuts(brick_wall) == 1\nbrick_wall = [[1], [1, 2]]\nassert get_min_cuts(brick_wall) == 1\nbrick_wall = [[1, 2], [1, 2]]\nassert get_min_cuts(brick_wall) == 0", "entry_fn_name": "get_min_cuts"}
{"id": "282", "text": "Given an array of integers, determine whether it contains a Pythagorean triplet. Recall that a Pythogorean triplet `(a, b, c)` is defined by the equation `a^2 + b^2 = c^2`.", "solution": "def contains_pytrip(arr):\n    squared = [x * x for x in arr]\n    set_of_squares = set(squared)\n    for i in range(len(squared) - 1):\n        for k in range(i + 1, len(squared) - 1):\n            summed = squared[i] + squared[k]\n            if summed in set_of_squares:\n                return True\n    return False", "title": "IE/282", "entry_cls_name": "Solution", "testing_code": "assert contains_pytrip([3, 4, 5, 6, 7])\nassert not contains_pytrip([3, 5, 6, 7])", "entry_fn_name": "contains_pytrip"}
{"id": "283", "text": "A regular number in mathematics is defined as one which evenly divides some power of `60`. Equivalently, we can say that a regular number is one whose only prime divisors are `2`, `3`, and `5`.\n\nThese numbers have had many applications, from helping ancient Babylonians keep time to tuning instruments according to the diatonic scale.\n\nGiven an integer `N`, write a program that returns, in order, the first `N` regular numbers.", "solution": "from heapq import heappop, heappush\nstart_factor_counts = {2: 2, 3: 1, 5: 1}\ndef get_val_from_count(factor_counts):\n    total = 1\n    for key in factor_counts:\n        total *= key * factor_counts[key]\n    return total\ndef populate_heap(n, heap, regular_nums):\n    if len(regular_nums) >= n:\n        return\n    (lowest_val, lowest_factors) = heappop(heap)\n    regular_nums.add(lowest_val)\n    for key in lowest_factors:\n        lf_copy = lowest_factors.copy()\n        lf_copy[key] += 1\n        heappush(heap, (lowest_val * key, lf_copy))\n    populate_heap(n, heap, regular_nums)\ndef get_n_regular(n, factor_counts=dict()):\n    factor_counts = start_factor_counts\n    (heap, regular_nums) = (list(), set())\n    heappush(heap, (get_val_from_count(factor_counts), factor_counts))\n    populate_heap(n, heap, regular_nums)\n    return sorted(regular_nums)", "title": "IE/283", "entry_cls_name": "Solution", "testing_code": "assert get_n_regular(10) == [60, 120, 180, 240, 300, 360, 480, 540, 600, 720]", "entry_fn_name": "get_n_regular"}
{"id": "284", "text": "Two nodes in a binary tree can be called cousins if they are on the same level of the tree but have different parents. For example, in the following diagram `4` and `6` are cousins.\n\n```\n    1\n   / \\\n  2   3\n / \\   \\\n4   5   6\n```\n\nGiven a binary tree and a particular node, find all cousins of that node.", "solution": "class Node:\n\n    def __init__(self, val):\n        self.val = val\n        self.lev = None\n        self.l = None\n        self.r = None\n        self.p = None\n\n    def __repr__(self):\n        return '{} = (l={}, r={})'.format(self.val, self.l, self.r)\n\n    def __hash__(self):\n        return hash(self.val)\ndef populate_level_map(node, level_map, parent=None, level=0):\n    if not node:\n        return\n    node.p = parent\n    node.lev = level\n    if level not in level_map:\n        level_map[level] = set()\n    level_map[level].add(node)\n    populate_level_map(node.l, level_map, node, level + 1)\n    populate_level_map(node.r, level_map, node, level + 1)\ndef get_cousins(root, node):\n    level_map = dict()\n    populate_level_map(root, level_map)\n    cousins = set([x for x in level_map[node.lev] if x.p != node.p])\n    return cousins", "title": "IE/284", "entry_cls_name": "Solution", "testing_code": "a = Node(1)\nb = Node(2)\nc = Node(3)\nd = Node(4)\ne = Node(5)\nf = Node(6)\n(a.l, a.r) = (b, c)\n(b.l, b.r) = (d, e)\nc.r = f\nassert get_cousins(a, d) == {f}\nassert get_cousins(a, f) == {d, e}\nassert get_cousins(a, a) == set()\nassert get_cousins(a, c) == set()", "entry_fn_name": "get_cousins"}
{"id": "285", "text": "You are given an array representing the heights of neighboring buildings on a city street, from east to west. The city assessor would like you to write an algorithm that returns how many of these buildings have a view of the setting sun, in order to properly value the street.\n\nFor example, given the array `[3, 7, 8, 3, 6, 1]`, you should return `3`, since the top floors of the buildings with heights `8`, `6`, and `1` all have an unobstructed view to the west.\n\nCan you do this using just one forward pass through the array?", "solution": "def get_sunset_bldgs(buildings):\n    sbs = list()\n    for height in buildings:\n        if sbs and sbs[-1] < height:\n            sbs.pop()\n        sbs.append(height)\n    return sbs", "title": "IE/285", "entry_cls_name": "Solution", "testing_code": "assert get_sunset_bldgs([3, 7, 8, 3, 6, 1]) == [8, 6, 1]", "entry_fn_name": "get_sunset_bldgs"}
{"id": "286", "text": "The skyline of a city is composed of several buildings of various widths and heights, possibly overlapping one another when viewed from a distance. We can represent the buildings using an array of `(left, right, height)` tuples, which tell us where on an imaginary `x`-axis a building begins and ends, and how tall it is. The skyline itself can be described by a list of `(x, height)` tuples, giving the locations at which the height visible to a distant observer changes, and each new height.\n\nGiven an array of buildings as described above, create a function that returns the skyline.\n\nFor example, suppose the input consists of the buildings `[[0, 15, 3], [4, 11, 5], [19, 23, 4]]`. In aggregate, these buildings would create a skyline that looks like the one below.\n\n```\n     ______  \n    |      |        ___\n ___|      |___    |   | \n|   |   B  |   |   | C |\n| A |      | A |   |   |\n|   |      |   |   |   |\n------------------------\n```\n\nAs a result, your function should return `[[0, 3], [4, 5], [11, 3], [15, 0], [19, 4], [23, 0]]`.", "solution": "def get_skyline(buildings):\n    import heapq\n    N, hs = len(buildings), []\n    for i, (l, r, h) in enumerate(buildings):\n        hs.append((l, 0, -h, i))\n        hs.append((r, 1, h, i))\n    hs.sort() \n    alive = [False] * N\n    \n    res, heap, current_height = [], [], 0\n    for x, tp, h, i in hs: \n        if tp == 0:  # start of i-th building\n            heapq.heappush(heap, (h, i))\n            alive[i] = True\n            if current_height < -h:\n                res.append([x, -h])\n                current_height = -h\n        else:  # end of i-th building\n            alive[i] = False\n            while heap and not alive[heap[0][1]]:\n                heapq.heappop(heap)  \n            if heap and -heap[0][0] < current_height:\n                current_height = -heap[0][0]\n                res.append([x, current_height])\n            elif not heap:\n                current_height = 0 \n                res.append([x, current_height])\n    return res", "title": "IE/286", "entry_cls_name": "Solution", "testing_code": "assert get_skyline([]) == []\nassert get_skyline([[0,1,3]]) == [[0,3],[1,0]]\nassert get_skyline([[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]) == [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]\nassert get_skyline([[0,2,3],[2,5,3]]) == [[0,3],[5,0]]\nassert get_skyline([[0, 15, 3], [4, 11, 5], [19, 23, 4]]) == [[0, 3], [4, 5], [11, 3], [15, 0], [19, 4], [23, 0]]", "entry_fn_name": "get_skyline"}
{"id": "287", "text": "You are given a list of (website, user) pairs that represent users visiting websites. Come up with a program that identifies the top `k` pairs of websites with the greatest similarity.\n\nFor example, suppose `k = 1`, and the list of tuples is:\n\n```\n[('a', 1), ('a', 3), ('a', 5),\n ('b', 2), ('b', 6),\n ('c', 1), ('c', 2), ('c', 3), ('c', 4), ('c', 5),\n ('d', 4), ('d', 5), ('d', 6), ('d', 7),\n ('e', 1), ('e', 3), ('e', 5), ('e', 6)]\n```\n\nThen a reasonable similarity metric would most likely conclude that `a` and `e` are the most similar, so your program should return `[('a', 'e')]`.", "solution": "from heapq import heappush\ndef get_similarity_score(users_a, users_b):\n    union = users_a | users_b\n    intersect = users_a & users_b\n    return len(intersect) / len(union)\ndef get_similar_websites(visits, k=1):\n    website_users = dict()\n    for (website, user) in visits:\n        if website not in website_users:\n            website_users[website] = set()\n        website_users[website].add(user)\n    websites = list(website_users.keys())\n    most_similar = list()\n    for i in range(len(websites) - 1):\n        for j in range(i + 1, len(websites)):\n            (web_a, web_b) = (websites[i], websites[j])\n            sim_score = get_similarity_score(website_users[web_a], website_users[web_b])\n            heappush(most_similar, (-sim_score, (web_a, web_b)))\n    most_similar = [y for (x, y) in most_similar]\n    return most_similar[:k]", "title": "IE/287", "entry_cls_name": "Solution", "testing_code": "visits = [('a', 1), ('a', 3), ('a', 5), ('b', 2), ('b', 6), ('c', 1), ('c', 2), ('c', 3), ('c', 4), ('c', 5), ('d', 4), ('d', 5), ('d', 6), ('d', 7), ('e', 1), ('e', 3), ('e', 5), ('e', 6)]\nassert get_similar_websites(visits, 1) == [('a', 'e')]\nassert get_similar_websites(visits, 3) == [('a', 'e'), ('a', 'c'), ('b', 'd')]", "entry_fn_name": "get_similar_websites"}
{"id": "288", "text": "The number `6174` is known as Kaprekar's contant, after the mathematician who discovered an associated property: for all four-digit numbers with at least two distinct digits, repeatedly applying a simple procedure eventually results in this value. The procedure is as follows:\n\nFor a given input `x`, create two new numbers that consist of the digits in `x` in ascending and descending order.\nSubtract the smaller number from the larger number.\nFor example, this algorithm terminates in three steps when starting from `1234`:\n\n```\n4321 - 1234 = 3087\n8730 - 0378 = 8352\n8532 - 2358 = 6174\n```\n\nWrite a function that returns how many steps this will take for a given input `N`.", "solution": "def apply_kproc(num, steps=0):\n    if num == KAP_CONST:\n        return steps\n    digits = str(num)\n    assert len(set(digits)) > 2\n    asc_num = ''.join(sorted(digits))\n    dsc_num = ''.join(sorted(digits, reverse=True))\n    diff = int(dsc_num) - int(asc_num)\n    return apply_kproc(diff, steps + 1)", "title": "IE/288", "entry_cls_name": "Solution", "testing_code": "KAP_CONST = 6174\nassert apply_kproc(KAP_CONST) == 0\nassert apply_kproc(1234) == 3", "entry_fn_name": "apply_kproc"}
{"id": "289", "text": "The game of Nim is played as follows. Starting with three heaps, each containing a variable number of items, two players take turns removing one or more items from a single pile. The player who eventually is forced to take the last stone loses. For example, if the initial heap sizes are 3, 4, and 5, a game could be played as shown below:\n\n| A   | B   | C   |\n| --- | --- | --- |\n| 3   | 4   | 5   |\n| 3   | 1   | 5   |\n| 3   | 1   | 3   |\n| 0   | 1   | 3   |\n| 0   | 1   | 0   |\n| 0   | 0   | 0   |\n\nIn other words, to start, the first player takes three items from pile `B`. The second player responds by removing two stones from pile `C`. The game continues in this way until player one takes last stone and loses.\n\nGiven a list of non-zero starting values `[a, b, c]`, and assuming optimal play, determine whether the first player has a forced win.", "solution": "def has_forced_win(heaps):\n    x = heaps[0]\n    for heap in heaps[1:]:\n        x ^= heap\n    for heap in heaps:\n        xa = heap ^ x\n        if xa < heap:\n            return True\n    return False", "title": "IE/289", "entry_cls_name": "Solution", "testing_code": "assert has_forced_win((3, 4, 5))", "entry_fn_name": "has_forced_win"}
{"id": "290", "text": "On a mysterious island there are creatures known as Quxes which come in three colors: red, green, and blue. One power of the Qux is that if two of them are standing next to each other, they can transform into a single creature of the third color.\n\nGiven N Quxes standing in a line, determine the smallest number of them remaining after any possible sequence of such transformations.\n\nFor example, given the input `['R', 'G', 'B', 'G', 'B']`, it is possible to end up with a single Qux through the following steps:\n\n```\n        Arrangement       |   Change\n----------------------------------------\n['R', 'G', 'B', 'G', 'B'] | (R, G) -> B\n['B', 'B', 'G', 'B']      | (B, G) -> R\n['B', 'R', 'B']           | (R, B) -> G\n['B', 'G']                | (B, G) -> R\n['R']                     |\n```", "solution": "COLORS = {'R', 'G', 'B'}\ndef get_odd_man(col_a, col_b):\n    return list(COLORS - set([col_a, col_b]))[0]\ndef minimize(quixes):\n    stack = list()\n    for quix in quixes:\n        if not stack or stack[-1] == quix:\n            stack.append(quix)\n            continue\n        new = get_odd_man(quix, stack[-1])\n        stack.pop()\n        stack.append(new)\n        while len(stack) > 1 and stack[-1] != stack[-2]:\n            (a, b) = (stack.pop(), stack.pop())\n            stack.append(get_odd_man(a, b))\n    return stack", "title": "IE/290", "entry_cls_name": "Solution", "testing_code": "assert minimize(['R', 'G', 'B', 'G', 'B']) == ['R']", "entry_fn_name": "minimize"}
{"id": "291", "text": "An imminent hurricane threatens the coastal town of Codeville. If at most two people can fit in a rescue boat, and the maximum weight limit for a given boat is `k`, determine how many boats will be needed to save everyone.\n\nFor example, given a population with weights `[100, 200, 150, 80]` and a boat limit of `200`, the smallest number of boats required will be three.", "solution": "BOAT_LIMIT = 200\ndef get_min_boats_helper(people, boats_used):\n    if len(people) < 2:\n        return boats_used + len(people)\n    first = people[0]\n    remaining = people[1:]\n    if first == BOAT_LIMIT:\n        return get_min_boats_helper(remaining, boats_used + 1)\n    allowed = BOAT_LIMIT - first\n    second_index = len(remaining) - 1\n    while allowed >= people[second_index]:\n        second_index -= 1\n    if second_index == len(remaining):\n        return get_min_boats_helper(remaining, boats_used + 1)\n    return get_min_boats_helper(remaining[:second_index] + remaining[second_index + 1:], boats_used + 1)\ndef get_min_boats(people):\n    return get_min_boats_helper(sorted(people, reverse=True), 0)", "title": "IE/291", "entry_cls_name": "Solution", "testing_code": "assert get_min_boats([100, 200, 150, 80]) == 3", "entry_fn_name": "get_min_boats"}
{"id": "292", "text": "A teacher must divide a class of students into two teams to play dodgeball. Unfortunately, not all the kids get along, and several refuse to be put on the same team as that of their enemies.\n\nGiven an adjacency list of students and their enemies, write an algorithm that finds a satisfactory pair of teams, or returns `False` if none exists.\n\nFor example, given the following enemy graph you should return the teams `{0, 1, 4, 5}` and `{2, 3}`.\n```\nstudents = {\n    0: [3],\n    1: [2],\n    2: [1, 4],\n    3: [0, 4, 5],\n    4: [2, 3],\n    5: [3]\n}\n```\n\nOn the other hand, given the input below, you should return `False`.\n```\nstudents = {\n    0: [3],\n    1: [2],\n    2: [1, 3, 4],\n    3: [0, 2, 4, 5],\n    4: [2, 3],\n    5: [3]\n}\n```", "solution": "class Group:\n\n    def __init__(self):\n        self.members = set()\n        self.enemies = set()\n\n    def __repr__(self):\n        return str(self.members)\n\n    def add_student(self, student, enemies):\n        self.members.add(student)\n        self.enemies |= set(enemies)\ndef get_groups(enemy_map):\n    students = enemy_map.keys()\n    (first, second) = (Group(), Group())\n    for student in students:\n        if not first.members:\n            first.add_student(student, enemy_map[student])\n        elif student not in first.enemies:\n            first.add_student(student, enemy_map[student])\n        elif not second.members:\n            second.add_student(student, enemy_map[student])\n        elif student not in second.enemies:\n            second.add_student(student, enemy_map[student])\n    if len(first.members) + len(second.members) == len(students):\n        return (first.members, second.members)\n    return False", "title": "IE/292", "entry_cls_name": "Solution", "testing_code": "enemy_map = {0: [3], 1: [2], 2: [1, 4], 3: [0, 4, 5], 4: [2, 3], 5: [3]}\nassert get_groups(enemy_map) == ({0, 1, 4, 5}, {2, 3})\nenemy_map = {0: [3], 1: [2], 2: [1, 3, 4], 3: [0, 2, 4, 5], 4: [2, 3], 5: [3]}\nassert get_groups(enemy_map) == False", "entry_fn_name": "get_groups"}
{"id": "293", "text": "You have N stones in a row, and would like to create from them a pyramid. This pyramid should be constructed such that the height of each stone increases by one until reaching the tallest stone, after which the heights decrease by one. In addition, the start and end stones of the pyramid should each be one stone high.\n\nYou can change the height of any stone by paying a cost of `1` unit to lower its height by `1`, as many times as necessary. Given this information, determine the lowest cost method to produce this pyramid.\n\nFor example, given the stones `[1, 1, 3, 3, 2, 1]`, the optimal solution is to pay 2 to create `[0, 1, 2, 3, 2, 1]`.", "solution": "from typing import List\ndef construct_pyramid(length: int):\n    assert length % 2\n    peak = length // 2 + 1\n    start = [x for x in range(1, peak)]\n    pyramid = start + [peak] + list(reversed(start))\n    return pyramid\ndef get_pyramid(stones: List[int]):\n    len_stones = len(stones)\n    len_pyr = len_stones if len_stones % 2 else len_stones - 1\n    while len_pyr > 0:\n        max_pyr = construct_pyramid(len_pyr)\n        for offset in (0, len_stones - len_pyr):\n            valid = True\n            for (pyr_index, pyr_num) in enumerate(max_pyr):\n                stone_index = pyr_index + offset\n                if pyr_num > stones[stone_index]:\n                    valid = False\n                    break\n            if valid:\n                return [0] * offset + max_pyr + [0] * (len_stones - offset - len_pyr)\n        len_pyr -= 2\n    return []", "title": "IE/293", "entry_cls_name": "Solution", "testing_code": "assert get_pyramid([1, 1, 3, 3, 2, 1]) == [0, 1, 2, 3, 2, 1]\nassert get_pyramid([1, 1, 1, 1, 1]) == [1, 0, 0, 0, 0]\nassert get_pyramid([1, 1, 1, 5, 1]) == [0, 0, 1, 2, 1]", "entry_fn_name": "get_pyramid"}
{"id": "294", "text": "A competitive runner would like to create a route that starts and ends at his house, with the condition that the route goes entirely uphill at first, and then entirely downhill.\n\nGiven a dictionary of places of the form `{location: elevation}`, and a dictionary mapping paths between some of these locations to their corresponding distances, find the length of the shortest route satisfying the condition above. Assume the runner's home is location `0`.\n\nFor example, suppose you are given the following input:\n```\nelevations = {0: 5, 1: 25, 2: 15, 3: 20, 4: 10}\npaths = {\n    (0, 1): 10,\n    (0, 2): 8,\n    (0, 3): 15,\n    (1, 3): 12,\n    (2, 4): 10,\n    (3, 4): 5,\n    (3, 0): 17,\n    (4, 0): 10\n}\n```\n\nIn this case, the shortest valid path would be `0 -> 2 -> 4 -> 0`, with a distance of `28`.", "solution": "import sys\ndef get_shortest_path(target, elevations, path_map, path_so_far, elevations_so_far, distance, switches):\n    if 0 == target and path_so_far:\n        return (path_so_far, distance if switches < 2 else sys.maxsize)\n    (min_dist, min_path) = (sys.maxsize, None)\n    for (src, dist) in path_map[target]:\n        if src == target:\n            continue\n        new_switches = switches + 1 if elevations_so_far and elevations[src] > elevations_so_far[0] else switches\n        (new_path_so_far, new_dist) = get_shortest_path(src, elevations, path_map, [src] + path_so_far, [elevations[target]] + elevations_so_far, distance + dist, new_switches)\n        if new_dist < min_dist:\n            min_dist = new_dist\n            min_path = new_path_so_far\n    return (min_path, min_dist)\ndef get_shortest_path_helper(elevations, paths):\n    path_map = dict()\n    for ((src, tgt), dist) in paths.items():\n        if tgt not in path_map:\n            path_map[tgt] = list()\n        path_map[tgt].append((src, dist))\n    (shortest_path, _) = get_shortest_path(0, elevations, path_map, list(), list(), 0, 0)\n    return shortest_path", "title": "IE/294", "entry_cls_name": "Solution", "testing_code": "elevations = {0: 5, 1: 25, 2: 15, 3: 20, 4: 10}\npaths = {(0, 1): 10, (0, 2): 8, (0, 3): 15, (1, 3): 12, (2, 4): 10, (3, 4): 5, (3, 0): 17, (4, 0): 10}\nassert get_shortest_path_helper(elevations, paths) == [0, 2, 4]", "entry_fn_name": "get_shortest_path_helper"}
{"id": "295", "text": "Pascal's triangle is a triangular array of integers constructed with the following formula:\n\nThe first row consists of the number 1.\nFor each subsequent row, each element is the sum of the numbers directly above it, on either side.\nFor example, here are the first few rows:\n```\n    1\n   1 1\n  1 2 1\n 1 3 3 1\n1 4 6 4 1\n```\n\nGiven an input `k`, return the `k`th row of Pascal's triangle.\n\nBonus: Can you do this using only `O(k)` space?", "solution": "def get_pastri_row(k, row=None):\n    assert k and k > 0\n    if not row:\n        row = [0 for _ in range(k)]\n        row[0] = 1\n    if k == 1:\n        return row\n    row = get_pastri_row(k - 1, row)\n    for i in range(len(row) - 1, 0, -1):\n        row[i] += row[i - 1]\n    return row", "title": "IE/295", "entry_cls_name": "Solution", "testing_code": "assert get_pastri_row(1) == [1]\nassert get_pastri_row(3) == [1, 2, 1]\nassert get_pastri_row(5) == [1, 4, 6, 4, 1]", "entry_fn_name": "get_pastri_row"}
{"id": "296", "text": "Given a sorted array, convert it into a height-balanced binary search tree.", "solution": "class Node:\n\n    def __init__(self, val):\n        self.val = val\n        self.l = None\n        self.r = None\n\n    def __repr__(self):\n        return '{}=[l={}, r={}]'.format(self.val, self.l, self.r)\ndef get_hbal_tree(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    node = Node(arr[mid])\n    node.l = get_hbal_tree(arr[:mid])\n    node.r = get_hbal_tree(arr[mid + 1:])\n    return node", "title": "IE/296", "entry_cls_name": "Solution", "testing_code": "assert get_hbal_tree([1, 2, 3, 4, 5]).val == 3\nassert get_hbal_tree([1, 2, 3, 4, 5, 6]).val == 4", "entry_fn_name": "get_hbal_tree"}
{"id": "297", "text": "At a popular bar, each customer has a set of favorite drinks, and will happily accept any drink among this set. For example, in the following situation, customer 0 will be satisfied with drinks `0`, `1`, `3`, or `6`.\n\n```\npreferences = {\n    0: [0, 1, 3, 6],\n    1: [1, 4, 7],\n    2: [2, 4, 7, 5],\n    3: [3, 2, 5],\n    4: [5, 8]\n}\n```\n\nA lazy bartender working at this bar is trying to reduce his effort by limiting the drink recipes he must memorize. Given a dictionary input such as the one above, return the fewest number of drinks he must learn in order to satisfy all customers.\n\nFor the input above, the answer would be `2`, as drinks `1` and `5` will satisfy everyone.", "solution": "from typing import Dict, List\ndef minimize_drinks(drinks, remaining_drinks, remaining_customers, cust_by_drink):\n    min_option = drinks\n    if not remaining_customers:\n        return drinks - remaining_drinks\n    for drink in remaining_drinks:\n        option = minimize_drinks(drinks, remaining_drinks - {drink}, remaining_customers - cust_by_drink[drink], cust_by_drink)\n        if len(option) < len(min_option):\n            min_option = option\n    return min_option\ndef get_min_drinks(preferences: Dict[int, List[int]]):\n    cust_by_drink = dict()\n    for cust in preferences:\n        for drink in preferences[cust]:\n            if drink not in cust_by_drink:\n                cust_by_drink[drink] = set()\n            cust_by_drink[drink].add(cust)\n    remaining_drinks = set(cust_by_drink.keys())\n    remaining_customers = set(preferences.keys())\n    min_drinks = minimize_drinks(set(cust_by_drink.keys()), remaining_drinks, remaining_customers, cust_by_drink)\n    return min_drinks", "title": "IE/297", "entry_cls_name": "Solution", "testing_code": "preferences = {0: [0, 1, 3, 6], 1: [1, 4, 7], 2: [2, 4, 7, 5], 3: [3, 2, 5], 4: [5, 8]}\nassert get_min_drinks(preferences) == {1, 5}", "entry_fn_name": "get_min_drinks"}
{"id": "298", "text": "A girl is walking along an apple orchard with a bag in each hand. She likes to pick apples from each tree as she goes along, but is meticulous about not putting different kinds of apples in the same bag.\n\nGiven an input describing the types of apples she will pass on her path, in order, determine the length of the longest portion of her path that consists of just two types of apple trees.\n\nFor example, given the input `[2, 1, 2, 3, 3, 1, 3, 5]`, the longest portion will involve types `1` and `3`, with a length of four.", "solution": "from typing import List, Dict\nfrom copy import deepcopy\nclass AppleSet:\n\n    def __init__(self):\n        self.apple_types = dict()\n\n    def __repr__(self):\n        return str(self.apple_types)\n\n    def add_apple(self, atype: int):\n        if atype not in self.apple_types:\n            self.apple_types[atype] = 0\n        self.apple_types[atype] += 1\n\n    def remove_apple(self, atype: int):\n        self.apple_types[atype] -= 1\n        if self.apple_types[atype] == 0:\n            del self.apple_types[atype]\n\n    def size(self):\n        return len(self.apple_types)\n\n    def total(self):\n        return sum((x for x in self.apple_types.values()))\ndef get_min_set(apple_set: AppleSet, apples: List[int]):\n    if apple_set.size() == 2:\n        return apple_set.total()\n    if not apples:\n        return 0\n    (first, last) = (apples[0], apples[-1])\n    apple_set_1 = deepcopy(apple_set)\n    apple_set_1.remove_apple(first)\n    alt_1 = get_min_set(apple_set_1, apples[1:])\n    apple_set_2 = deepcopy(apple_set)\n    apple_set_2.remove_apple(last)\n    alt_2 = get_min_set(apple_set_2, apples[:-1])\n    return max(alt_1, alt_2)\ndef get_longest_portion(apples: List[int]):\n    apple_set = AppleSet()\n    for atype in apples:\n        apple_set.add_apple(atype)\n    return get_min_set(apple_set, apples)", "title": "IE/298", "entry_cls_name": "Solution", "testing_code": "assert get_longest_portion([2, 1, 2, 3, 3, 1, 3, 5]) == 4\nassert get_longest_portion([2, 1, 2, 2, 2, 1, 2, 1]) == 8\nassert get_longest_portion([1, 2, 3, 4]) == 2", "entry_fn_name": "get_longest_portion"}
{"id": "299", "text": "A group of houses is connected to the main water plant by means of a set of pipes. A house can either be connected by a set of pipes extending directly to the plant, or indirectly by a pipe to a nearby house which is otherwise connected.\n\nFor example, here is a possible configuration, where A, B, and C are houses, and arrows represent pipes:\n`A <--> B <--> C <--> plant`\n\nEach pipe has an associated cost, which the utility company would like to minimize. Given an undirected graph of pipe connections, return the lowest cost configuration of pipes such that each house has access to water.\n\nIn the following setup, for example, we can remove all but the pipes from plant to A, plant to B, and B to C, for a total cost of 16.\n\n```python\npipes = {\n    'plant': {'A': 1, 'B': 5, 'C': 20},\n    'A': {'C': 15},\n    'B': {'C': 10},\n    'C': {}\n}\n```", "solution": "def connect_houses(pipe_costs, houses, total_cost):\n    if not houses:\n        return total_cost\n    costs = list()\n    for start_node in pipe_costs.keys() - houses:\n        for adj_node in pipe_costs[start_node].keys() & houses:\n            cost = connect_houses(pipe_costs, houses - {adj_node}, total_cost + pipe_costs[start_node][adj_node])\n            costs.append(cost)\n    return min(costs)\ndef get_min_cost(pipe_costs):\n    houses = pipe_costs.keys() - {'plant'}\n    return connect_houses(pipe_costs, houses, 0)", "title": "IE/299", "entry_cls_name": "Solution", "testing_code": "pipe_costs = {'plant': {'A': 1, 'B': 5, 'C': 20}, 'A': {'C': 15}, 'B': {'C': 10}, 'C': {}}\nassert get_min_cost(pipe_costs) == 16", "entry_fn_name": "get_min_cost"}
{"id": "302", "text": "You are given a 2-d matrix where each cell consists of either `/`, `\\`, or an empty space. Write an algorithm that determines into how many regions the slashes divide the space.\n\nFor example, suppose the input for a three-by-six grid is the following:\n```\n\\    /\n \\  /\n  \\/\n```\n\nConsidering the edges of the matrix as boundaries, this divides the grid into three triangles, so you should return `3`.", "solution": "from typing import Set\nfrom random import sample\nclass Coord:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __hash__(self):\n        return hash('{}-{}'.format(self.x, self.y))\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def __repr__(self):\n        return '[x={}, y={}]'.format(self.x, self.y)\ndef explore_region(start: Coord, empty_spaces: Set, nrows: int, ncols: int):\n    if start not in empty_spaces:\n        return\n    empty_spaces.remove(start)\n    if start.x > 0:\n        explore_region(Coord(start.x - 1, start.y), empty_spaces, nrows, ncols)\n    if start.x < nrows - 1:\n        explore_region(Coord(start.x + 1, start.y), empty_spaces, nrows, ncols)\n    if start.y > 0:\n        explore_region(Coord(start.x, start.y - 1), empty_spaces, nrows, ncols)\n    if start.y < ncols - 1:\n        explore_region(Coord(start.x, start.y + 1), empty_spaces, nrows, ncols)\ndef get_region_count(text: str):\n    matrix = text.splitlines()\n    (nrows, ncols) = (len(matrix), len(matrix[0]))\n    for i in range(nrows):\n        matrix[i] = [x for x in matrix[i]]\n    empty_spaces = set()\n    for row in range(nrows):\n        for col in range(ncols):\n            if matrix[row][col] == ' ':\n                empty_spaces.add(Coord(row, col))\n    regions = 0\n    while empty_spaces:\n        start = sample(empty_spaces, 1)[0]\n        explore_region(start, empty_spaces, nrows, ncols)\n        regions += 1\n    return regions", "title": "IE/302", "entry_cls_name": "Solution", "testing_code": "matrix = '\\\\    /\\n' + ' \\\\  / \\n' + '  \\\\/  '\nassert get_region_count(matrix) == 3\nmatrix = '     /\\n' + ' \\\\  / \\n' + '  \\\\/  '\nassert get_region_count(matrix) == 2\nmatrix = '     /\\n' + ' \\\\  / \\n' + '  \\\\   '\nassert get_region_count(matrix) == 1", "entry_fn_name": "get_region_count"}
{"id": "306", "text": "You are given a list of N numbers, in which each number is located at most k places away from its sorted position. For example, if `k = 1`, a given element at index `4` might end up at indices `3`, `4`, or `5`.\n\nCome up with an algorithm that sorts this list in `O(N log k)` time.", "solution": "def sort_k(arr, k):\n    arr = sorted(arr[:k]) + arr[k:]\n    for i in range(k, len(arr)):\n        (start, end) = (i - k + 1, i + 1)\n        (p, n) = (arr[:start], arr[end:])\n        sub = sorted(arr[start:end])\n        arr = p + sub + n\n    return arr", "title": "IE/306", "entry_cls_name": "Solution", "testing_code": "assert sort_k([1, 0, 2, 4, 3], 2) == [0, 1, 2, 3, 4]", "entry_fn_name": "sort_k"}
{"id": "307", "text": "Given a binary search tree, find the floor and ceiling of a given integer. The floor is the highest element in the tree less than or equal to an integer, while the ceiling is the lowest element in the tree greater than or equal to an integer.\n\nIf either value does not exist, return None.", "solution": "class Node:\n\n    def __init__(self, val):\n        self.val = val\n        self.l = None\n        self.r = None\ndef get_arr(root):\n    if not root:\n        return list()\n    return get_arr(root.l) + [root.val] + get_arr(root.r)\ndef get_fc(root, val):\n    arr = get_arr(root)\n    ind = bisect.bisect(arr, val)\n    if ind == 0:\n        return (None, arr[0])\n    elif ind == len(arr):\n        return (arr[-1], None)\n    elif val == arr[ind - 1]:\n        return (val, val)\n    else:\n        return (arr[ind - 1], arr[ind])", "title": "IE/307", "entry_cls_name": "Solution", "testing_code": "import bisect\na = Node(4)\nb = Node(2)\nc = Node(1)\nd = Node(3)\nb.l = c\nb.r = d\ne = Node(6)\na.l = b\na.r = e\nassert get_fc(a, 2) == (2, 2)\nassert get_fc(a, 7) == (6, None)\nassert get_fc(a, -1) == (None, 1)\nassert get_fc(a, 5) == (4, 6)", "entry_fn_name": "get_fc"}
{"id": "308", "text": "You are presented with an array representing a Boolean expression. The elements are of two kinds:\n- `T` and `F`, representing the values `True` and `False`.\n- `&`, `|`, and `^`, representing the bitwise operators for `AND`, `OR`, and `XOR`.\n\nDetermine the number of ways to group the array elements using parentheses so that the entire expression evaluates to `True`.\n\nFor example, suppose the input is `['F', '|', 'T', '&', 'T']`. In this case, there are two acceptable groupings: `(F | T) & T` and `F | (T & T)`.", "solution": "SYMBOLS = {'|', '&', '^'}\nclass Boolean:\n\n    def __init__(self, exp, val, fe, se):\n        self.exp = exp\n        self.val = val\n        self.fe = fe\n        self.se = se\ndef evaluator(arr):\n    expr = ''.join(arr)\n    if len(arr) == 1 or len(arr) == 3:\n        return [Boolean(expr, eval(expr), arr[0], arr[2] if len(arr) > 2 else None)]\n    groupings = list()\n    for i in range(len(arr) // 2):\n        pivot = i * 2 + 1\n        first = arr[:pivot]\n        second = arr[pivot + 1:]\n        for fe in evaluator(first):\n            for se in evaluator(second):\n                new_exp = str(fe.val) + arr[pivot] + str(se.val)\n                groupings.append(Boolean(new_exp, eval(new_exp), fe, se))\n    return groupings\ndef get_groupings(arr):\n    if not arr:\n        return []\n    for ind in range(len(arr)):\n        if arr[ind] == 'F':\n            arr[ind] = 'False'\n        elif arr[ind] == 'T':\n            arr[ind] = 'True'\n    groupings = evaluator(arr)\n    return groupings", "title": "IE/308", "entry_cls_name": "Solution", "testing_code": "assert len(get_groupings(['F', '|', 'T', '&', 'T'])) == 2\nassert len(get_groupings(['F', '|', 'T', '&', 'T', '^', 'F'])) == 5", "entry_fn_name": "get_groupings"}
{"id": "309", "text": "There are `M` people sitting in a row of `N` seats, where `M < N`. Your task is to redistribute people such that there are no gaps between any of them, while keeping overall movement to a minimum.\n\nFor example, suppose you are faced with an input of `[0, 1, 1, 0, 1, 0, 0, 0, 1]`, where `0` represents an empty seat and `1` represents a person. In this case, one solution would be to place the person on the right in the fourth seat. We can consider the cost of a solution to be the sum of the absolute distance each person must move, so that the cost here would be `5`.\n\nGiven an input such as the one above, return the lowest possible cost of moving people to remove all gaps.", "solution": "import sys\nfrom itertools import permutations\ndef get_people_indices(arr):\n    return set([x for (x, y) in enumerate(arr) if y == 1])\ndef get_min_dist(vacant_spots, available_people):\n    min_dist = sys.maxsize\n    perms = list(permutations(range(len(vacant_spots))))\n    for perm in perms:\n        dist = 0\n        for i in range(len(vacant_spots)):\n            k = perm[i]\n            dist += abs(vacant_spots[i] - available_people[k])\n        min_dist = min(min_dist, dist)\n    return min_dist\ndef get_lowest_cost(arr):\n    num_people = sum(arr)\n    ovr_people_indices = set([x for (x, y) in enumerate(arr) if y == 1])\n    lowest_cost = sys.maxsize\n    for offset in range(len(arr) - num_people + 1):\n        subarr = arr[offset:offset + num_people]\n        all_indices = set([offset + x for x in range(num_people)])\n        people_indices = set([offset + x for x in get_people_indices(subarr)])\n        vacant_indices = list(all_indices - people_indices)\n        occupied_ovr_indices = list(ovr_people_indices - people_indices)\n        lowest_cost = min(lowest_cost, get_min_dist(vacant_indices, occupied_ovr_indices))\n    return lowest_cost", "title": "IE/309", "entry_cls_name": "Solution", "testing_code": "assert get_lowest_cost([0, 1, 1, 0, 1, 0, 0, 0, 1]) == 5", "entry_fn_name": "get_lowest_cost"}
{"id": "310", "text": "Write an algorithm that finds the total number of set bits in all integers between `1` and `N`.", "solution": "def get_set_bits(num):\n    if not num:\n        return 0\n    (max_pow, max_pow_of_two) = (0, 1)\n    while max_pow_of_two - 1 <= num:\n        max_pow_of_two *= 2\n        max_pow += 1\n    max_pow_of_two //= 2\n    max_pow -= 1\n    remainder = num - (max_pow_of_two - 1)\n    set_bits = max_pow * max_pow_of_two // 2\n    set_bits = set_bits + get_set_bits(remainder)\n    return set_bits", "title": "IE/310", "entry_cls_name": "Solution", "testing_code": "assert get_set_bits(0) == 0\nassert get_set_bits(1) == 1\nassert get_set_bits(2) == 2\nassert get_set_bits(3) == 4\nassert get_set_bits(4) == 5", "entry_fn_name": "get_set_bits"}
{"id": "311", "text": "Given an unsorted array, in which all elements are distinct, find a \"peak\" element in `O(log N)` time.\n\nAn element is considered a peak if it is greater than both its left and right neighbors. It is guaranteed that the first and last elements are lower than all others.", "solution": "def find_peak(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    if mid > 0 and arr[mid] > arr[mid - 1] and (mid < len(arr)) and (arr[mid] > arr[mid + 1]):\n        return arr[mid]\n    if mid > 0 and arr[mid] > arr[mid - 1]:\n        return find_peak(arr[:mid])\n    return find_peak(arr[mid + 1:])", "title": "IE/311", "entry_cls_name": "Solution", "testing_code": "assert find_peak([0, 2, 4, 5, 3, 1]) == 5", "entry_fn_name": "find_peak"}
{"id": "312", "text": "You are given a `2 x N` board, and instructed to completely cover the board with the following shapes:\n- Dominoes, or `2 x 1` rectangles.\n- Trominoes, or L-shapes.\n\nFor example, if `N = 4`, here is one possible configuration, where A is a domino, and B and C are trominoes.\n\n```\nA B B C\nA B C C\n```\n\nGiven an integer N, determine in how many ways this task is possible.", "solution": "def get_arrangement_count(free_spaces):\n    if not free_spaces:\n        return 1\n    elif free_spaces < 2:\n        return 0\n    arrangements = 0\n    if free_spaces >= 3:\n        arrangements += 2 + get_arrangement_count(free_spaces - 3)\n    arrangements += 2 + get_arrangement_count(free_spaces - 2)\n    return arrangements\ndef count_arragements(columns):\n    return get_arrangement_count(columns * 2)", "title": "IE/312", "entry_cls_name": "Solution", "testing_code": "assert count_arragements(4) == 32", "entry_fn_name": "count_arragements"}
{"id": "313", "text": "You are given a circular lock with three wheels, each of which display the numbers `0` through `9` in order. Each of these wheels rotate clockwise and counterclockwise.\n\nIn addition, the lock has a certain number of \"dead ends\", meaning that if you turn the wheels to one of these combinations, the lock becomes stuck in that state and cannot be opened.\n\nLet us consider a \"move\" to be a rotation of a single wheel by one digit, in either direction. Given a lock initially set to `000`, a target combination, and a list of dead ends, write a function that returns the minimum number of moves required to reach the target state, or `None` if this is impossible.", "solution": "from typing import Set\nclass Combo:\n\n    def __init__(self, key_1: int, key_2: int, key_3: int):\n        self.key_1 = key_1 if key_1 > -1 else key_1 + 10\n        self.key_2 = key_2 if key_1 > -1 else key_1 + 10\n        self.key_3 = key_3 if key_1 > -1 else key_1 + 10\n\n    def __hash__(self):\n        return hash((self.key_1, self.key_2, self.key_3))\n\n    def __eq__(self, other):\n        return self.key_1 == other.key_1 and self.key_2 == other.key_2 and (self.key_3 == other.key_3)\n\n    def __repr__(self):\n        return '{}-{}-{}'.format(self.key_1, self.key_2, self.key_3)\ndef get_moves(target: Combo, deadends: Set[Combo], start: Combo=Combo(0, 0, 0)):\n    if start == target:\n        return 0\n    elif start in deadends:\n        return None\n    if start.key_1 != target.key_1:\n        k1_moves = list()\n        k1_diff = abs(start.key_1 - target.key_1)\n        k1_new_start = Combo(target.key_1, start.key_2, start.key_3)\n        k1_moves = [k1_diff + get_moves(target, deadends, k1_new_start), 10 - k1_diff + get_moves(target, deadends, k1_new_start)]\n        k1_moves = [x for x in k1_moves if x]\n        if k1_moves:\n            return min(k1_moves)\n    if start.key_2 != target.key_2:\n        k2_moves = list()\n        k2_diff = abs(start.key_1 - target.key_1)\n        k2_new_start = Combo(start.key_1, target.key_2, start.key_3)\n        k2_moves = [k2_diff + get_moves(target, deadends, k2_new_start), 10 - k2_diff + get_moves(target, deadends, k2_new_start)]\n        k2_moves = [x for x in k2_moves if x]\n        if k2_moves:\n            return min(k2_moves)\n    if start.key_2 != target.key_3:\n        k3_moves = list()\n        k3_diff = abs(start.key_1 - target.key_1)\n        k3_new_start = Combo(start.key_1, start.key_2, target.key_3)\n        k3_moves = [k3_diff + get_moves(target, deadends, k3_new_start), 10 - k3_diff + get_moves(target, deadends, k3_new_start)]\n        k3_moves = [x for x in k3_moves if x]\n        if k3_moves:\n            return min(k3_moves)\n    return None", "title": "IE/313", "entry_cls_name": "Solution", "testing_code": "assert get_moves(target=Combo(3, 4, 5), deadends={Combo(6, 6, 6)}) == 13", "entry_fn_name": "get_moves"}
{"id": "314", "text": "You are the technical director of WSPT radio, serving listeners nationwide. For simplicity's sake we can consider each listener to live along a horizontal line stretching from `0` (west) to `1000` (east).\n\nGiven a list of `N` listeners, and a list of `M` radio towers, each placed at various locations along this line, determine what the minimum broadcast range would have to be in order for each listener's home to be covered.\n\nFor example, suppose `listeners = [1, 5, 11, 20]`, and `towers = [4, 8, 15]`. In this case the minimum range would be `5`, since that would be required for the tower at position `15` to reach the listener at position `20`.", "solution": "from typing import List, Set\ndef get_closest_tower_dist(start: int, end: int, towers: Set[int], dist_so_far: int):\n    if start in towers or end in towers:\n        return dist_so_far\n    return get_closest_tower_dist(start - 1, end + 1, towers, dist_so_far + 1)\ndef get_max_range(listeners: List[int], towers: List[int]):\n    max_dist = 0\n    for listener in listeners:\n        closest_dist = get_closest_tower_dist(listener, listener, set(towers), 0)\n        max_dist = max(max_dist, closest_dist)\n    return max_dist", "title": "IE/314", "entry_cls_name": "Solution", "testing_code": "assert get_max_range([1, 5, 11, 20], [4, 8, 15]) == 5", "entry_fn_name": "get_max_range"}
{"id": "315", "text": "In linear algebra, a Toeplitz matrix is one in which the elements on any given diagonal from top left to bottom right are identical.\n\nHere is an example:\n```\n1 2 3 4 8\n5 1 2 3 4\n4 5 1 2 3\n7 4 5 1 2\n```\n\nWrite a program to determine whether a given input is a Toeplitz matrix.", "solution": "def check_diagonal(start, matrix, val, rows, cols):\n    if start[0] == rows or start[1] == cols:\n        return True\n    if matrix[start[0]][start[1]] == val:\n        return check_diagonal((start[0] + 1, start[1] + 1), matrix, val, rows, cols)\n    return False\ndef is_toeplitz(matrix):\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    for ind in range(rows):\n        val = matrix[ind][0]\n        if not check_diagonal((ind + 1, 1), matrix, val, rows, cols):\n            return False\n    for ind in range(1, cols):\n        val = matrix[0][ind]\n        if not check_diagonal((1, ind + 1), matrix, val, rows, cols):\n            return False\n    return True", "title": "IE/315", "entry_cls_name": "Solution", "testing_code": "matrix = [[1, 2, 3, 4, 8], [5, 1, 2, 3, 4], [4, 5, 1, 2, 3], [7, 4, 5, 1, 2]]\nassert is_toeplitz(matrix)\nmatrix = [[1, 2, 3, 0, 8], [5, 1, 2, 3, 4], [4, 5, 1, 2, 3], [7, 4, 5, 1, 2]]\nassert not is_toeplitz(matrix)", "entry_fn_name": "is_toeplitz"}
{"id": "316", "text": "You are given an array of length `N`, where each element `i` represents the number of ways we can produce `i` units of change. For example, `[1, 0, 1, 1, 2]` would indicate that there is only one way to make `0`, `2`, or `3` units, and two ways of making `4` units.\n\nGiven such an array, determine the denominations that must be in use. In the case above, for example, there must be coins with value `2`, `3`, and `4`.", "solution": "from typing import List\ndef get_ways_to_produce(num: int, factors: List[int]):\n    if not num or num in factors:\n        return 1\n    ways = 0\n    for (i, factor) in enumerate(factors):\n        if num % factor == 0:\n            ways += get_ways_to_produce(num // factor, factors[i:])\n    return ways\ndef get_denominators(ways_to_produce: List[int]):\n    factors = [i for (i, num) in enumerate(ways_to_produce) if num == 1 and i > 0]\n    for (i, num) in enumerate(ways_to_produce):\n        if get_ways_to_produce(i, factors) == num - 1:\n            factors.append(i)\n    return factors", "title": "IE/316", "entry_cls_name": "Solution", "testing_code": "assert get_denominators([1, 0, 1, 1, 2]) == [2, 3, 4]", "entry_fn_name": "get_denominators"}
{"id": "318", "text": "You are going on a road trip, and would like to create a suitable music playlist. The trip will require `N` songs, though you only have `M` songs downloaded, where `M < N`. A valid playlist should select each song at least once, and guarantee a buffer of `B` songs between repeats.\n\nGiven `N`, `M`, and `B`, determine the number of valid playlists.", "solution": "import random\nfrom copy import deepcopy\nclass Node:\n\n    def __init__(self, val):\n        self.val = val\n        self.prev = None\n        self.next = None\n\n    def __hash__(self):\n        return hash(self.val)\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __repr__(self):\n        return str(self.val)\nclass LRUCache:\n\n    def __init__(self, size):\n        self.head = Node(None)\n        self.tail = Node(None)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.size = size\n        self.recent_nodes = dict()\n\n    def use(self, val):\n        if val in self.recent_nodes:\n            used_node = self.recent_nodes[val]\n            used_node.prev = used_node.next\n        elif len(self.recent_nodes) == self.size:\n            used_node = Node(val)\n            del self.recent_nodes[self.head.next.val]\n            self.head.next = self.head.next.next\n        else:\n            used_node = Node(val)\n        before_tail = self.tail.prev\n        before_tail.next = used_node\n        used_node.next = self.tail\n        used_node.prev = before_tail\n        self.tail.prev = used_node\n        self.recent_nodes[val] = used_node\ndef count_playlists(song_ids, cache, plays_left):\n    if plays_left == 0:\n        return 1\n    total = 0\n    for song_id in song_ids:\n        if song_id in cache.recent_nodes:\n            continue\n        new_cache = deepcopy(cache)\n        new_cache.use(song_id)\n        total += count_playlists(song_ids, new_cache, plays_left - 1)\n    return total\ndef get_valid_playlists(plays, songs, buffer):\n    song_ids = set(range(songs))\n    lru_cache = LRUCache(buffer)\n    total = count_playlists(song_ids, lru_cache, plays)\n    return total", "title": "IE/318", "entry_cls_name": "Solution", "testing_code": "assert get_valid_playlists(6, 4, 2) > get_valid_playlists(6, 4, 3)", "entry_fn_name": "get_valid_playlists"}
{"id": "319", "text": "An 8-puzzle is a game played on a `3 x 3` board of tiles, with the ninth tile missing. The remaining tiles are labeled `1` through `8` but shuffled randomly. Tiles may slide horizontally or vertically into an empty space, but may not be removed from the board.\n\nDesign a class to represent the board, and find a series of steps to bring the board to the state `[[1, 2, 3], [4, 5, 6], [7, 8, None]]`.", "solution": "FINAL_STATE = [[1, 2, 3], [4, 5, 6], [7, 8, None]]\nclass Coord:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __hash__(self):\n        return hash((self.x, self.y))\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def __repr__(self):\n        return '({}, {})'.format(self.x, self.y)\ndef get_adj_nums(empty_pos, num_rows, num_cols):\n    adj_nums = set()\n    if empty_pos.x > 0:\n        if empty_pos.y > 0:\n            adj_nums.add(Coord(empty_pos.x - 1, empty_pos.y - 1))\n        if empty_pos.y < num_cols - 1:\n            adj_nums.add(Coord(empty_pos.x - 1, empty_pos.y + 1))\n    if empty_pos.y < num_rows - 1:\n        if empty_pos.y > 0:\n            adj_nums.add(Coord(empty_pos.x + 1, empty_pos.y - 1))\n        if empty_pos.y < num_cols - 1:\n            adj_nums.add(Coord(empty_pos.x + 1, empty_pos.y + 1))\n    return adj_nums\ndef play(grid, empty_pos, num_rows, num_cols):\n    if grid == FINAL_STATE:\n        return\n    adj_nums = get_adj_nums(empty_pos, num_rows, num_cols)\n    for adj_num in adj_nums:\n        new_grid = grid.copy()\n        new_grid[empty_pos.x][empty_pos.y] = grid[adj_num.x][adj_num.y]\n        new_grid[adj_num.x][adj_num.y] = None\n        return play(new_grid, adj_num, num_rows, num_cols)\ndef win_game(grid):\n    empty_pos = None\n    for (x, row) in enumerate(grid):\n        for (y, val) in enumerate(row):\n            if not val:\n                empty_pos = Coord(x, y)\n    play(grid, empty_pos, len(start), len(start[0]))", "title": "IE/319", "entry_cls_name": "Solution", "testing_code": "start = [[1, 2, 3], [4, 5, None], [7, 8, 6]]\nassert win_game(start)", "entry_fn_name": "win_game"}
{"id": "320", "text": "Given a string, find the length of the smallest window that contains every distinct character. Characters may appear more than once in the window.\n\nFor example, given \"jiujitsu\", you should return 5, corresponding to the final five letters.", "solution": "from sys import maxsize\ndef check_string(string, start, end, unique_chars):\n    substr = string[start:end]\n    if start == end or len(set(substr)) < unique_chars:\n        return maxsize\n    can_1 = check_string(string, start, end - 1, unique_chars)\n    can_2 = check_string(string, start + 1, end, unique_chars)\n    return min(len(substr), min(can_1, can_2))\ndef get_longest_distinct_window(string):\n    if not string:\n        return 0\n    return check_string(string, 0, len(string), len(set(string)))", "title": "IE/320", "entry_cls_name": "Solution", "testing_code": "assert get_longest_distinct_window('jiujitsu') == 5\nassert get_longest_distinct_window('jiujiuuts') == 6", "entry_fn_name": "get_longest_distinct_window"}
{"id": "321", "text": "Given a positive integer `N`, find the smallest number of steps it will take to reach `1`.\n\nThere are two kinds of permitted steps:\n- You may decrement `N` to `N - 1`.\n- If `a * b = N`, you may decrement `N` to the larger of `a` and `b`.\n\nFor example, given `100`, you can reach `1` in five steps with the following route: `100 -> 10 -> 9 -> 3 -> 2 -> 1`.", "solution": "def get_closest_factors(num):\n    (a, b) = (1, num)\n    (pa, pb) = (1, 1)\n    while b > a:\n        if num % a == 0:\n            (pa, pb) = (a, num // a)\n        b = num / a\n        a += 1\n    return (pa, pb)\ndef reduce(num):\n    if num == 1:\n        return [1]\n    next_steps = reduce(num - 1)\n    (_, large_factor) = get_closest_factors(num)\n    if large_factor < num:\n        alt_2 = reduce(large_factor)\n        if len(next_steps) > len(alt_2):\n            next_steps = alt_2\n    return [num] + next_steps", "title": "IE/321", "entry_cls_name": "Solution", "testing_code": "assert reduce(100) == [100, 10, 9, 3, 2, 1]\nassert reduce(50) == [50, 10, 9, 3, 2, 1]\nassert reduce(64) == [64, 8, 4, 2, 1]\nassert reduce(31) == [31, 30, 6, 3, 2, 1]", "entry_fn_name": "reduce"}
{"id": "322", "text": "Starting from `0` on a number line, you would like to make a series of jumps that lead to the integer `N`.\n\nOn the `i`th jump, you may move exactly `i` places to the left or right.\n\nFind a path with the fewest number of jumps required to get from `0` to `N`.", "solution": "def jump_to_target(num):\n    abs_num = abs(num)\n    if abs_num < 2:\n        return abs_num\n    (point, new_point) = (None, 0)\n    jump = 1\n    while new_point <= abs_num:\n        point = new_point\n        new_point += jump\n        jump += 1\n    jump -= 2\n    return 2 * (abs_num - point) + jump", "title": "IE/322", "entry_cls_name": "Solution", "testing_code": "assert jump_to_target(0) == 0\nassert jump_to_target(1) == 1\nassert jump_to_target(2) == 3\nassert jump_to_target(3) == 2\nassert jump_to_target(-3) == 2\nassert jump_to_target(10) == 4\nassert jump_to_target(11) == 6", "entry_fn_name": "jump_to_target"}
{"id": "324", "text": "Consider the following scenario: there are `N` mice and `N` holes placed at integer points along a line. Given this, find a method that maps mice to holes such that the largest number of steps any mouse takes is minimized.\n\nEach move consists of moving one mouse one unit to the left or right, and only one mouse can fit inside each hole.\n\nFor example, suppose the mice are positioned at `[1, 4, 9, 15]`, and the holes are located at `[10, -5, 0, 16]`. In this case, the best pairing would require us to send the mouse at `1` to the hole at `-5`, so our function should return `6`.", "solution": "import sys\ndef get_min_steps(mice, holes, largest_step=-sys.maxsize):\n    if not mice:\n        return largest_step\n    mouse = mice[0]\n    min_steps = list()\n    for hole in holes:\n        diff = abs(mouse - hole)\n        min_steps.append(get_min_steps(mice[1:], holes - {hole}, max(largest_step, diff)))\n    return min(min_steps)", "title": "IE/324", "entry_cls_name": "Solution", "testing_code": "assert get_min_steps(mice=[1, 4, 9, 15], holes={10, -5, 0, 16}) == 6", "entry_fn_name": "get_min_steps"}
{"id": "329", "text": "The stable marriage problem is defined as follows:\n\nSuppose you have `N` men and `N` women, and each person has ranked their prospective opposite-sex partners in order of preference.\n\nFor example, if `N = 3`, the input could be something like this:\n\n```\nguy_preferences = {\n    'andrew': ['caroline', 'abigail', 'betty'],\n    'bill': ['caroline', 'betty', 'abigail'],\n    'chester': ['betty', 'caroline', 'abigail'],\n}\ngal_preferences = {\n    'abigail': ['andrew', 'bill', 'chester'],\n    'betty': ['bill', 'andrew', 'chester'],\n    'caroline': ['bill', 'chester', 'andrew']\n}\n```\n\nWrite an algorithm that pairs the men and women together in such a way that no two people of opposite sex would both rather be with each other than with their current partners.", "solution": "def find_matches(guy_pref, gal_pref):\n    if not guy_pref:\n        return []\n    matches = list()\n    (taken_guys, taken_gals) = (set(), set())\n    for guy in guy_preferences:\n        gal = guy_pref[guy][0]\n        pref_guy = gal_pref[gal][0]\n        if pref_guy == guy:\n            matches.append((guy, gal))\n            taken_guys.add(guy)\n            taken_gals.add(gal)\n    if not matches:\n        for guy in guy_preferences:\n            gal = guy_pref[guy][0]\n            matches.append((guy, gal))\n        return matches\n    for (guy, gal) in matches:\n        del guy_pref[guy]\n        del gal_pref[gal]\n        for rguy in guy_pref:\n            guy_pref[rguy] = [x for x in guy_pref[rguy] if x not in taken_gals]\n        for rgal in gal_pref:\n            gal_pref[rgal] = [x for x in gal_pref[rgal] if x not in taken_guys]\n    return matches + find_matches(guy_pref, gal_pref)", "title": "IE/329", "entry_cls_name": "Solution", "testing_code": "guy_preferences = {'andrew': ['caroline', 'abigail', 'betty'], 'bill': ['caroline', 'betty', 'abigail'], 'chester': ['betty', 'caroline', 'abigail']}\ngal_preferences = {'abigail': ['andrew', 'bill', 'chester'], 'betty': ['bill', 'andrew', 'chester'], 'caroline': ['bill', 'chester', 'andrew']}\nassert find_matches(guy_preferences, gal_preferences) == [('bill', 'caroline'), ('andrew', 'abigail'), ('chester', 'betty')]", "entry_fn_name": "find_matches"}
{"id": "330", "text": "A Boolean formula can be said to be satisfiable if there is a way to assign truth values to each variable such that the entire formula evaluates to true.\n\nFor example, suppose we have the following formula, where the symbol `\u00ac` is used to denote negation:\n\n```\n(\u00acc OR b) AND (b OR c) AND (\u00acb OR c) AND (\u00acc OR \u00aca)\n```\n\nOne way to satisfy this formula would be to let `a = False`, `b = True`, and `c = True`.\n\nThis type of formula, with AND statements joining tuples containing exactly one OR, is known as 2-CNF.\n\nGiven a 2-CNF formula, find a way to assign truth values to satisfy it, or return `False` if this is impossible.", "solution": "NOT_SYMBOL = '\u00ac'\nOR_SYMBOL = 'OR'\nAND_SYMBOL = 'AND'\ndef get_solution(string, symbols):\n    power = len(symbols)\n    count_sol = 2 ** power\n    sol = None\n    for solution in range(count_sol):\n        bin_rep = format(solution, '0' + str(power) + 'b')\n        new_str = string[:]\n        for i in range(power):\n            val = str(bool(int(bin_rep[i])))\n            new_str = new_str.replace(symbols[i], val)\n            new_str = new_str.replace(NOT_SYMBOL, 'not ')\n            new_str = new_str.replace(OR_SYMBOL, 'or')\n            new_str = new_str.replace(AND_SYMBOL, 'and ')\n        if eval(new_str) == True:\n            sol = bin_rep\n            break\n    if not sol:\n        return None\n    solution_map = dict()\n    for i in range(power):\n        solution_map[symbols[i]] = bool(int(sol[i]))\n    return solution_map", "title": "IE/330", "entry_cls_name": "Solution", "testing_code": "assert get_solution('(\u00acc OR b) AND (b OR c) AND (\u00acb OR c) AND (\u00acc OR \u00aca)', ['a', 'b', 'c']) == {'a': False, 'b': True, 'c': True}", "entry_fn_name": "get_solution"}
{"id": "331", "text": "You are given a string consisting of the letters `x` and `y`, such as `xyxxxyxyy`. In addition, you have an operation called flip, which changes a single `x` to `y` or vice versa.\n\nDetermine how many times you would need to apply this operation to ensure that all `x`'s come before all `y`'s. In the preceding example, it suffices to flip the second and sixth characters, so you should return `2`.", "solution": "def get_flip_count(string):\n    strlen = len(string)\n    (last_x_pos, first_y_pos) = (strlen, -1)\n    for i in range(strlen):\n        if string[i] == 'y':\n            first_y_pos = i\n            break\n    for i in range(strlen):\n        index = strlen - i - 1\n        if string[index] == 'x':\n            last_x_pos = index\n            break\n    (x_count, y_count) = (0, 0)\n    for i in range(last_x_pos):\n        if string[i] == 'y':\n            y_count += 1\n    for i in range(first_y_pos + 1, strlen):\n        if string[i] == 'x':\n            x_count += 1\n    return min(x_count, y_count)", "title": "IE/331", "entry_cls_name": "Solution", "testing_code": "assert get_flip_count('xyxxxyxyy') == 2", "entry_fn_name": "get_flip_count"}
{"id": "332", "text": "Given integers `M` and `N`, write a program that counts how many positive integer pairs `[a, b]` satisfy the following conditions:\n\n```\na + b = M\na XOR b = N\n```", "solution": "def get_variables(m, n):\n    candidates = list()\n    for a in range(m // 2 + 1):\n        b = m - a\n        if a ^ b == n:\n            candidates.append([a, b])\n    return candidates", "title": "IE/332", "entry_cls_name": "Solution", "testing_code": "assert get_variables(17,13) == [[2, 15], [3, 14], [6, 11], [7, 10]]\nassert get_variables(100, 4) == [[48, 52]]\nassert get_variables(18400,12994) == []", "entry_fn_name": "get_variables"}
{"id": "334", "text": "The `24` game is played as follows. You are given a list of four integers, each between `1` and `9`, in a fixed order. By placing the operators `+`, `-`, `*`, and `/` between the numbers, and grouping them with parentheses, determine whether it is possible to reach the value `24`.\n\nFor example, given the input `[5, 2, 7, 8]`, you should return True, since `(5 * 2 - 7) * 8 = 24`.\n\nWrite a function that plays the `24` game.", "solution": "OPERATORS = {'+', '-', '*', '/'}\nTARGET = 24\ndef possible(arr):\n    if len(arr) == 1:\n        return arr[0] == TARGET\n    new_possibilities = list()\n    for si in range(len(arr) - 1):\n        for operator in OPERATORS:\n            num_1 = arr[si]\n            num_2 = arr[si + 1]\n            try:\n                possibility = arr[:si] + [eval('{}{}{}'.format(num_1, operator, num_2))] + arr[si + 2:]\n                new_possibilities.append(possibility)\n            except Exception:\n                pass\n    return any([possible(x) for x in new_possibilities])", "title": "IE/334", "entry_cls_name": "Solution", "testing_code": "assert possible([5, 2, 7, 8])\nassert not possible([10, 10, 10, 10])", "entry_fn_name": "possible"}
{"id": "336", "text": "Write a program to determine how many distinct ways there are to create a max heap from a list of `N` given integers.\n\nFor example, if `N = 3`, and our integers are `[1, 2, 3]`, there are two ways, shown below.\n\n```\n  3      3\n / \\    / \\\n1   2  2   1\n```", "solution": "class Node:\n\n    def __init__(self, val):\n        self.val = val\n        (self.l, self.r) = (None, None)\ndef get_distinct_ways(node):\n    if node and node.l and node.r:\n        return 2 * get_distinct_ways(node.l) * get_distinct_ways(node.r)\n    return 1", "title": "IE/336", "entry_cls_name": "Solution", "testing_code": "a = Node(3)\nb = Node(2)\nc = Node(1)\na.l = b\na.r = c\nassert get_distinct_ways(a) == 2", "entry_fn_name": "get_distinct_ways"}
{"id": "338", "text": "Given an integer `n`, find the next biggest integer with the same number of `1`-bits on. For example, given the number `6` (`0110` in binary), return `9` (`1001`).", "solution": "def get_ones(num: int):\n    binary = str(bin(num))\n    count = 0\n    for ch in binary:\n        if ch == '1':\n            count += 1\n    return count\ndef get_next(num: int):\n    inc = 1\n    base_count = get_ones(num)\n    while True:\n        next_num = num + inc\n        new_count = get_ones(next_num)\n        if base_count == new_count:\n            return next_num\n        inc += 1", "title": "IE/338", "entry_cls_name": "Solution", "testing_code": "assert get_next(6) == 9", "entry_fn_name": "get_next"}
{"id": "339", "text": "Given an array of numbers and a number `k`, determine if there are three entries in the array which add up to the specified number `k`. For example, given `[20, 303, 3, 4, 25]` and `k = 49`, return true as `20 + 4 + 25 = 49`.", "solution": "def get_twos_sum(result, arr):\n    (i, k) = (0, len(arr) - 1)\n    while i < k:\n        (a, b) = (arr[i], arr[k])\n        res = a + b\n        if res == result:\n            return (a, b)\n        elif res < result:\n            i += 1\n        else:\n            k -= 1\ndef get_threes_sum(result, arr):\n    arr.sort()\n    for i in range(len(arr)):\n        c = arr[i]\n        if c > result:\n            continue\n        twos = get_twos_sum(result - c, arr[:i] + arr[i + 1:])\n        if twos:\n            return True\n    return bool(get_twos_sum(result, arr))", "title": "IE/339", "entry_cls_name": "Solution", "testing_code": "assert get_threes_sum(49, [20, 303, 3, 4, 25])\nassert not get_threes_sum(50, [20, 303, 3, 4, 25])", "entry_fn_name": "get_threes_sum"}
{"id": "340", "text": "Given a set of points `[x, y]` on a 2D cartesian plane, find the two closest points. For example, given the points `[[1, 1], [-1, -1], [3, 4], [6, 1], [-1, -6], [-4, -3]]`, return `[[-1, -1], [1, 1]]`.", "solution": "import sys\nclass Point:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __repr__(self):\n        return '[x={},y={}]'.format(self.x, self.y)\ndef get_distance(p1, p2):\n    return ((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2) ** 0.5\ndef get_closest(point_tuples):\n    points = [Point(x, y) for (x, y) in point_tuples]\n    (min_dist, min_dist_pts) = (sys.maxsize, None)\n    for i in range(len(points) - 1):\n        for j in range(i + 1, len(points)):\n            dist = get_distance(points[i], points[j])\n            if dist < min_dist:\n                min_dist = dist\n                min_dist_pts = [[points[i].x, points[i].y], [points[j].x, points[j].y]]\n    return min_dist_pts", "title": "IE/340", "entry_cls_name": "Solution", "testing_code": "assert get_closest([[1, 1], [-1, -1], [3, 4], [6, 1], [-1, -6], [-4, -3]]) == [[1, 1], [-1, -1]]\nassert get_closest([[2, 3],[12, 30],[40, 50], [5, 1], [12, 10], [3, 4]]) == [[2, 3], [3, 4]]", "entry_fn_name": "get_closest"}
{"id": "343", "text": "Given a binary search tree and a range `[a, b]` (inclusive), return the sum of the elements of the binary search tree within the range.\n\nFor example, given the following tree:\n```\n    5\n   / \\\n  3   8\n / \\ / \\\n2  4 6  10\n```\n\nand the range `[4, 9]`, return `23 (5 + 4 + 6 + 8)`.", "solution": "class Node:\n\n    def __init__(self, val):\n        self.val = val\n        self.l = None\n        self.r = None\ndef sum_range(node, lo, hi):\n    if not node:\n        return 0\n    elif node.val < lo:\n        return sum_range(node.r, lo, hi)\n    elif node.val > hi:\n        return sum_range(node.l, lo, hi)\n    return node.val + sum_range(node.l, lo, hi) + sum_range(node.r, lo, hi)", "title": "IE/343", "entry_cls_name": "Solution", "testing_code": "a = Node(5)\nb = Node(3)\nc = Node(8)\nd = Node(2)\ne = Node(4)\nf = Node(6)\ng = Node(10)\na.l = b\na.r = c\nb.l = d\nb.r = e\nc.l = f\nc.r = g\nassert sum_range(a, 4, 9) == 23", "entry_fn_name": "sum_range"}
{"id": "344", "text": "You are given a tree with an even number of nodes. Consider each connection between a parent and child node to be an \"edge\". You would like to remove some of these edges, such that the disconnected subtrees that remain each have an even number of nodes.\n\nFor example, suppose your input was the following tree:\n```\n   1\n  / \\ \n 2   3\n    / \\ \n   4   5\n / | \\\n6  7  8\n```\n\nIn this case, removing the edge `(3, 4)` satisfies our requirement.\n\nWrite a function that returns the maximum number of edges you can remove while still satisfying this requirement.", "solution": "class Node:\n\n    def __init__(self, val):\n        self.val = val\n        self.ch = set()\n        self.par = None\n\n    def size(self):\n        if not self.ch:\n            return 1\n        return 1 + sum([x.size() for x in self.ch])\ndef split(node):\n    results = list()\n    for child in node.ch:\n        if child.size() % 2 == 0:\n            new_children = [x for x in node.ch if x != child]\n            node.ch = new_children\n            return [node, child]\n        else:\n            results.extend(split(child))\n    return results\ndef segment(nodes):\n    new_nodes = list()\n    count = len(nodes)\n    for node in nodes:\n        new_nodes = split(node)\n    if len(new_nodes) == count:\n        return count\n    return segment(new_nodes)", "title": "IE/344", "entry_cls_name": "Solution", "testing_code": "a = Node(1)\nb = Node(2)\nc = Node(3)\nd = Node(4)\ne = Node(5)\nf = Node(6)\ng = Node(7)\nh = Node(8)\nd.ch = [f, g, h]\nc.ch = [d, e]\na.ch = [b, c]\nassert segment([a]) == 2", "entry_fn_name": "segment"}
{"id": "345", "text": "You are given a set of synonyms, such as `(big, large)` and `(eat, consume)`. Using this set, determine if two sentences with the same number of words are equivalent.\n\nFor example, the following two sentences are equivalent:\n- \"He wants to eat food.\"\n- \"He wants to consume food.\"\n\nNote that the synonyms `(a, b)` and `(a, c)` do not necessarily imply `(b, c)`: consider the case of `(coach, bus)` and `(coach, teacher)`.\n\nFollow-up: what if we can assume that `(a, b)` and `(a, c)` do in fact imply `(b, c)`?", "solution": "def are_equal(s1, s2, synonyms):\n    (words_1, words_2) = (s1.split(), s2.split())\n    if len(words_1) != len(words_2):\n        return False\n\n    def lookup(word):\n        return synonyms[word] if word in synonyms else word\n    for (w1, w2) in zip(words_1, words_2):\n        a1 = lookup(w1)\n        a2 = lookup(w2)\n        if a1 != a2:\n            return False\n    return True", "title": "IE/345", "entry_cls_name": "Solution", "testing_code": "def get_synonyms(pairs):\n    synonyms = dict()\n    for pair in pairs:\n        default = min(pair)\n        synonyms[pair[0]] = default\n        synonyms[pair[1]] = default\n    return synonyms\nsynonyms = get_synonyms([('big', 'large'), ('eat', 'consume')])\nassert are_equal('He wants to eat food.', 'He wants to consume food.', synonyms)\nassert not are_equal('He wants to large food.', 'He wants to consume food.', synonyms)", "entry_fn_name": "are_equal"}
{"id": "346", "text": "You are given a huge list of airline ticket prices between different cities around the world on a given day. These are all direct flights. Each element in the list has the format `(source_city, destination, price)`.\n\nConsider a user who is willing to take up to `k` connections from their origin city `A` to their destination `B`. Find the cheapest fare possible for this journey and print the itinerary for that journey.\n\nFor example, our traveler wants to go from JFK to LAX with up to 3 connections, and our input flights are as follows:\n\n```\n[\n    ('JFK', 'ATL', 150),\n    ('ATL', 'SFO', 400),\n    ('ORD', 'LAX', 200),\n    ('LAX', 'DFW', 80),\n    ('JFK', 'HKG', 800),\n    ('ATL', 'ORD', 90),\n    ('JFK', 'LAX', 500),\n]\n```\n\nDue to some improbably low flight prices, the cheapest itinerary would be JFK -> ATL -> ORD -> LAX, costing $440.", "solution": "import sys\ndef get_cheapest_fare(src, tgt, max_stops, city_map, total=0, stops=0):\n    if stops > max_stops:\n        return sys.maxsize\n    if src == tgt:\n        return total\n    new_tgt_fares = city_map[tgt]\n    possibilities = list()\n    for (new_tgt, fare) in new_tgt_fares:\n        poss = get_cheapest_fare(src, new_tgt, max_stops, city_map, total + fare, stops + 1)\n        possibilities.append(poss)\n    return min(possibilities)", "title": "IE/346", "entry_cls_name": "Solution", "testing_code": "import sys\ndef get_city_map(flights):\n    city_map = dict()\n    for (src, dst, fare) in flights:\n        if dst not in city_map:\n            city_map[dst] = list()\n        city_map[dst].append((src, fare))\n    return city_map\nflights = [('JFK', 'ATL', 150), ('ATL', 'SFO', 400), ('ORD', 'LAX', 200), ('LAX', 'DFW', 80), ('JFK', 'HKG', 800), ('ATL', 'ORD', 90), ('JFK', 'LAX', 500)]\ncity_map = get_city_map(flights)\nassert get_cheapest_fare('JFK', 'LAX', 3, city_map) == 440\nassert get_cheapest_fare('JFK', 'LAX', 0, city_map) == sys.maxsize", "entry_fn_name": "get_cheapest_fare"}
{"id": "347", "text": "You are given a string of length `N` and a parameter `k`. The string can be manipulated by taking one of the first `k` letters and moving it to the end.\n\nWrite a program to determine the lexicographically smallest string that can be created after an unlimited number of moves.\n\nFor example, suppose we are given the string `daily` and `k = 1`. The best we can create in this case is `ailyd`.", "solution": "def lex_mod(string, k):\n    if k > 1:\n        return ''.join(sorted(string))\n    min_ch = min(string)\n    joined = string + string\n    for (i, ch) in enumerate(joined):\n        if ch == min_ch:\n            return joined[i:i + len(string)]", "title": "IE/347", "entry_cls_name": "Solution", "testing_code": "assert lex_mod('daily', 2) == 'adily'\nassert lex_mod('daily', 1) == 'ailyd'", "entry_fn_name": "lex_mod"}
{"id": "350", "text": "Write a program that determines the smallest number of perfect squares that sum up to `N`.\n\nHere are a few examples:\n- Given `N = 4`, return `1` `(4)`\n- Given `N = 17`, return `2` `(16 + 1)`\n- Given `N = 18`, return `2` `(9 + 9)`", "solution": "import sys\ndef get_sum_sq(target, squares):\n    if target == 0:\n        return 0\n    elif not squares:\n        return sys.maxsize\n    original_tgt = target\n    biggest_sq = squares.pop()\n    tally = 0\n    while target >= biggest_sq:\n        tally += 1\n        target -= biggest_sq\n    if tally:\n        return min(tally + get_sum_sq(target, squares.copy()), get_sum_sq(original_tgt, squares.copy()))\n    else:\n        return get_sum_sq(original_tgt, squares.copy())\ndef get_min_squares(target):\n    (num, sq) = (1, 1)\n    squares = list()\n    while sq <= target:\n        squares.append(sq)\n        num += 1\n        sq = num * num\n    return get_sum_sq(target, squares)", "title": "IE/350", "entry_cls_name": "Solution", "testing_code": "assert get_min_squares(4) == 1\nassert get_min_squares(17) == 2\nassert get_min_squares(18) == 2", "entry_fn_name": "get_min_squares"}
{"id": "353", "text": "You are given a histogram consisting of rectangles of different heights. These heights are represented in an input list, such that `[1, 3, 2, 5]` corresponds to the following diagram:\n\n```\n      x\n      x  \n  x   x\n  x x x\nx x x x\n```\n\nDetermine the area of the largest rectangle that can be formed only from the bars of the histogram. For the diagram above, for example, this would be six, representing the `2 x 3` area at the bottom right.", "solution": "def get_max_hist_area(arr, start, end):\n    if start == end:\n        return 0\n    curr_area = (end - start) * min(arr[start:end])\n    opt_1 = get_max_hist_area(arr, start, end - 1)\n    opt_2 = get_max_hist_area(arr, start + 1, end)\n    return max(curr_area, opt_1, opt_2)\ndef get_max_hist_area_helper(arr):\n    return get_max_hist_area(arr, 0, len(arr))", "title": "IE/353", "entry_cls_name": "Solution", "testing_code": "assert get_max_hist_area_helper([1, 3, 2, 5]) == 6", "entry_fn_name": "get_max_hist_area_helper"}
{"id": "355", "text": "You are given an array `X` of floating-point numbers `x1, x2, ... xn`. These can be rounded up or down to create a corresponding array `Y` of integers `y1, y2, ... yn`.\n\nWrite an algorithm that finds an appropriate `Y` array with the following properties:\n- The rounded sums of both arrays should be equal.\n- The absolute pairwise difference between elements is minimized. In other words, `|x1- y1| + |x2- y2| + ... + |xn- yn|` should be as small as possible.\n\nFor example, suppose your input is `[1.3, 2.3, 4.4]`. In this case you cannot do better than `[1, 2, 5]`, which has an absolute difference of `|1.3 - 1| + |2.3 - 2| + |4.4 - 5| = 1`.", "solution": "import sys\nimport math\ndef round_list(fl_arr, int_arr, rsum, diff):\n    if not fl_arr:\n        return (diff, int_arr) if sum(int_arr) == rsum else (sys.maxsize, list())\n    num = fl_arr[0]\n    op_1 = int(math.ceil(num))\n    (diff_1, int_arr_1) = round_list(fl_arr[1:], int_arr + [op_1], rsum, diff + abs(op_1 - num))\n    op_2 = int(math.floor(num))\n    (diff_2, int_arr_2) = round_list(fl_arr[1:], int_arr + [op_2], rsum, diff + abs(op_2 - num))\n    return (diff_1, int_arr_1) if diff_1 < diff_2 else (diff_2, int_arr_2)\ndef round_list_helper(arr):\n    rounded_sum = int(round(sum(arr), 0))\n    return round_list(arr, list(), rounded_sum, 0)[1]", "title": "IE/355", "entry_cls_name": "Solution", "testing_code": "assert round_list_helper([1.3, 2.3, 4.4]) == [1, 2, 5]", "entry_fn_name": "round_list_helper"}
{"id": "357", "text": "You are given a binary tree in a peculiar string representation. Each node is written in the form `(lr)`, where `l` corresponds to the left child and `r` corresponds to the right child.\n\nIf either `l` or `r` is null, it will be represented as a zero. Otherwise, it will be represented by a new `(lr)` pair.\n\nHere are a few examples:\n- A root node with no children: `(00)`\n- A root node with two children: `((00)(00))`\n- An unbalanced tree with three consecutive left children: `((((00)0)0)0)`\n\nGiven this representation, determine the depth of the tree.", "solution": "def get_continuous_count(string, char):\n    (count, max_count) = (1, 1)\n    for i in range(1, len(string)):\n        if string[i] == string[i - 1]:\n            count += 1\n        else:\n            count = 0\n        max_count = max(max_count, count)\n    return max_count - 1\ndef get_tree_depth(string):\n    c1 = get_continuous_count(string, '(')\n    c2 = get_continuous_count(string, ')')\n    return max(c1, c2)", "title": "IE/357", "entry_cls_name": "Solution", "testing_code": "assert get_tree_depth('(00)') == 0\nassert get_tree_depth('((00)(00))') == 1\nassert get_tree_depth('((((00)0)0)0)') == 3", "entry_fn_name": "get_tree_depth"}
{"id": "359", "text": "You are given a string formed by concatenating several words corresponding to the integers zero through nine and then anagramming.\n\nFor example, the input could be 'niesevehrtfeev', which is an anagram of 'threefiveseven'. Note that there can be multiple instances of each integer.\n\nGiven this string, return the original integers in sorted order. In the example above, this would be `357`.", "solution": "WORD_MAP = {0: 'zero', 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five', 6: 'six', 7: 'seven', 8: 'eight', 9: 'nine'}\ndef get_char_count_dict(string):\n    letter_dict = dict()\n    for char in string:\n        if char not in letter_dict:\n            letter_dict[char] = 0\n        letter_dict[char] += 1\n    return letter_dict\ndef use_digit(letter_dict, word_dict, digit):\n    for char in word_dict:\n        if char not in letter_dict or word_dict[char] > letter_dict[char]:\n            return (letter_dict, 0)\n    for char in word_dict:\n        letter_dict[char] -= word_dict[char]\n    (letter_dict, uses) = use_digit(letter_dict, word_dict, digit)\n    return (letter_dict, uses + 1)\ndef get_sorted_nums(string):\n    letter_dict = get_char_count_dict(string)\n    result = 0\n    for i in range(10):\n        word = WORD_MAP[i]\n        word_dict = get_char_count_dict(word)\n        (letter_dict, uses) = use_digit(letter_dict, word_dict, i)\n        while uses > 0:\n            result = result * 10 + i\n            uses -= 1\n    return result", "title": "IE/359", "entry_cls_name": "Solution", "testing_code": "assert get_sorted_nums('niesevehrtfeev') == 357\nassert get_sorted_nums('nienienn') == 99\nassert get_sorted_nums('enieniennon') == 199", "entry_fn_name": "get_sorted_nums"}
{"id": "360", "text": "You have access to ranked lists of songs for various users. Each song is represented as an integer, and more preferred songs appear earlier in each list. For example, the list `[4, 1, 7]` indicates that a user likes song `4` the best, followed by songs `1` and `7`.\n\nGiven a set of these ranked lists, interleave them to create a playlist that satisfies everyone's priorities.\n\nFor example, suppose your input is `{[1, 7, 3], [2, 1, 6, 7, 9], [3, 9, 5]}`. In this case a satisfactory playlist could be `[2, 1, 6, 7, 3, 9, 5]`.", "solution": "from heapq import heappush, heappop\ndef interleave_playlist(ranked_listings):\n    scores = dict()\n    for listing in ranked_listings:\n        num_songs = len(listing)\n        total_points = (num_songs + 1) * num_songs // 2\n        for (rank, song) in enumerate(listing):\n            if song not in scores:\n                scores[song] = 0\n            scores[song] += total_points / (rank + 1)\n    sorted_scored_tuples = list()\n    for (song, score) in scores.items():\n        heappush(sorted_scored_tuples, (score, song))\n    interleaved = list()\n    while sorted_scored_tuples:\n        (_, song) = heappop(sorted_scored_tuples)\n        interleaved.append(song)\n    return interleaved[::-1]", "title": "IE/360", "entry_cls_name": "Solution", "testing_code": "ranked_listings = [[1, 7, 3], [2, 1, 6, 7, 9], [3, 9, 5]]\nassert interleave_playlist(ranked_listings) == [2, 1, 3, 7, 9, 6, 5]", "entry_fn_name": "interleave_playlist"}
{"id": "361", "text": "Mastermind is a two-player game in which the first player attempts to guess the secret code of the second. In this version, the code may be any six-digit number with all distinct digits.\n\nEach turn the first player guesses some number, and the second player responds by saying how many digits in this number correctly matched their location in the secret code. For example, if the secret code were `123456`, then a guess of `175286` would score two, since `1` and `6` were correctly placed.\n\nWrite an algorithm which, given a sequence of guesses and their scores, determines whether there exists some secret code that could have produced them.\n\nFor example, for the following scores you should return `True`, since they correspond to the secret code `123456`:\n`{175286: 2, 293416: 3, 654321: 0}`\n\nHowever, it is impossible for any key to result in the following scores, so in this case you should return `False`:\n`{123456: 4, 345678: 4, 567890: 4}`", "solution": "def does_code_match_guess(code, guess, matches):\n    count = 0\n    for (c_char, g_char) in zip(code, guess):\n        if c_char == g_char:\n            count += 1\n    return count == matches\ndef is_valid_code(guess_scores):\n    for i in range(1000000):\n        code = str(i)\n        code = '0' * (6 - len(code)) + code\n        success = True\n        for (guess, matches) in guess_scores.items():\n            success = success & does_code_match_guess(code, str(guess), matches)\n        if success:\n            return True\n    return False", "title": "IE/361", "entry_cls_name": "Solution", "testing_code": "assert is_valid_code({175286: 2, 293416: 3, 654321: 0})\nassert not is_valid_code({123456: 4, 345678: 4, 567890: 4})", "entry_fn_name": "is_valid_code"}
{"id": "362", "text": "A strobogrammatic number is a positive number that appears the same after being rotated `180` degrees. For example, `16891` is strobogrammatic.\n\nCreate a program that finds all strobogrammatic numbers with N digits.", "solution": "def get_strob_numbers(num_digits):\n    if not num_digits:\n        return ['']\n    elif num_digits == 1:\n        return ['0', '1', '8']\n    smaller_strob_numbers = get_strob_numbers(num_digits - 2)\n    strob_numbers = list()\n    for x in smaller_strob_numbers:\n        strob_numbers.extend(['1' + x + '1', '6' + x + '9', '9' + x + '6', '8' + x + '8'])\n    return strob_numbers", "title": "IE/362", "entry_cls_name": "Solution", "testing_code": "assert get_strob_numbers(1) == ['0', '1', '8']\nassert get_strob_numbers(2) == ['11', '69', '96', '88']\nassert get_strob_numbers(3) == ['101', '609', '906', '808', '111', '619', '916', '818', '181', '689', '986', '888']", "entry_fn_name": "get_strob_numbers"}
{"id": "363", "text": "Write a function, add_subtract, which alternately adds and subtracts curried arguments. Here are some sample operations:\n\n```\nadd_subtract(7) -> 7\nadd_subtract(1)(2)(3) -> 1 + 2 - 3 -> 0\nadd_subtract(-5)(10)(3)(9) -> -5 + 10 - 3 + 9 -> 11\n```", "solution": "def add(x, y=1):\n    return lambda z: add(x + y * z, -1 * y) if z else x", "title": "IE/363", "entry_cls_name": "Solution", "testing_code": "assert add(7)(None) == 7\nassert add(1)(2)(3)(None) == 0\nassert add(-5)(10)(3)(9)(None) == 11", "entry_fn_name": "add"}
{"id": "61", "text": "Implement integer exponentiation. That is, implement the `pow(x, y)` function, where `x` and `y` are integers and returns `x^y`.\n\nDo this faster than the naive method of repeated multiplication.\n\nFor example, `pow(2, 10)` should return 1024.", "solution": "def get_exponent(x,y):\n    if not x:\n        return 0\n    elif not y:\n        return 1\n\n    y_abs = abs(y)\n\n    current_pow = 1\n    prev_result, prev_pow = 0, 0\n    result = x\n    while current_pow <= y_abs:\n        prev_result = result\n        prev_pow = current_pow\n        result *= result\n        current_pow *= 2\n\n    prev_result *= get_exponent(x, y_abs - prev_pow)\n\n    return 1/prev_result if y != y_abs else prev_result", "title": "IE/61", "entry_cls_name": "Solution", "testing_code": "assert get_exponent(2, 2) == 4\nassert get_exponent(2, 10) == 1024\nassert get_exponent(2, 1) == 2\nassert get_exponent(3, 3) == 27\nassert get_exponent(10, 3) == 1000\nassert get_exponent(2, -3) == 0.125\nassert get_exponent(10, -2) == 0.01\nassert get_exponent(5, 0) == 1\nassert get_exponent(0, 2) == 0\nassert get_exponent(2, -2) == 0.25", "entry_fn_name": "get_exponent"}
{"id": "29", "text": "Given a list of integers, write a function that returns the largest sum of non-adjacent numbers. Numbers can be `0` or negative.\n\nFor example, `[2, 4, 6, 2, 5]` should return `13`, since we pick `2`, `6`, and `5`. `[5, 1, 1, 5]` should return `10`, since we pick `5` and `5`.\n\nFollow-up: Can you do this in O(N) time and constant space?\n", "solution": "def get_largest_non_adj_sum(array):\n    previous, largest = 0, 0\n    for amount in array:\n        previous, largest = largest, max(largest, previous + amount)\n    return largest", "title": "IE/9", "entry_cls_name": "Solution", "entry_fn_name": "get_largest_non_adj_sum", "testing_code": "assert get_largest_non_adj_sum([2, 4, 6, 8]) == 12\nassert get_largest_non_adj_sum([5, 1, 1, 5]) == 10\nassert get_largest_non_adj_sum([2, 4, 6, 2, 5]) == 13\nassert get_largest_non_adj_sum([5]) == 5\nassert get_largest_non_adj_sum([5, 6]) == 6\nassert get_largest_non_adj_sum([6, 5]) == 6\nassert get_largest_non_adj_sum([0, -4, -2]) == 0\nassert get_largest_non_adj_sum([0, -2, -4]) == 0\nassert get_largest_non_adj_sum([0, 0, -4]) == 0\nassert get_largest_non_adj_sum([-5, -1, -1, -5]) == 0\nassert get_largest_non_adj_sum([-5, -1, 1, -5]) == 1\nassert get_largest_non_adj_sum([2, 4, -6, 2, 5]) == 9\nassert get_largest_non_adj_sum([2, 4, -6, 5, 2]) == 9\nassert get_largest_non_adj_sum([2, 4, -6, -5, 4]) == 8\nassert get_largest_non_adj_sum([3, 5, -7, 8, 10]) == 15\nassert get_largest_non_adj_sum([-3]) == 0"}
