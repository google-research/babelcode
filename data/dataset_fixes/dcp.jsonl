{"id": "33", "testing_code": "assert get_running_medians([]) == []\nassert get_running_medians([2, 5]) == [2, 3.5]\nassert get_running_medians([3, 3, 3, 3]) == [3, 3, 3, 3]\nassert get_running_medians([2, 1, 5, 7, 2, 0, 5]) == [2, 1.5, 2, 3.5, 2, 2, 2]\nassert get_running_medians([1, 2, 3]) == [1, 1.5, 2]", "solution": "import heapq as hq\ndef get_running_medians(arr):\n    if not arr:\n        return []\n    min_heap = list()\n    max_heap = list()\n    medians = list()\n    for x in arr:\n        hq.heappush(min_heap, x)\n        if len(min_heap) > len(max_heap) + 1:\n            smallest_large_element = hq.heappop(min_heap)\n            hq.heappush(max_heap, -smallest_large_element)\n        if len(min_heap) == len(max_heap):\n            median = (min_heap[0] - max_heap[0]) / 2\n        else:\n            median = min_heap[0]\n        medians.append(median)\n    return medians\n"}
{"id": "41", "testing_code": "assert get_itinerary([('SFO', 'HKO'), ('YYZ', 'SFO'), ('YUL', 'YYZ'), ('HKO', 'ORD')], 'YUL') == ['YUL', 'YYZ', 'SFO', 'HKO', 'ORD']\nassert get_itinerary([('SFO', 'COM'), ('COM', 'YYZ')], 'YUL') == []\nassert get_itinerary([('A', 'B'), ('A', 'C'), ('B', 'C'), ('C', 'A')], 'A') == ['A', 'B', 'C', 'A', 'C']\nassert get_itinerary([('A','B'),('B','A')],'A') == ['A', 'B', 'A']\nassert get_itinerary([('A','B'),('C','D')],'D') == []\nassert get_itinerary([['A', 'B'], ['A', 'C'], ['B', 'C'], ['C', 'A']], 'A') == ['A', 'B', 'C', 'A', 'C']", "solution": "def get_itinerary(flights, starting_point):\n    def _get_itinerary(flights, starting_point, current_itinerary):\n      if not flights:\n          return current_itinerary + [starting_point]\n      updated_itinerary = None\n      for (index, (city_1, city_2)) in enumerate(flights):\n          if starting_point == city_1:\n              child_itinerary = _get_itinerary(flights[:index] + flights[index + 1:], city_2, current_itinerary + [city_1])\n              if child_itinerary:\n                  if not updated_itinerary or ''.join(child_itinerary) < ''.join(updated_itinerary):\n                      updated_itinerary = child_itinerary\n      return updated_itinerary or []\n    return _get_itinerary(flights, starting_point, [])\n"}
{"id": "42", "testing_code": "assert get_subset_for_sum([], 1) == []\nassert get_subset_for_sum([12, 1, 61, 5, 9, 2], 24) == [12, 1, 9, 2]\nassert get_subset_for_sum([12, 1, 61, 5, 9, 2], 61) == [61]\nassert get_subset_for_sum([12, 1, 61, 5, -108, 2], -106) == [-108, 2]\nassert get_subset_for_sum([1,2],3) == [1,2]\nassert get_subset_for_sum([-1,-1,-1,-1,-1,-1,8],2) == [-1, -1, -1, -1, -1, -1, 8]\nassert get_subset_for_sum([12, 1, 61, 5, 9, 2], 15) == [12,1,2]\nassert get_subset_for_sum([12, 1, 61, 5, 9, 2], 16) == [5, 9, 2]\nassert get_subset_for_sum([12, 1, 61, 5, 9, 2], 17) == [12, 5]\nassert get_subset_for_sum([12, 1, 61, 5, 9, 2], 18) == [12, 1, 5]\nassert get_subset_for_sum([12, 1, 61, 5, 9, 2], 19) == [12, 5, 2]\nassert get_subset_for_sum([12, 1, 61, 5, 9, 2], 20) == [12, 1, 5, 2]\nassert get_subset_for_sum([12, 1, 61, 5, 9, 2], 21) == [12, 9]\nassert get_subset_for_sum([12, 1, 61, 5, 9, 2], 22) == [12, 1, 9]\nassert get_subset_for_sum([12, 1, 61, 5, 9, 2], 23) == [12, 9, 2]\nassert get_subset_for_sum([2, 3, 7, 8, 10], 9) == [2, 7]\nassert get_subset_for_sum([2, 3, 7, 8, 10], 10) == [2,8]\nassert get_subset_for_sum([2, 3, 7, 8, 10], 11) == [3, 8]\nassert get_subset_for_sum([2, 3, 7, 8, 10], 30) == [2, 3, 7, 8, 10]", "solution": "def get_subset_for_sum(arr, k):\n    if len(arr) == 0:\n        return []\n    if arr[0] == k:\n        return [arr[0]]\n    with_first = get_subset_for_sum(arr[1:], k - arr[0])\n    if with_first:\n        return [arr[0]] + with_first\n    else:\n        return get_subset_for_sum(arr[1:], k)", "text": "Given a list of integers S and a target number k, write a function that returns a subset of S that adds up to k. If such a subset cannot be made, then return an empty list.\n\nIntegers can appear more than once in the list. You may assume all numbers in the list are positive.\n\nFor example, given `S = [12, 1, 61, 5, 9, 2]` and `k = 24`, return [12, 9, 2, 1] since it sums up to 24."}
{"id": "57", "testing_code": "assert break_test('encyclopedia', 8) == []\nassert break_test('the quick brown fox jumps over the lazy dog', 10) == ['the quick', 'brown fox', 'jumps over', 'the lazy', 'dog']\nassert break_test('a b c d e f gg h h ii',2) == ['a', 'b', 'c', 'd', 'e', 'f', 'gg', 'h', 'h', 'ii']\nassert break_test('ab',1) == []\nassert break_test('a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a',1) == ['a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a']", "solution": "def break_test(sentence, k):\n    words = sentence.split()\n    broken_text = list()\n    char_counter = -1\n    current_words = list()\n    index = 0\n    while index < len(words):\n        word = words[index]\n        if len(word) > k:\n            return []\n        if char_counter + len(word) + 1 <= k:\n            char_counter += len(word) + 1\n            current_words.append(word)\n            index += 1\n        else:\n            broken_text.append(' '.join(current_words))\n            char_counter = -1\n            current_words = list()\n    broken_text.extend(current_words)\n    return broken_text\n", "text": "\nGiven a string s and an integer k, break up the string into multiple texts such that each text has a length of k or less. You must break it up so that words don't break across lines. If there's no way to break the text up, then return an empty list.\n\nYou can assume that there are no spaces at the ends of the string and that there is exactly one space between each word.\n\nFor example, given the string \"the quick brown fox jumps over the lazy dog\" and k = 10, you should return: [\"the quick\", \"brown fox\", \"jumps over\", \"the lazy\", \"dog\"]. No string in the list has a length of more than 10.\n"}
{"id": "62", "testing_code": "assert get_matrix_traversals(1, 1) == 1\nassert get_matrix_traversals(2, 2) == 2\nassert get_matrix_traversals(5, 5) == 70\nassert get_matrix_traversals(10,10) == 48620\nassert get_matrix_traversals(15,15) == 40116600\nassert get_matrix_traversals(0, 0) == -1\nassert get_matrix_traversals(1,0)==-1\nassert get_matrix_traversals(0,1)==-1\nassert get_matrix_traversals(3, 2) == 3\nassert get_matrix_traversals(7, 3) == 28", "solution": "def matrix_traversal_helper(row_count, col_count, curr_row, curr_col):\n    if curr_row == row_count - 1 and curr_col == col_count - 1:\n        return 1\n    count = 0\n    if curr_row < row_count - 1:\n        count += matrix_traversal_helper(row_count, col_count, curr_row + 1, curr_col)\n    if curr_col < col_count - 1:\n        count += matrix_traversal_helper(row_count, col_count, curr_row, curr_col + 1)\n    return count\ndef get_matrix_traversals(row_count, col_count):\n    if not row_count or not col_count:\n        return -1\n    count = matrix_traversal_helper(row_count, col_count, 0, 0)\n    return count\n", "text": "There is an N by M matrix of zeroes. Given N and M, write a function to count the number of ways of starting at the top-left corner and getting to the bottom-right corner. You can only move right or down. Return -1 if it is not possible.\n\nFor example, given a 2 by 2 matrix, you should return 2, since there are two ways to get to the bottom-right:\n* Right, then down\n* Down, then right\n\nGiven a 5 by 5 matrix, there are 70 ways to get to the bottom-right.\n"}
{"id": "103", "testing_code": "assert get_min_string('abcdedbc', {'g', 'f'}) == ''\nassert get_min_string('abccbbbccbcb', {'a', 'b', 'c'}) == 'abc'\nassert get_min_string('figehaeci', {'a', 'e', 'i'}) == 'aeci'\nassert get_min_string('abcdedbc', {'d', 'b', 'b'}) == 'db'\nassert get_min_string('abcdedbc', {'b', 'c'}) == 'bc'\nassert get_min_string('abcdecdb', {'b', 'c'}) == 'bc'\nassert get_min_string('abcdecdb', {'b', 'c', 'e'}) == 'bcde'", "solution": "from queue import Queue\ndef get_min_string(string, charset):\n    curr_queue = list()\n    ind_queue = list()\n    curr_seen = set()\n    candidate = None\n    i = 0\n    while i < len(string):\n        if string[i] in charset:\n            curr_queue.append(string[i])\n            ind_queue.append(i)\n            curr_seen.add(string[i])\n        shift = 0\n        for k in range(len(curr_queue) // 2):\n            if curr_queue[k] == curr_queue[-k - 1]:\n                shift += 1\n        curr_queue = curr_queue[shift:]\n        ind_queue = ind_queue[shift:]\n        if len(curr_seen) == len(charset):\n            if not candidate or len(candidate) > ind_queue[-1] - ind_queue[0] + 1:\n                candidate = string[ind_queue[0]:ind_queue[-1] + 1]\n        i += 1\n    return candidate or ''", "text": "Given a string and a set of characters, return the shortest substring containing all the characters in the set.\n\nFor example, given the string \"figehaeci\" and the set of characters {a, e, i}, you should return \"aeci\".\n\nIf there is no substring containing all the characters in the set, return an empty string."}
{"id": "153", "testing_code": "assert get_smallest_dist('hello', 'hello', 'world') == -1\nassert get_smallest_dist('hello world', 'hello', 'world') == 0\nassert get_smallest_dist('dog cat hello cat dog dog hello cat world', 'hello', 'world') == 1\nassert get_smallest_dist('dog cat hello cat dog dog hello cat world', 'dog', 'world') == 2", "solution": "def get_smallest_dist(text, w1, w2):\n    dist = -1\n    (ls_word, ls_index) = (None, None)\n    for (index, word) in enumerate(text.split()):\n        if word == w1 or word == w2:\n            if word == w1 and ls_word == w2 or (word == w2 and ls_word == w1):\n                dist = index - ls_index - 1\n            ls_word = word\n            ls_index = index\n    return dist\n", "text": "Find an efficient algorithm to find the smallest distance (measured in number of words) between any two given words in a string. If it is not possible return -1.\n\nFor example, given words \"hello\", and \"world\" and a text content of \"dog cat hello cat dog dog hello cat world\", return 1 because there's only one word \"cat\" in between the two words.\n"}
{"id": "159", "testing_code": "assert get_first_recurring('acbbac') == 'b'\nassert get_first_recurring('abcdef') == ''\nassert get_first_recurring('abcdefghijklmnopqrstuvwxyz_1234567890!@#$%^&*()-=[]|;:\"?><,.a') == 'a'", "solution": "def get_first_recurring(string):\n    seen = set()\n    for char in string:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''\n", "text": "Given a string, return the first recurring character in it, or `null` if there is no recurring chracter.\n\nFor example, given the string `\"acbbac\"`, return `\"b\"`. Given the string `\"abcdef\"`, return `\"\"`.\n"}
{"id": "142", "solution": "def valid_paren(string, stack=list()):\n    def _valid_paren(string, stack=None):\n        stack=stack or []\n        if not string and (not stack):\n            return True\n        elif not string:\n            return False\n        cchar = string[0]\n        remaining = string[1:]\n        if cchar == '*':\n            return _valid_paren('(' + remaining, stack) or _valid_paren(')' + remaining, stack) or _valid_paren(remaining, stack)\n        cstack = stack.copy()\n        if cchar == ')' and (not stack):\n            return False\n        elif cchar == ')':\n            cstack.pop()\n        else:\n            cstack.append(cchar)\n        return _valid_paren(remaining, cstack)\n    return _valid_paren(string)\n"}
{"id": "181", "solution": "def is_palindrome(string):\n    return bool(string) and string == string[::-1]\ndef split_into_pals(string):\n    def _split_into_pals(string, curr, prev_pals):\n        if not string and (not curr):\n            return prev_pals\n        elif not string:\n            return prev_pals + list(curr)\n        candidate = curr + string[0]\n        alt_1 = []\n        if is_palindrome(candidate):\n            alt_1 = _split_into_pals(string[1:], '', prev_pals + [candidate])\n        alt_2 = _split_into_pals(string[1:], candidate, prev_pals)\n        return alt_1 if bool(alt_1) and len(alt_1) < len(alt_2) else alt_2\n    return _split_into_pals(string, '', [])\n"}
{"id": "189", "solution": "def get_longest_uqsub(arr):\n    def _get_longest_uqsub(arr, seen):\n        if not arr:\n            return len(seen)\n        curr = arr[0]\n        if curr in seen:\n            return len(seen)\n        seen_cp = seen.copy()\n        seen_cp.add(curr)\n        return max(_get_longest_uqsub(arr[1:], seen_cp), _get_longest_uqsub(arr[1:],set()))\n    return _get_longest_uqsub(arr, set())\n"}
{"id": "191", "solution": "def get_min_removals(intervals):\n    def _get_min_removals(intervals, reserved_intervals, removed):\n        if not intervals:\n            return removed\n\n        curr_interval = intervals[0]\n        if_removed = _get_min_removals(\n            intervals[1:], reserved_intervals, removed + 1)\n\n        for ri in reserved_intervals:\n            if curr_interval[0] in ri or curr_interval[1] in ri:\n                return if_removed\n\n        new_reserved_intervals = reserved_intervals +             [range(curr_interval[0], curr_interval[1])]\n\n        return min(if_removed, _get_min_removals(intervals[1:], new_reserved_intervals, removed))\n    return _get_min_removals(intervals, reserved_intervals=list(), removed=0)\n"}
{"id": "193", "solution": "def get_max_profit(prices, fee):\n    def _get_max_profit(prices, fee, reserve=0, buyable=True):\n        if not prices:\n            return reserve\n        price_offset = -prices[0] - fee if buyable else prices[0]\n        return max(_get_max_profit(prices[1:], fee, reserve, buyable), _get_max_profit(prices[1:], fee, reserve + price_offset, not buyable))\n    return _get_max_profit(prices, fee)\n"}
{"id": "144", "testing_code": "assert nearest_larger([4, 1, 3, 5, 6], 0) == 3\nassert nearest_larger([4, 1, 3, 5, 6], 1) == 2\nassert nearest_larger([4, 1, 3, 5, 6], 4) == -1\nassert nearest_larger([4, 1, 3, 5, 6], 3) == 4\n", "solution": "def get_mapping_indices(arr):\n    nl_indices = dict()\n    sorted_tuples = [(x, i) for (i, x) in enumerate(arr)]\n    sorted_tuples.sort(key=lambda x: x[0])\n    for (k, (_, i)) in enumerate(sorted_tuples[:-1]):\n        min_dist = len(arr)\n        for m in range(k + 1, len(sorted_tuples)):\n            dist = abs(i - sorted_tuples[m][1])\n            if dist < min_dist:\n                min_dist = dist\n                nl_indices[i] = sorted_tuples[m][1]\n    return nl_indices\ndef nearest_larger(arr, index):\n    nl_indices = get_mapping_indices(arr)\n    if index not in nl_indices:\n        return -1\n    return nl_indices[index]\n", "text": "Given an array of numbers and an index `i`, return the index of the nearest larger number of the number at index `i`, where distance is measured in array indices.\n\nFor example, given `[4, 1, 3, 5, 6]` and index `0`, you should return `3`.\n\nIf two distances to larger numbers are equal, then return any one of them. If the array at `i` doesn't have a nearest larger integer, then return `-1`.\n\nFollow-up: If you can preprocess the array, can you do this in constant time?\n\n"}
{"id": "114", "testing_code": "assert reverse_words('hello/world:here/', [':', '/']) == 'here/world:hello/'\nassert reverse_words(':hello//world:here/', [':', '/']) == ':here//world:hello/'\nassert reverse_words('hello//world:here', [':', '/']) == 'here//world:hello'\nassert reverse_words('hello/world:here', [':', '/']) == 'here/world:hello'\nassert reverse_words('hello world, here', [':', '/']) == 'hello world, here'\n"}
{"id": "17", "testing_code": "assert get_longest_path('dir\\n\\tsubdir1\\n\\tsubdir2') == 0\nassert get_longest_path('dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext') == 20\nassert get_longest_path(\"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\") == 32\nassert get_longest_path('dir\\n\\tsubdir1\\n\\tsubdir2\\n\\tsubdir3') == 0\nassert get_longest_path('dir\\n\\tsubdir1\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\tsubdir3') == 0\nassert get_longest_path('dir') == 0\nassert get_longest_path('dir\\n\\tfile1.txt') == 13", "solution": "def get_longest_path(fs: str) -> int:\n    paths = fs.split('\\n')\n    max_len = 0\n    path_lengths = {0: 0}\n    depth = 0\n    for path in paths:\n        name = path.strip()\n        depth = len(path)-len(name)\n        if '.' in name:\n            max_len = max(max_len, path_lengths[depth] + len(name))\n        else:\n            path_lengths[depth+1] = path_lengths[depth] + len(name) + 1\n    return max_len"}
{"id": "163", "testing_code": "assert evaluate_expression([\"5\", \"3\", \"+\"]) == 8\nassert evaluate_expression([\"2\",\"1\",\"+\",\"3\",\"*\"]) == 9\nassert evaluate_expression([\"4\",\"13\",\"5\",\"/\",\"+\"]) == 6\nassert evaluate_expression([\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]) == 22\nassert evaluate_expression(['15', '7', '1', '1', '+', '-', '/', '3', '*', '2', '1', '1', '+', '+', '-']) == 5\n", "solution": "def evaluate_expression(tokens):\n    stack = []\n    for t in tokens:\n        if t not in \"+-*/\":\n            stack.append(int(t))\n        else:\n            r, l = stack.pop(), stack.pop()\n            if t == \"+\":\n                stack.append(l+r)\n            elif t == \"-\":\n                stack.append(l-r)\n            elif t == \"*\":\n                stack.append(l*r)\n            else:\n                stack.append(int(float(l)/r))\n    return stack.pop()\n", "text": "Given an arithmetic expression in Reverse Polish Notation, write a program to evaluate it.\n\nThe expression is given as a list of numbers and operands. For example: `[\"5\", \"3\", '+']` should return `5 + 3 = 8`.\n\nFor example, `[\"2\",\"1\",\"+\",\"3\",\"*\"]` should return `9`, since it is equivalent to `((2 + 1) * 3) = 9`.\n\nYou can assume the given expression is always valid and division of integers should be truncated towards 0.\n"}
{"id": "259", "testing_code": "assert get_optimal_chars(['cat', 'calf', 'dog', 'bear']) == {'b'}\nassert get_optimal_chars(['cat', 'calf', 'dog', 'bear', 'ao']) == {'b', 'a'}\nassert get_optimal_chars([\"ghost\", \"ghostbuster\", \"gas\"]) == {}\n\n"}
{"id": "260", "testing_code": "assert deduce_nums(['0','+','+']) == [0,1,2]\nassert deduce_nums(['0','-','-']) == [2,1,0]\nassert deduce_nums(['', '+', '+', '-', '+']) == [1, 2, 3, 0, 4]\nassert deduce_nums(['0','-','-','-','-','-']) == [5, 4, 3, 2, 1, 0]\n", "text": "The sequence `[0, 1, ..., N]` has been jumbled, and the only clue you have for its order is an array representing whether each number is larger or smaller than the last. Given this information, reconstruct an array that is consistent with it. For example, given `[\"\", +, +, -, +]`, you could return `[1, 2, 3, 0, 4]`."}
{"id": "72", "testing_code": "assert get_max_value_string('ABACA', [[0, 1], [0, 2], [2, 3], [3, 4]]) == 3\nassert get_max_value_string('A', [[0, 0]]) == -1\nassert get_max_value_string('ABCDE', [[0, 1],[2,3],[3,1]]) == 1\n", "solution": "class GraphPath:\n\n    def __init__(self, nodes=set(), letter_counts=dict()):\n        self.nodes = nodes\n        self.letter_counts = letter_counts\n\n    def __repr__(self):\n        return 'nodes={}, letters={}'.format(self.nodes, self.letter_counts)\ndef get_max_value_string_helper(graph_path, node, adjacency_map):\n    if node in graph_path.nodes:\n        return [graph_path]\n    new_nodes = graph_path.nodes.copy()\n    new_nodes.add(node)\n    new_letter_counts = graph_path.letter_counts.copy()\n    if node[0] not in new_letter_counts:\n        new_letter_counts[node[0]] = 0\n    new_letter_counts[node[0]] += 1\n    new_graph_path = GraphPath(new_nodes, new_letter_counts)\n    if node not in adjacency_map:\n        return [new_graph_path]\n    paths = list()\n    for child_node in adjacency_map[node]:\n        new_paths = get_max_value_string_helper(new_graph_path, child_node, adjacency_map)\n        paths.extend(new_paths)\n    return paths\ndef get_max_value_string(graph_string, edge_list):\n    letter_counts = dict()\n    nodes = list()\n    for char in graph_string:\n        if char not in letter_counts:\n            letter_counts[char] = 0\n        else:\n            letter_counts[char] += 1\n        nodes.append('{}{}'.format(char, letter_counts[char]))\n    adjacency_map = dict()\n    for (start, end) in edge_list:\n        if nodes[start] not in adjacency_map:\n            adjacency_map[nodes[start]] = set()\n        if nodes[start] != nodes[end]:\n            adjacency_map[nodes[start]].add(nodes[end])\n    paths = list()\n    graph_path = GraphPath()\n    for node in adjacency_map:\n        new_paths = get_max_value_string_helper(graph_path, node, adjacency_map)\n        paths.extend(new_paths)\n    max_value = 0\n    for path in paths:\n        max_path_value = max(path.letter_counts.values())\n        if max_path_value > max_value:\n            max_value = max_path_value\n    return max_value if max_value > 0 else -1", "text": "In a directed graph, each node is assigned an uppercase letter. We define a path's value as the number of most frequently-occurring letter along that path. For example, if a path in the graph goes through \"ABACA\", the value of the path is 3, since there are 3 occurrences of 'A' on the path.\n\nGiven a graph with n nodes and m directed edges, return the largest value path of the graph. If the largest value is infinite, then return an empty list.\n\nThe graph is represented with a string and an edge list. The i-th character represents the uppercase letter of the i-th node. Each list in the edge list [i, j] means there is a directed edge from the i-th node to the j-th node. Self-edges are possible, as well as multi-edges.\n\nFor example, the following input graph:\n\n```\nABACA\n[[0, 1],\n [0, 2],\n [2, 3],\n [3, 4]]\n```\nWould have maximum value 3 using the path of vertices `[0, 2, 3, 4], [A, A, C, A]`.\n\nThe following input graph:\n\n```\nA\n[(0, 0)]\n```\n\nShould return -1, since we have an infinite loop.", "entry_fn_name": "get_max_value_string"}
{"id": "68", "testing_code": "assert get_attack_vectors([[0, 0], [1, 2], [2, 2], [4, 0]], 5) == 2\nassert get_attack_vectors([[0, 0], [1, 2], [2, 2]], 5) == 1\nassert get_attack_vectors([[0, 0], [1, 2], [2, 2]], 1) == 0", "solution": "def add_new_bishop(location, attack_positions, board_size):\n    count = 0\n    if location in attack_positions:\n        count += 1\n    \n    new_attack_positions = list()\n    [i, j] = location\n    while i > 0 and j > 0:\n        i -= 1\n        j -= 1\n        new_attack_positions.append([i, j])\n    [i, j] = location\n    while i > 0 and j < board_size - 1:\n        i -= 1\n        j += 1\n        new_attack_positions.append([i, j])\n    [i, j] = location\n    while i < board_size - 1 and j > 0:\n        i += 1\n        j -= 1\n        new_attack_positions.append([i, j])\n    [i, j] = location\n    while i < board_size - 1 and j < board_size - 1:\n        i += 1\n        j += 1\n        new_attack_positions.append([i, j])\n    attack_positions.extend(new_attack_positions)\n    return (count, attack_positions)\ndef get_attack_vectors(bishop_locations, board_size):\n    attack_positions = list()\n    total_count = 0\n    for location in bishop_locations:\n        (count, attack_positions) = add_new_bishop(location, attack_positions, board_size)\n        total_count += count\n    return total_count", "text": "On our special chessboard, two bishops attack each other if they share the same diagonal. This includes bishops that have another bishop located between them, i.e. bishops can attack through pieces.\n\nYou are given N bishops, represented as (row, column) tuples on a M by M chessboard. Write a function to count the number of pairs of bishops that attack each other. The ordering of the pair doesn't matter: [1, 2] is considered the same as [2, 1].\n\nFor example, given M = 5 and the list of bishops:\n```\n(0, 0)\n(1, 2)\n(2, 2)\n(4, 0)\n```\n\nThe board would look like this:\n\n```\n[b 0 0 0 0]\n[0 0 b 0 0]\n[0 0 b 0 0]\n[0 0 0 0 0]\n[b 0 0 0 0]\n```\n\nYou should return 2, since bishops 1 and 3 attack each other, as well as bishops 3 and 4."}
{"id": "77", "testing_code": "assert merge_overlaps([[1, 3], [5, 8], [4, 10], [20, 25]]) == [[1, 3], [4, 10], [20, 25]]\nassert merge_overlaps([[1, 3], [5, 8], [4, 10], [20, 25], [6, 12]]) == [[1, 3], [4, 12], [20, 25]]\nassert merge_overlaps([[1, 4], [4, 5]]) == [[1, 5]]", "solution": "def merge_overlaps(intervals):\n    (interval_starts, interval_ends) = (set(), set())\n    for (start, end) in intervals:\n        interval_starts.add(start)\n        interval_ends.add(end)\n    min_start = min(interval_starts)\n    max_end = max(interval_ends)\n    current_active = 0\n    instant_statuses = list([current_active])\n    merged = list()\n    for i in range(min_start, max_end + 1):\n        if i in interval_ends:\n            current_active -= 1\n        if i in interval_starts:\n            current_active += 1\n        instant_statuses.append(current_active)\n    (start, end) = (None, None)\n    for i in range(len(instant_statuses)):\n        if instant_statuses[i] and (not instant_statuses[i - 1]):\n            start = i\n        if not instant_statuses[i] and instant_statuses[i - 1]:\n            end = i\n            merged.append([start, end])\n            (start, end) = (None, None)\n    return merged"}
{"id": "101", "testing_code": "assert get_primes(4) == [2, 2]\nassert get_primes(10) == [3, 7]\nassert get_primes(100) == [3, 97]\nassert get_primes(74) == [3, 71]\nassert get_primes(1024) == [3, 1021]\nassert get_primes(66) == [5, 61]\nassert get_primes(9990) == [17, 9973]", "solution": "def is_prime(num, primes):\n    for prime in primes:\n        if prime == num:\n            return True\n        if not num % prime:\n            return False\n    return True\ndef get_primes(num):\n    limit = num // 2 + 1\n    candidates = list()\n    primes = list()\n    for i in range(2, limit):\n        if is_prime(i, primes):\n            primes.append(i)\n            candidates.append((i, num - i))\n    new_candidates = list()\n    for (first, second) in candidates[::-1]:\n        if is_prime(second, primes):\n            primes.append(second)\n            new_candidates.append([first, second])\n    return new_candidates[-1]"}
{"id": "123", "solution": "def strip_neg(num):\n    if num[0] != '-':\n        return num\n    elif len(num) > 1:\n        return num[1:]\ndef is_valid_number_helper(string, dec):\n    if not string:\n        return True\n    char = string[0]\n    if dec and char == '.' or (not char.isdigit() and char != '.'):\n        return False\n    elif char == '.':\n        dec = True\n    return is_valid_number_helper(string[1:], dec)\ndef is_valid_number(string):\n    if not string:\n        return False\n    split_list = string.split('e')\n    if len(split_list) > 2:\n        return False\n    if len(split_list) == 2:\n        string_1 = strip_neg(split_list[0])\n        string_2 = strip_neg(split_list[1])\n        return string_1 and string_2 and is_valid_number_helper(string_1, False) and is_valid_number_helper(string_2, False)\n    else:\n        string = strip_neg(split_list[0])\n        return string and is_valid_number_helper(string, False)\n    return False"}
{"id": "167", "testing_code": "assert get_unique_index_pairs(['code', 'edoc', 'da', 'd']) == [[0, 1], [1, 0], [2, 3]]\nassert get_unique_index_pairs([\"geekf\", \"geeks\", \"or\", \"keeg\", \"abc\", \"bc\"]) == [[0, 3], [1, 3]]\nassert get_unique_index_pairs([\"geekf\"]) == []", "solution": "def is_palindrome(word):\n    return word == word[::-1]\ndef get_unique_index_pairs(words):\n    index_tuples = list()\n    for (i, word_i) in enumerate(words):\n        for (j, word_j) in enumerate(words):\n            if i != j:\n                composite = word_i + word_j\n                if is_palindrome(composite):\n                    index_tuples.append([i, j])\n    return index_tuples", "text": "Given a list of words, find all pairs of unique indices such that the concatenation of the two words is a palindrome.\n\nFor example, given the list `[\"code\", \"edoc\", \"da\", \"d\"]`, return `[[0, 1], [1, 0], [2, 3]]`.", "entry_fn_name": "get_unique_index_pairs"}
{"id": "186", "testing_code": "assert divide_numbers([5, 10, 15, 20, 25]) == [{5, 15, 20}, {10, 25}]\nassert divide_numbers([5, 10, 15, 20]) == [{10, 15}, {20, 5}]\nassert divide_numbers([56,12,30]) == [{12, 30}, {56}]", "solution": "def get_diff(s1, s1_sum, s2, s2_sum, score):\n    (min_diff, min_cand) = (score, None)\n    for (i, num) in enumerate(s1):\n        (new_s1_sum, new_s2_sum) = (s1_sum - num, s2_sum + num)\n        new_score = abs(new_s1_sum - new_s2_sum)\n        if new_score < min_diff:\n            min_diff = new_score\n            min_cand = (s1[:i] + s1[i + 1:], new_s1_sum, s2 + [num], new_s2_sum)\n    if not min_cand:\n        return (set(s1), set(s2))\n    return get_diff(min_cand[0], min_cand[1], min_cand[2], min_cand[3], min_diff)\ndef divide_numbers(nums):\n    sum_nums = sum(nums)\n    best_sets = get_diff(nums.copy(), sum_nums, [], 0, sum_nums)\n    return list(best_sets)"}
{"id": "200", "testing_code": "assert get_stab_points([[1, 4], [4, 5], [7, 9], [9, 12]]) == [4, 9]\nassert get_stab_points([[1, 4], [-2, 6], [4, 5], [7, 9], [9, 12]]) == [4, 9]\nassert get_stab_points([[1, 4], [-2, 0], [4, 5], [7, 9]]) == [0, 7]", "solution": "def get_stab_points(intervals):\n    (starts, ends) = zip(*intervals)\n    return [min(ends), max(starts)]", "text": "Let `X` be a set of `n` intervals on the real line. We say that a set of points `P` \"stabs\" `X` if every interval in `X` contains at least one point in `P`. Compute the smallest set of points that stabs `X`.\n\nFor example, given the intervals `[[1, 4], [4, 5], [7, 9], [9, 12]]`, you should return `[4, 9]`."}
{"id": "231", "testing_code": "assert rearrange('aaabbc') == 'abcaba'\nassert rearrange('aaab') == ''\nassert rearrange('aaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbcccccccccccccccccz') == 'baczbacbacbacbacbacbacbacbacbacbacbacbacbacbacbacbacbababababababababababbb'", "solution": "def rearrange(string):\n    from collections import Counter\n    from queue import Queue\n    c = Counter(string)\n    sitems = sorted(c.items(), key=lambda x: x[1], reverse=True)\n    strlen = len(string)\n    if strlen % 2:\n        if sitems[0][1] > strlen // 2 + 1:\n            return ''\n    elif sitems[0][1] > strlen // 2:\n        return ''\n    q = Queue()\n    for item in sitems:\n        q.put(item)\n    new_str = ''\n    while not q.empty():\n        item = q.get()\n        new_str += item[0]\n        item = (item[0], item[1] - 1)\n        if item[1]:\n            q.put(item)\n    return new_str", "text": "Given a string with repeated characters, rearrange the string so that no two adjacent characters are the same. If this is not possible, return None.\n\nFor example, given \"aaabbc\", you could return \"ababac\". Given \"aaab\", return \"\"."}
{"id": "235", "testing_code": "assert find_min_max([4, 3, 1, 2, 5]) == [1, 5]\nassert find_min_max([1,1,1,1,1,1,1]) == [1, 1]\nassert find_min_max([1,1,1,1,-1,-1,-1]) == [-1, 1]", "solution": "def find_min_max(nums):\n    mini = maxi = nums[0]\n    for num in nums[1:]:\n        if num < mini:\n            mini = num\n            continue\n        elif num > maxi:\n            maxi = num\n    return [mini, maxi]"}
{"id": "257", "testing_code": "assert get_sort_range([3, 5, 6, 7, 9]) == []\nassert get_sort_range([3, 7, 5, 6, 9]) == [1, 3]\nassert get_sort_range([5, 4, 3, 2, 1]) == [0, 4]", "solution": "def get_sort_range(arr):\n    from heapq import heappush as hp\n    if arr == sorted(arr):\n        return []\n    options = list()\n    for sort_start in range(len(arr) - 1):\n        for sort_end in range(1, len(arr) + 1):\n            a1 = arr[:sort_start]\n            a2 = arr[sort_start:sort_end]\n            a3 = arr[sort_end:]\n            new_arr = a1 + sorted(a2) + a3\n            if new_arr == sorted(new_arr):\n                hp(options, (sort_end - sort_start, [sort_start, sort_end - 1]))\n    return options[0][1]", "text": "Given an array of integers out of order, determine the bounds of the smallest window that must be sorted in order for the entire array to be sorted. For example, given `[3, 7, 5, 6, 9]`, you should return `[1, 3]`."}
{"id": "286", "testing_code": "assert get_skyline([]) == []\nassert get_skyline([[0,1,3]]) == [[0,3],[1,0]]\nassert get_skyline([[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]) == [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]\nassert get_skyline([[0,2,3],[2,5,3]]) == [[0,3],[5,0]]\nassert get_skyline([[0, 15, 3], [4, 11, 5], [19, 23, 4]]) == [[0, 3], [4, 5], [11, 3], [15, 0], [19, 4], [23, 0]]", "solution": "def get_skyline(buildings):\n    import heapq\n    N, hs = len(buildings), []\n    for i, (l, r, h) in enumerate(buildings):\n        hs.append((l, 0, -h, i))\n        hs.append((r, 1, h, i))\n    hs.sort() \n    alive = [False] * N\n    \n    res, heap, current_height = [], [], 0\n    for x, tp, h, i in hs: \n        if tp == 0:  # start of i-th building\n            heapq.heappush(heap, (h, i))\n            alive[i] = True\n            if current_height < -h:\n                res.append([x, -h])\n                current_height = -h\n        else:  # end of i-th building\n            alive[i] = False\n            while heap and not alive[heap[0][1]]:\n                heapq.heappop(heap)  \n            if heap and -heap[0][0] < current_height:\n                current_height = -heap[0][0]\n                res.append([x, current_height])\n            elif not heap:\n                current_height = 0 \n                res.append([x, current_height])\n    return res", "text": "The skyline of a city is composed of several buildings of various widths and heights, possibly overlapping one another when viewed from a distance. We can represent the buildings using an array of `(left, right, height)` tuples, which tell us where on an imaginary `x`-axis a building begins and ends, and how tall it is. The skyline itself can be described by a list of `(x, height)` tuples, giving the locations at which the height visible to a distant observer changes, and each new height.\n\nGiven an array of buildings as described above, create a function that returns the skyline.\n\nFor example, suppose the input consists of the buildings `[[0, 15, 3], [4, 11, 5], [19, 23, 4]]`. In aggregate, these buildings would create a skyline that looks like the one below.\n\n```\n     ______  \n    |      |        ___\n ___|      |___    |   | \n|   |   B  |   |   | C |\n| A |      | A |   |   |\n|   |      |   |   |   |\n------------------------\n```\n\nAs a result, your function should return `[[0, 3], [4, 5], [11, 3], [15, 0], [19, 4], [23, 0]]`."}
{"id": "332", "testing_code": "assert get_variables(17,13) == [[2, 15], [3, 14], [6, 11], [7, 10]]\nassert get_variables(100, 4) == [[48, 52]]\nassert get_variables(18400,12994) == []", "solution": "def get_variables(m, n):\n    candidates = list()\n    for a in range(m // 2 + 1):\n        b = m - a\n        if a ^ b == n:\n            candidates.append([a, b])\n    return candidates", "text": "Given integers `M` and `N`, write a program that counts how many positive integer pairs `[a, b]` satisfy the following conditions:\n\n```\na + b = M\na XOR b = N\n```"}
{"id": "340", "testing_code": "assert get_closest([[1, 1], [-1, -1], [3, 4], [6, 1], [-1, -6], [-4, -3]]) == [[1, 1], [-1, -1]]\nassert get_closest([[2, 3],[12, 30],[40, 50], [5, 1], [12, 10], [3, 4]]) == [[2, 3], [3, 4]]", "solution": "import sys\nclass Point:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __repr__(self):\n        return '[x={},y={}]'.format(self.x, self.y)\ndef get_distance(p1, p2):\n    return ((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2) ** 0.5\ndef get_closest(point_tuples):\n    points = [Point(x, y) for (x, y) in point_tuples]\n    (min_dist, min_dist_pts) = (sys.maxsize, None)\n    for i in range(len(points) - 1):\n        for j in range(i + 1, len(points)):\n            dist = get_distance(points[i], points[j])\n            if dist < min_dist:\n                min_dist = dist\n                min_dist_pts = [[points[i].x, points[i].y], [points[j].x, points[j].y]]\n    return min_dist_pts", "text": "Given a set of points `[x, y]` on a 2D cartesian plane, find the two closest points. For example, given the points `[[1, 1], [-1, -1], [3, 4], [6, 1], [-1, -6], [-4, -3]]`, return `[[-1, -1], [1, 1]]`."}
{"id": "96", "solution": "def get_permutations(arr):\n    if not arr:\n        return []\n    if len(arr) < 2:\n        return [arr]\n    permutations = list()\n    for (i, num) in enumerate(arr):\n        arr_cp = arr[:i] + arr[i + 1:]\n        child_perms = get_permutations(arr_cp)\n        for perm in child_perms:\n            permutations.append([num] + perm)\n    return permutations", "testing_code": "assert get_permutations([]) == [[]]\nassert get_permutations([1]) == [[1]]\nassert get_permutations([1, 2]) == [[1, 2], [2, 1]]\nassert get_permutations([1, 2, 3]) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\nassert get_permutations([]) == []"}
{"id": "47", "testing_code": "assert get_stock_profit([9]) == 0\nassert get_stock_profit([9, 11, 8, 5, 7, 10]) == 5\nassert get_stock_profit([1, 2, 3, 4, 5]) == 4\nassert get_stock_profit([1, 1, 1, 1, 1]) == 0\nassert get_stock_profit([1, 1, 1, 2, 1]) == 1\nassert get_stock_profit([5, 4]) == -1\nassert get_stock_profit([7, 6, 4, 3, 1]) == -1\nassert get_stock_profit([]) == 0", "solution": "import sys\ndef get_stock_profit(prices):\n    if not prices or len(prices) == 1:\n      return 0\n    min_price = prices[0]\n    max_diff = -sys.maxsize\n    for price in prices[1:]:\n        if price - min_price > max_diff:\n            max_diff = price - min_price\n        if price < min_price:\n            min_price = price\n    return max_diff"}
{"id": "102", "solution": "def get_cont_arr(arr, target):\n    summed = 0\n    sum_tracker = {0:-1}\n    for idx, v in enumerate(arr):\n        summed+=v\n        sum_tracker[summed] = idx\n        prev= sum_tracker.get(summed-target)\n        if prev is not None:\n            return arr[prev+1:idx+1]\n    return []", "text": "Given a list of integers and a number K, return which contiguous elements of the list sum to K.\n\nFor example, if the list is [1, 2, 3, 4, 5] and K is 9, then it should return [2, 3, 4]. If no subset is found, return an empty list.", "testing_code": "assert get_cont_arr([1, 2, 3, 4, 5], 0) == []\nassert get_cont_arr([1, 2, 3, 4, 5], 1) == [1]\nassert get_cont_arr([1, 2, 3, 4, 5], 5) == [2, 3]\nassert get_cont_arr([5, 4, 3, 4, 5], 12) == [5, 4, 3]\nassert get_cont_arr([5, 4, 3, 4, 5], 11) == [4, 3, 4]\nassert get_cont_arr([1, 2, 3, 4, 5], 9) == [2, 3, 4]\nassert get_cont_arr([1, 2, 3, 4, 5], 3) == [1, 2]\nassert get_cont_arr([1, 4, 20, 3, 10, 5], 33) == [20, 3, 10]\nassert get_cont_arr([1, 4, 0, 0, 3, 10, 5], 7) == [4, 0, 0, 3]\nassert get_cont_arr([1, 4], 0) == []\nassert get_cont_arr([10, 2, -2, -20, 10], -10) == [10, 2, -2, -20]\nassert get_cont_arr([-10, 0, 2, -2, -20, 10], 20) == []\nassert get_cont_arr([1, 1, 1, 1], 4) == [1, 1, 1, 1]\nassert get_cont_arr([1, 3, -2, 1], 2) == [1, 3, -2]"}
{"id": "58", "testing_code": "assert find_element([13, 18, 25, 2, 8, 10], 2) == 3\nassert find_element([13, 18, 25, 2, 8, 10], 8) == 4\nassert find_element([25, 2, 8, 10, 13, 18], 8) == 2\nassert find_element([8, 10, 13, 18, 25, 2], 8) == 0\nassert find_element([4, 5, 6, 7, 0, 1, 2], 0) == -1", "solution": "def find_element_helper(arr, element, start, end):\n    if start == end:\n        return -1\n    mid = start + (end - start) // 2\n    if arr[mid] == element:\n        return mid\n    elif arr[mid] > element:\n        if arr[start] >= element:\n            return find_element_helper(arr, element, start, mid)\n        else:\n            return find_element_helper(arr, element, mid, end)\n    elif arr[mid] < element:\n        if arr[start] <= element:\n            return find_element_helper(arr, element, start, mid)\n        else:\n            return find_element_helper(arr, element, mid, end)\ndef find_element(arr, element):\n    element_pos = find_element_helper(arr, element, 0, len(arr))\n    return element_pos", "text": "An sorted array of integers was rotated an unknown number of times.\n\nGiven such an array, find the index of the element in the array in faster than linear time. If the element doesn't exist in the array, return -1.\n\nFor example, given the array [13, 18, 25, 2, 8, 10] and the element 8, return 4 (the index of 8 in the array).\n\nYou can assume all the integers in the array are unique.", "entry_fn_name": "find_element"}
{"id": "18", "solution": "from collections import deque\ndef get_sliding_max(a, k):\n    window_max_elements = list()\n    if not a:\n        return None\n    if len(a) <= k:\n        return [max(a)]\n    dq = deque()\n    for i in range(k):\n        while dq and a[dq[-1]] < a[i]:\n            dq.pop()\n        dq.append(i)\n    window_max_elements.append(a[dq[0]])\n    for i in range(k, len(a)):\n        while dq and dq[0] <= i - k:\n            dq.popleft()\n        while dq and a[dq[-1]] < a[i]:\n            dq.pop()\n        dq.append(i)\n        window_max_elements.append(a[dq[0]])\n    return window_max_elements", "testing_code": "assert get_sliding_max([10, 5, 2, 7, 8, 7], 3) == [10, 7, 8, 8]\nassert get_sliding_max([5, 2, 1], 2) == [5, 2]\nassert get_sliding_max([11, 22], 2) == [22]\nassert get_sliding_max([11, 33, 22], 3) == [33]"}
{"id": "19", "testing_code": "assert get_minimum_painting_cost( [[7, 3, 8, 6, 1, 2], [5, 6, 7, 2, 4, 3], [10, 1, 4, 9, 7, 6]]) == 4\nassert get_minimum_painting_cost([[7, 3, 8, 6, 1, 2], [5, 6, 7, 2, 4, 3], [10, 1, 4, 9, 7, 6], [10, 1, 4, 9, 7, 6]]) == 8\nassert get_minimum_painting_cost([[17, 2, 17], [16, 16, 5], [14, 3, 9]]) == 10", "solution": "import sys\ndef get_minimum_painting_cost(cost_matrix):\n    num_houses = len(cost_matrix)\n    num_colors = len(cost_matrix[0])\n    if not cost_matrix:\n        return 0\n    prev_house_min = 0\n    prev_house_min_index = -1\n    prev_house_second_min = 0\n    for i in range(num_houses):\n        curr_house_min = sys.maxsize\n        curr_house_second_min = sys.maxsize\n        curr_house_min_index = 0\n        for j in range(num_colors):\n            if prev_house_min_index == j:\n                cost_matrix[i][j] += prev_house_second_min\n            else:\n                cost_matrix[i][j] += prev_house_min\n            if curr_house_min > cost_matrix[i][j]:\n                curr_house_second_min = curr_house_min\n                curr_house_min = cost_matrix[i][j]\n                curr_house_min_index = j\n            elif curr_house_second_min > cost_matrix[i][j]:\n                curr_house_second_min = cost_matrix[i][j]\n        prev_house_min = curr_house_min\n        prev_house_second_min = curr_house_second_min\n        prev_house_min_index = curr_house_min_index\n    return min(cost_matrix[num_houses - 1])\nassert get_minimum_painting_cost( [[7, 3, 8, 6, 1, 2], [5, 6, 7, 2, 4, 3], [10, 1, 4, 9, 7, 6]]) == 4\nassert get_minimum_painting_cost([[7, 3, 8, 6, 1, 2], [5, 6, 7, 2, 4, 3], [10, 1, 4, 9, 7, 6], [10, 1, 4, 9, 7, 6]]) == 8"}
{"id": "74", "solution": "def get_mult_count(n, x):\n    if n == 1:\n        return n\n    running_counter = 0\n    for i in range(1, n+1):\n        if x % i == 0 and x / i <= n:\n           running_counter+=1 \n    return running_counter", "testing_code": "assert get_mult_count(1, 1) == 1\nassert get_mult_count(6, 12) == 4\nassert get_mult_count(2, 4) == 1\nassert get_mult_count(3, 6) == 2\nassert get_mult_count(3, 9) == 1\nassert get_mult_count(3, 1) == 1"}
{"id": "75", "testing_code": "assert get_longest_inc_subseq([]) == 0\nassert get_longest_inc_subseq([0, 1]) == 2\nassert get_longest_inc_subseq([0, 2, 1]) == 2\nassert get_longest_inc_subseq([0, 1, 2]) == 3\nassert get_longest_inc_subseq([2, 1, 0]) == 1\nassert get_longest_inc_subseq([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]) == 6\nassert get_longest_inc_subseq([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert get_longest_inc_subseq([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6", "solution": "def get_longest_inc_subseq(arr):\n    if len(arr) == 0:\n        return 0\n    DP = [1]*len(arr)\n    LONGEST = [1]*len(arr)\n    for i in range(0, len(arr)):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                DP[i] = max(DP[i],DP[j]+1)\n        LONGEST[i] = max(DP[i],LONGEST[i-1])\n    return LONGEST[-1]", "entry_fn_name": "get_longest_inc_subseq"}
{"id": "79", "solution": "def can_edit(arr):\n    decr_pairs = 0\n    if not arr:\n        return False\n    prev = None\n    for i in range(0, len(arr)-1):\n        if arr[i] > arr[i + 1]:\n            if decr_pairs:\n                return False\n            if prev is not None:\n                if i+2 < len(arr) and arr[i] > arr[i+2] and prev > arr[i+1]:\n                    return False\n            decr_pairs += 1\n        prev = arr[i]\n    return True", "testing_code": "assert can_edit([10, 5, 7])\nassert not can_edit([10, 5, 1])\nassert can_edit([1, 10, 5, 7])\nassert can_edit([10, 5, 7]) == True\nassert can_edit([10, 5, 1]) == False\nassert can_edit([4, 2, 3]) == True\nassert can_edit([4, 2, 1]) == False\nassert can_edit([1, 1, 1]) == True\nassert can_edit([3, 4, 2, 3]) == False\nassert can_edit([2, 3, 3, 2, 4]) == True\nassert can_edit([5, 5, 3, 4]) == False\nassert can_edit([-1, 4, 2, 3]) == True"}
{"id": "2", "solution": "def get_factors(array):\n    if not array or len(array)==1: return array\n    cumulative_product = 1\n    right_prod_array = list()\n    for num in array:\n        cumulative_product *= num\n        right_prod_array.append(cumulative_product)\n    cumulative_product = 1\n    left_prod_array = list()\n    for num in array[::-1]:\n        cumulative_product *= num\n        left_prod_array.append(cumulative_product)\n    left_prod_array = left_prod_array[::-1]\n    output_array = list()\n    for i in range(len(array)):\n        num = None\n        if i == 0:\n            num = left_prod_array[i + 1]\n        elif i == len(array) - 1:\n            num = right_prod_array[i - 1]\n        else:\n            num = right_prod_array[i - 1] * left_prod_array[i + 1]\n        output_array.append(num)\n    return output_array", "testing_code": "assert get_factors([1, 2, 3, 4, 5]) == [120, 60, 40, 30, 24]\nassert get_factors([3, 2, 1]) == [2, 3, 6]\nassert get_factors([1]) == [1]\nassert get_factors([]) == []"}
{"id": "7", "testing_code": "\nassert get_message_count(\"81\") == 1\nassert get_message_count(\"11\") == 2\nassert get_message_count(\"111\") == 3\nassert get_message_count(\"1111\") == 5\nassert get_message_count(\"1311\") == 4\nassert get_message_count(\"1118111111131111111111111111111111111111111111333333333333333333333262626262626\") == 162442229760\nassert get_message_count('111') == 3\nassert get_message_count('12') == 2\nassert get_message_count('8') == 1\nassert get_message_count('26') == 2\nassert get_message_count('27') == 1\nassert get_message_count('226') == 3\nassert get_message_count('10') == 1\nassert get_message_count('11') == 2\nassert get_message_count('34') == 1\nassert get_message_count('0') == 0\nassert get_message_count('1') == 1", "solution": "def get_message_count(code_str):\n    c = [0]*len(code_str) + [1]\n\n    for i in range(len(code_str)-1,-1,-1):\n        if code_str[i].startswith('0'):\n            c[i] = 0\n        elif i == len(code_str) - 1:\n            c[i] = 1\n        else:\n            if int(code_str[i:i + 2]) <= 26:\n                c[i] = c[i + 2]\n            c[i] += c[i + 1]\n    return c[0]"}
{"id": "142", "solution": "def valid_paren(string):\n    def _valid_paren(string, stack=list()):\n        stack=stack or []\n        if not string and (not stack):\n            return True\n        elif not string:\n            return False\n        cchar = string[0]\n        remaining = string[1:]\n        if cchar == '*':\n            return _valid_paren('(' + remaining, stack) or _valid_paren(')' + remaining, stack) or _valid_paren(remaining, stack)\n        cstack = stack.copy()\n        if cchar == ')' and (not stack):\n            return False\n        elif cchar == ')':\n            cstack.pop()\n        else:\n            cstack.append(cchar)\n        return _valid_paren(remaining, cstack)\n    return _valid_paren(string)"}
